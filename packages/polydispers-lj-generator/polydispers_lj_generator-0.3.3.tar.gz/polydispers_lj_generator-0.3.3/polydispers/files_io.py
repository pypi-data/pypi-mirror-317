import os
from collections import namedtuple

import numpy as np
import yaml
from jinja2 import Environment, PackageLoader, select_autoescape

from polydispers.input_config import InputConfig
from polydispers.topology_config import TopologyConfig

# Define namedtuples for topology data
TopologyAtom = namedtuple("TopologyAtom", ["atom_id", "atom_name", "residue_id", "residue_name", "mass", "type_id"])
TopologyBond = namedtuple("TopologyBond", ["atom_i", "atom_j"])
TopologyData = namedtuple("TopologyData", ["chain_description", "bond_list", "box_size"])

# Initialize Jinja2 environment
env = Environment(
    loader=PackageLoader("polydispers", "templates"),
    autoescape=select_autoescape(),
    trim_blocks=True,
    lstrip_blocks=True,
)


def write_gro_file(
    filename: str,
    coordinates: np.ndarray,
    box_size: float,
    atomname: str = "C",
    resname: str = "MOL",
    title: str = "Generated by gro_writer",
) -> None:
    """
    Write a GRO format file with simplified inputs.

    Args:
        filename: Output .gro filename
        coordinates: Numpy array of shape (N, 3) containing x,y,z coordinates in nm
        box_size: Cubic box size in nm
        atomname: Name of all atoms (default: "C")
        resname: Name of all residues (default: "MOL")
        title: Title string
    """
    n_atoms = len(coordinates)

    with open(filename, "w") as f:
        # Write title line
        f.write(f"{title}\n")

        # Write number of atoms
        f.write(f"{n_atoms}\n")

        # Write atom information
        for i, (x, y, z) in enumerate(coordinates, start=1):
            resid = 1
            atomid = i
            line = f"{resid:>5d}{resname:<5s}{atomname:>5s}{atomid:>5d}"
            line += f"{x:8.3f}{y:8.3f}{z:8.3f}"
            f.write(line + "\n")

        # Write box vectors (cubic box)
        f.write(f"{box_size:10.5f}{box_size:10.5f}{box_size:10.5f}\n")


def write_pdb_file(
    filename: str,
    coordinates: np.ndarray,
    box_size: float,
    atomname: str = "C",
    resname: str = "MOL",
    title: str = "Generated by pdb_writer",
) -> None:
    """
    Write a PDB format file with simplified inputs.

    Args:
        filename: Output .pdb filename
        coordinates: Numpy array of shape (N, 3) containing x,y,z coordinates in nm
        box_size: Cubic box size in nm
        atomname: Name of all atoms (default: "C")
        resname: Name of all residues (default: "MOL")
        title: Title string

    PDB Format Reference:
    ATOM/HETATM (1-6)    Record name
    atom number (7-11)    Integer
    atom name (13-16)     Atom name
    alt loc (17)          Alternate location indicator
    residue name (18-20)  Residue name
    chain (22)            Chain identifier
    residue number (23-26) Integer
    x (31-38)            Real(8.3) Orthogonal coordinates for X
    y (39-46)            Real(8.3) Orthogonal coordinates for Y
    z (47-54)            Real(8.3) Orthogonal coordinates for Z
    occupancy (55-60)     Real(6.2)
    temp factor (61-66)   Real(6.2)
    segment id (73-76)    Segment identifier
    element (77-78)       Element symbol
    charge (79-80)        Charge
    """
    # Convert nm to Angstroms for PDB format
    coords_ang = coordinates * 10.0
    box_ang = box_size * 10.0
    resid = 1

    with open(filename, "w") as f:
        # Write title
        f.write(f"TITLE     {title}\n")
        f.write("REMARK    Generated by pdb_writer\n")

        # Write crystal structure (box size)
        # Format: CRYST1   50.000   50.000   50.000  90.00  90.00  90.00 P 1           1
        f.write(f"CRYST1{box_ang:9.3f}{box_ang:9.3f}{box_ang:9.3f}  90.00  90.00  90.00 P 1           1\n")

        # Write atom coordinates
        for i, (x, y, z) in enumerate(coords_ang, start=1):
            # Format each field according to PDB specifications
            record = "ATOM  "  # cols 1-6
            serial = f"{i:5d}"  # cols 7-11
            space1 = " "  # col 12
            atom = f"{atomname:<4s}"  # cols 13-16
            alt_loc = " "  # col 17
            res_name = f"{resname:<3s}"  # cols 18-20
            space2 = " "  # col 21
            chain = "A"  # col 22
            res_seq = f"{resid:4d}"  # cols 23-26
            ins_code = " "  # col 27
            space3 = "   "  # cols 28-30
            x_coord = f"{x:8.3f}"  # cols 31-38
            y_coord = f"{y:8.3f}"  # cols 39-46
            z_coord = f"{z:8.3f}"  # cols 47-54
            occupancy = f"{1.00:6.2f}"  # cols 55-60
            temp_factor = f"{0.00:6.2f}"  # cols 61-66
            space4 = "      "  # cols 67-72
            segment = f"{resname:<4s}"  # cols 73-76
            element = f"{atomname:>2s}"  # cols 77-78
            charge = "  "  # cols 79-80

            line = (
                f"{record}{serial}{space1}{atom}{alt_loc}{res_name}"
                f"{space2}{chain}{res_seq}{ins_code}{space3}"
                f"{x_coord}{y_coord}{z_coord}{occupancy}{temp_factor}"
                f"{space4}{segment}{element}{charge}\n"
            )

            f.write(line)

        # Write END record
        f.write("END\n")


def write_packmol_input(
    output_filename: str, filenames: list[str], box_size: float, output_packmol_filename: str, filetype: str = "xyz"
) -> None:
    with open(output_packmol_filename, "w") as f:
        f.write("tolerance 2.0\n")
        f.write(f"filetype {filetype}\n")
        f.write(f"output {output_filename}\n")
        for filename in filenames:
            f.write(
                f"""
structure {filename}
  number 1
  inside box 0 0 0 {box_size} {box_size} {box_size}
  resnumbers 2
end structure
      """
            )


def write_xyz_file(filename: str, coordinates: np.ndarray, atomname: str = "C") -> None:
    with open(filename, "w") as f:
        f.write(f"{len(coordinates)}\n")
        f.write("Generated by xyz_writer\n")
        for i, (x, y, z) in enumerate(coordinates, start=1):
            f.write(f"{atomname} {x} {y} {z}\n")


def write_topology_file(filename: str, config: InputConfig, num_repeat_units: list[int]) -> None:
    """Generates a topology file for the system.

    Args:
        filename: Output topology filename
        config: Input configuration containing topology and mass information
        num_repeat_units: List of number of repeat units for each chain
    """
    # Write YAML file
    with open(filename, "w+") as out_yaml:
        # Write box size
        out_yaml.write(f"box_size: {config.box_size}\n")

        # Write chain description
        out_yaml.write("chain_description:\n")
        out_yaml.write(f'    repeat_unit_topology: "{config.polymer.repeat_unit_topology}"\n')
        out_yaml.write("    chain_lengths: [")
        out_yaml.write(", ".join(map(str, num_repeat_units)))
        out_yaml.write("]\n")

        # Write polymer information
        out_yaml.write("polymer:\n")
        out_yaml.write("    bead_types:\n")
        for bead_type in set(config.polymer.repeat_unit_topology):
            out_yaml.write(f"        {bead_type}:\n")
            out_yaml.write(f"            mass: {config.polymer.bead_types[bead_type].mass}\n")
            out_yaml.write(f"            type_id: {config.polymer.bead_types[bead_type].type_id}\n")


def read_topology_file(filename: str) -> TopologyData:
    """Reads a topology file and returns chain_description, bond_list and box_size

    Args:
        filename: Path to the topology YAML file

    Returns:
        TopologyData containing:
        - chain_description: List of TopologyAtom(atom_id, atom_name, residue_id, residue_name, mass, type_id)
        - bond_list: List of TopologyBond(atom_i, atom_j)
        - box_size: Box size value
    """
    with open(filename, "r") as in_yaml:
        yaml_data = yaml.safe_load(in_yaml)

    topology = TopologyConfig.from_dict(yaml_data)

    # Generate chain description
    chain_description = []
    atom_id = 1

    # For each chain
    for chain_idx, num_units in enumerate(topology.chain_description.chain_lengths, start=1):
        # For each repeat unit in the chain
        for _ in range(num_units):
            # For each bead in the repeat unit topology
            for bead_type in topology.chain_description.repeat_unit_topology:
                chain_description.append(
                    TopologyAtom(
                        atom_id=atom_id,
                        atom_name=bead_type,
                        residue_id=chain_idx,
                        residue_name="MOL",
                        mass=topology.polymer.bead_types[bead_type].mass,
                        type_id=topology.polymer.bead_types[bead_type].type_id,
                    )
                )
                atom_id += 1

    # Generate bond list
    bond_list = []

    # For each chain
    for chain_idx, num_units in enumerate(topology.chain_description.chain_lengths):
        chain_start = (
            sum(
                len(topology.chain_description.repeat_unit_topology) * n
                for n in topology.chain_description.chain_lengths[:chain_idx]
            )
            + 1
        )
        chain_length = len(topology.chain_description.repeat_unit_topology) * num_units

        # Connect atoms within the chain
        for j in range(chain_start, chain_start + chain_length - 1):
            bond_list.append(TopologyBond(atom_i=j, atom_j=j + 1))

    return TopologyData(chain_description=chain_description, bond_list=bond_list, box_size=topology.box_size)


def write_lammps_input(filename: str, data_file: str, topology_data: TopologyData) -> None:
    """Write LAMMPS input script using Jinja2 template.

    Args:
        filename: Output LAMMPS input script filename
        data_file: Path to LAMMPS data file
        topology_data: Topology data containing atom types and masses
    """
    # Get unique masses for each type_id
    masses = {}
    for atom in topology_data.chain_description:
        if atom.type_id not in masses:
            masses[atom.type_id] = atom.mass

    # Get template and render
    template = env.get_template("lammps_in.j2")
    output_dir = os.path.dirname(os.path.abspath(data_file))

    rendered = template.render(data_file=data_file, output_dir=output_dir, masses=masses)

    # Write rendered template
    with open(filename, "w") as f:
        f.write(rendered)


def write_lammps_data(filename, coordinates, chain_description, bond_list, box_size):
    # Get unique atom types and their type_ids from the topology
    max_type_id = max(atom.type_id for atom in chain_description)

    with open(filename, "w+") as out_lmp:
        out_lmp.write("LAMMPS data file\n\n")
        out_lmp.write(f"{len(coordinates)} atoms\n")
        out_lmp.write(f"{len(bond_list)} bonds\n")
        out_lmp.write("\n")
        out_lmp.write(f"{max_type_id} atom types\n")
        out_lmp.write("1 bond types\n")
        out_lmp.write("\n")
        out_lmp.write(f"0.0 {box_size} xlo xhi\n")
        out_lmp.write(f"0.0 {box_size} ylo yhi\n")
        out_lmp.write(f"0.0 {box_size} zlo zhi\n")
        out_lmp.write("\n")
        out_lmp.write("Masses\n\n")
        # Write masses for each atom type
        for type_id in range(1, max_type_id + 1):
            # Find the first atom of this type_id to get its mass
            mass = next(atom.mass for atom in chain_description if atom.type_id == type_id)
            out_lmp.write(f"{type_id} {mass}\n")
        out_lmp.write("\n")
        out_lmp.write("Atoms\n\n")
        # Format: atom-ID molecule-ID atom-type x y z
        for i, atom in enumerate(chain_description, start=1):
            x, y, z = coordinates[i - 1]
            out_lmp.write(f"{i} {atom.residue_id} {atom.type_id} {x} {y} {z}\n")
        out_lmp.write("\n")
        out_lmp.write("Bonds\n\n")
        for i, bond in enumerate(bond_list, start=1):
            out_lmp.write(f"{i} 1 {bond.atom_i} {bond.atom_j}\n")
