{"version":3,"file":"tqZ92Wod.js","mappings":";;AAsBA;AACA;AACA;;AAGA;;ACYA;AACA;AACA;AACA;;AAEA;;AAKA;;;;;;;;;;;;AAgBA;;ACXA;;AAEA;;AAEA;AAEA;;;;;;;;;;;;;;;;;AAqFA;;AClIA;;;;;;;AAOA;AAIA;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;AA4BA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-icon-button-arrow-prev.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-icon-button.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-menu-button.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-svg-icon.ts"],"sourcesContent":["import { mdiArrowLeft, mdiArrowRight } from \"@mdi/js\";\nimport type { TemplateResult } from \"lit\";\nimport { html, LitElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { mainWindow } from \"../common/dom/get_main_window\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-icon-button\";\n\n@customElement(\"ha-icon-button-arrow-prev\")\nexport class HaIconButtonArrowPrev extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property() public label?: string;\n\n  @state() private _icon =\n    mainWindow.document.dir === \"rtl\" ? mdiArrowRight : mdiArrowLeft;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-icon-button\n        .disabled=${this.disabled}\n        .label=${this.label || this.hass?.localize(\"ui.common.back\") || \"Back\"}\n        .path=${this._icon}\n      ></ha-icon-button>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-icon-button-arrow-prev\": HaIconButtonArrowPrev;\n  }\n}\n","import \"@material/mwc-icon-button\";\nimport type { IconButton } from \"@material/mwc-icon-button\";\nimport type { CSSResultGroup, TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-icon-button\")\nexport class HaIconButton extends LitElement {\n  @property({ type: Boolean, reflect: true }) disabled = false;\n\n  // SVG icon path (if you need a non SVG icon instead, use the provided slot to pass an <ha-icon> in)\n  @property({ type: String }) path?: string;\n\n  // Label that is used for ARIA support and as tooltip\n  @property({ type: String }) label?: string;\n\n  // These should always be set as properties, not attributes,\n  // so that only the <button> element gets the attribute\n  @property({ type: String, attribute: \"aria-haspopup\" })\n  override ariaHasPopup!: IconButton[\"ariaHasPopup\"];\n\n  @property({ type: Boolean }) hideTitle = false;\n\n  @query(\"mwc-icon-button\", true) private _button?: IconButton;\n\n  public override focus() {\n    this._button?.focus();\n  }\n\n  static shadowRootOptions: ShadowRootInit = {\n    mode: \"open\",\n    delegatesFocus: true,\n  };\n\n  protected render(): TemplateResult {\n    return html`\n      <mwc-icon-button\n        aria-label=${ifDefined(this.label)}\n        title=${ifDefined(this.hideTitle ? undefined : this.label)}\n        aria-haspopup=${ifDefined(this.ariaHasPopup)}\n        .disabled=${this.disabled}\n      >\n        ${this.path\n          ? html`<ha-svg-icon .path=${this.path}></ha-svg-icon>`\n          : html`<slot></slot>`}\n      </mwc-icon-button>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n        outline: none;\n      }\n      :host([disabled]) {\n        pointer-events: none;\n      }\n      mwc-icon-button {\n        --mdc-theme-on-primary: currentColor;\n        --mdc-theme-text-disabled-on-light: var(--disabled-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-icon-button\": HaIconButton;\n  }\n}\n","import { mdiMenu } from \"@mdi/js\";\nimport type { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport type { CSSResultGroup } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { subscribeNotifications } from \"../data/persistent_notification\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-icon-button\";\n\n@customElement(\"ha-menu-button\")\nclass HaMenuButton extends LitElement {\n  @property({ type: Boolean }) public hassio = false;\n\n  @property({ type: Boolean }) public narrow = false;\n\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _hasNotifications = false;\n\n  @state() private _show = false;\n\n  private _alwaysVisible = false;\n\n  private _attachNotifOnConnect = false;\n\n  private _unsubNotifications?: UnsubscribeFunc;\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (this._attachNotifOnConnect) {\n      this._attachNotifOnConnect = false;\n      this._subscribeNotifications();\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this._unsubNotifications) {\n      this._attachNotifOnConnect = true;\n      this._unsubNotifications();\n      this._unsubNotifications = undefined;\n    }\n  }\n\n  protected render() {\n    if (!this._show) {\n      return nothing;\n    }\n    const hasNotifications =\n      this._hasNotifications &&\n      (this.narrow || this.hass.dockedSidebar === \"always_hidden\");\n    return html`\n      <ha-icon-button\n        .label=${this.hass.localize(\"ui.sidebar.sidebar_toggle\")}\n        .path=${mdiMenu}\n        @click=${this._toggleMenu}\n      ></ha-icon-button>\n      ${hasNotifications ? html`<div class=\"dot\"></div>` : \"\"}\n    `;\n  }\n\n  protected firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n    if (!this.hassio) {\n      return;\n    }\n    // This component is used on Hass.io too, but Hass.io might run the UI\n    // on older frontends too, that don't have an always visible menu button\n    // in the sidebar.\n    this._alwaysVisible =\n      (Number((window.parent as any).frontendVersion) || 0) < 20190710;\n  }\n\n  protected willUpdate(changedProps) {\n    super.willUpdate(changedProps);\n\n    if (!changedProps.has(\"narrow\") && !changedProps.has(\"hass\")) {\n      return;\n    }\n\n    const oldHass = changedProps.has(\"hass\")\n      ? (changedProps.get(\"hass\") as HomeAssistant | undefined)\n      : this.hass;\n    const oldNarrow = changedProps.has(\"narrow\")\n      ? (changedProps.get(\"narrow\") as boolean | undefined)\n      : this.narrow;\n\n    const oldShowButton =\n      oldNarrow || oldHass?.dockedSidebar === \"always_hidden\";\n    const showButton =\n      this.narrow || this.hass.dockedSidebar === \"always_hidden\";\n\n    if (this.hasUpdated && oldShowButton === showButton) {\n      return;\n    }\n\n    this._show = showButton || this._alwaysVisible;\n\n    if (!showButton) {\n      if (this._unsubNotifications) {\n        this._unsubNotifications();\n        this._unsubNotifications = undefined;\n      }\n      return;\n    }\n\n    this._subscribeNotifications();\n  }\n\n  private _subscribeNotifications() {\n    if (this._unsubNotifications) {\n      throw new Error(\"Already subscribed\");\n    }\n    this._unsubNotifications = subscribeNotifications(\n      this.hass.connection,\n      (notifications) => {\n        this._hasNotifications = notifications.length > 0;\n      }\n    );\n  }\n\n  private _toggleMenu(): void {\n    fireEvent(this, \"hass-toggle-menu\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        position: relative;\n      }\n      .dot {\n        pointer-events: none;\n        position: absolute;\n        background-color: var(--accent-color);\n        width: 12px;\n        height: 12px;\n        top: 9px;\n        right: 7px;\n        inset-inline-end: 7px;\n        inset-inline-start: initial;\n        border-radius: 50%;\n        border: 2px solid var(--app-header-background-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-menu-button\": HaMenuButton;\n  }\n}\n","import type { CSSResultGroup, SVGTemplateResult } from \"lit\";\nimport { css, LitElement, nothing, svg } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-svg-icon\")\nexport class HaSvgIcon extends LitElement {\n  @property() public path?: string;\n\n  @property() public secondaryPath?: string;\n\n  @property() public viewBox?: string;\n\n  protected render(): SVGTemplateResult {\n    return svg`\n    <svg\n      viewBox=${this.viewBox || \"0 0 24 24\"}\n      preserveAspectRatio=\"xMidYMid meet\"\n      focusable=\"false\"\n      role=\"img\"\n      aria-hidden=\"true\"\n    >\n      <g>\n        ${\n          this.path\n            ? svg`<path class=\"primary-path\" d=${this.path}></path>`\n            : nothing\n        }\n        ${\n          this.secondaryPath\n            ? svg`<path class=\"secondary-path\" d=${this.secondaryPath}></path>`\n            : nothing\n        }\n      </g>\n    </svg>`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: var(--ha-icon-display, inline-flex);\n        align-items: center;\n        justify-content: center;\n        position: relative;\n        vertical-align: middle;\n        fill: var(--icon-primary-color, currentcolor);\n        width: var(--mdc-icon-size, 24px);\n        height: var(--mdc-icon-size, 24px);\n      }\n      svg {\n        width: 100%;\n        height: 100%;\n        pointer-events: none;\n        display: block;\n      }\n      path.primary-path {\n        opacity: var(--icon-primary-opactity, 1);\n      }\n      path.secondary-path {\n        fill: var(--icon-secondary-color, currentcolor);\n        opacity: var(--icon-secondary-opactity, 0.5);\n      }\n    `;\n  }\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-svg-icon\": HaSvgIcon;\n  }\n}\n"],"names":[],"sourceRoot":""}