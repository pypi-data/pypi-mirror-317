{"version":3,"file":"YsV9mk7i.js","mappings":";AA6aA;AACA;AACA;AACA;;AAEA;;AAIA;AACA;AAEA;AAMA;;;;;;;;AAUA;;;AAIA;AAEA;;AAIA;;;AAGA;;AAIA;AACA;AAGA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AAGA;;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAoBA;AACA;AAKA;;;;AAQA;AACA;AACA;;AAEA;AASA;AAgDA;AAKA;AACA;AAGA;AACA;;AAVA;;AAcA;;;AAOA;;;AAKA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwRA;;AC32BA;;AAGA;;;ACdA;AACA;;AAEA;;AAEA;;AAEA;;AAKA;AACA;AACA;AAKA;AACA;AACA;;;;AAIA;AACA;;AAGA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-service-control.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-service-icon.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-service-picker.ts"],"sourcesContent":["import { mdiHelpCircle } from \"@mdi/js\";\nimport type {\n  HassService,\n  HassServices,\n  HassServiceTarget,\n} from \"home-assistant-js-websocket\";\nimport type { CSSResultGroup, PropertyValues } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { ensureArray } from \"../common/array/ensure-array\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport { computeObjectId } from \"../common/entity/compute_object_id\";\nimport { supportsFeature } from \"../common/entity/supports-feature\";\nimport {\n  fetchIntegrationManifest,\n  type IntegrationManifest,\n} from \"../data/integration\";\nimport {\n  areaMeetsTargetSelector,\n  deviceMeetsTargetSelector,\n  entityMeetsTargetSelector,\n  expandAreaTarget,\n  expandDeviceTarget,\n  expandFloorTarget,\n  expandLabelTarget,\n  type Selector,\n  type TargetSelector,\n} from \"../data/selector\";\nimport type { HomeAssistant, ValueChangedEvent } from \"../types\";\nimport { documentationUrl } from \"../util/documentation-url\";\nimport \"./ha-checkbox\";\nimport \"./ha-icon-button\";\nimport \"./ha-selector/ha-selector\";\nimport \"./ha-service-picker\";\nimport \"./ha-settings-row\";\nimport \"./ha-yaml-editor\";\nimport type { HaYamlEditor } from \"./ha-yaml-editor\";\nimport \"./ha-service-section-icon\";\n\nconst attributeFilter = (values: any[], attribute: any) => {\n  if (typeof attribute === \"object\") {\n    if (Array.isArray(attribute)) {\n      return attribute.some((item) => values.includes(item));\n    }\n    return false;\n  }\n  return values.includes(attribute);\n};\n\nconst showOptionalToggle = (field) =>\n  field.selector &&\n  !field.required &&\n  !(\"boolean\" in field.selector && field.default);\n\ninterface Field extends Omit<HassService[\"fields\"][string], \"selector\"> {\n  key: string;\n  selector?: Selector;\n}\n\ninterface ExtHassService extends Omit<HassService, \"fields\"> {\n  fields: Array<\n    Omit<HassService[\"fields\"][string], \"selector\"> & {\n      key: string;\n      selector?: Selector;\n      fields?: Record<string, Omit<HassService[\"fields\"][string], \"selector\">>;\n      collapsed?: boolean;\n    }\n  >;\n  flatFields: Array<Field>;\n  hasSelector: string[];\n}\n\n@customElement(\"ha-service-control\")\nexport class HaServiceControl extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public value?: {\n    action: string;\n    target?: HassServiceTarget;\n    data?: Record<string, any>;\n  };\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean, reflect: true }) public narrow = false;\n\n  @property({ type: Boolean }) public showAdvanced = false;\n\n  @property({ type: Boolean, reflect: true }) public hidePicker = false;\n\n  @property({ type: Boolean }) public hideDescription = false;\n\n  @state() private _value!: this[\"value\"];\n\n  @state() private _checkedKeys = new Set();\n\n  @state() private _manifest?: IntegrationManifest;\n\n  @query(\"ha-yaml-editor\") private _yamlEditor?: HaYamlEditor;\n\n  protected willUpdate(changedProperties: PropertyValues<this>) {\n    if (!this.hasUpdated) {\n      this.hass.loadBackendTranslation(\"services\");\n      this.hass.loadBackendTranslation(\"selector\");\n    }\n    if (!changedProperties.has(\"value\")) {\n      return;\n    }\n    const oldValue = changedProperties.get(\"value\") as\n      | undefined\n      | this[\"value\"];\n\n    if (oldValue?.action !== this.value?.action) {\n      this._checkedKeys = new Set();\n    }\n\n    const serviceData = this._getServiceInfo(\n      this.value?.action,\n      this.hass.services\n    );\n\n    // Fetch the manifest if we have a service selected and the service domain changed.\n    // If no service is selected, clear the manifest.\n    if (this.value?.action) {\n      if (\n        !oldValue?.action ||\n        computeDomain(this.value.action) !== computeDomain(oldValue.action)\n      ) {\n        this._fetchManifest(computeDomain(this.value?.action));\n      }\n    } else {\n      this._manifest = undefined;\n    }\n\n    if (\n      serviceData &&\n      \"target\" in serviceData &&\n      (this.value?.data?.entity_id ||\n        this.value?.data?.area_id ||\n        this.value?.data?.device_id)\n    ) {\n      const target = {\n        ...this.value.target,\n      };\n\n      if (this.value.data.entity_id && !this.value.target?.entity_id) {\n        target.entity_id = this.value.data.entity_id;\n      }\n      if (this.value.data.area_id && !this.value.target?.area_id) {\n        target.area_id = this.value.data.area_id;\n      }\n      if (this.value.data.device_id && !this.value.target?.device_id) {\n        target.device_id = this.value.data.device_id;\n      }\n\n      this._value = {\n        ...this.value,\n        target,\n        data: { ...this.value.data },\n      };\n\n      delete this._value.data!.entity_id;\n      delete this._value.data!.device_id;\n      delete this._value.data!.area_id;\n    } else {\n      this._value = this.value;\n    }\n\n    if (oldValue?.action !== this.value?.action) {\n      let updatedDefaultValue = false;\n      if (this._value && serviceData) {\n        const loadDefaults = this.value && !(\"data\" in this.value);\n        // Set mandatory bools without a default value to false\n        if (!this._value.data) {\n          this._value.data = {};\n        }\n        serviceData.flatFields.forEach((field) => {\n          if (\n            field.selector &&\n            field.required &&\n            field.default === undefined &&\n            \"boolean\" in field.selector &&\n            this._value!.data![field.key] === undefined\n          ) {\n            updatedDefaultValue = true;\n            this._value!.data![field.key] = false;\n          }\n          if (\n            loadDefaults &&\n            field.selector &&\n            field.default !== undefined &&\n            this._value!.data![field.key] === undefined\n          ) {\n            updatedDefaultValue = true;\n            this._value!.data![field.key] = field.default;\n          }\n        });\n      }\n      if (updatedDefaultValue) {\n        fireEvent(this, \"value-changed\", {\n          value: {\n            ...this._value,\n          },\n        });\n      }\n    }\n\n    if (this._value?.data) {\n      const yamlEditor = this._yamlEditor;\n      if (yamlEditor && yamlEditor.value !== this._value.data) {\n        yamlEditor.setValue(this._value.data);\n      }\n    }\n  }\n\n  private _getServiceInfo = memoizeOne(\n    (\n      service?: string,\n      serviceDomains?: HassServices\n    ): ExtHassService | undefined => {\n      if (!service || !serviceDomains) {\n        return undefined;\n      }\n      const domain = computeDomain(service);\n      const serviceName = computeObjectId(service);\n      if (!(domain in serviceDomains)) {\n        return undefined;\n      }\n      if (!(serviceName in serviceDomains[domain])) {\n        return undefined;\n      }\n\n      const fields = Object.entries(\n        serviceDomains[domain][serviceName].fields\n      ).map(([key, value]) => ({\n        key,\n        ...value,\n        selector: value.selector as Selector | undefined,\n      }));\n\n      const flatFields: Field[] = [];\n      const hasSelector: string[] = [];\n      fields.forEach((field) => {\n        if ((field as any).fields) {\n          Object.entries((field as any).fields).forEach(([key, subField]) => {\n            flatFields.push({ ...(subField as Field), key });\n            if ((subField as any).selector) {\n              hasSelector.push(key);\n            }\n          });\n        } else {\n          flatFields.push(field);\n          if (field.selector) {\n            hasSelector.push(field.key);\n          }\n        }\n      });\n\n      return {\n        ...serviceDomains[domain][serviceName],\n        fields,\n        flatFields,\n        hasSelector,\n      };\n    }\n  );\n\n  private _getTargetedEntities = memoizeOne((target, value) => {\n    const targetSelector = target ? { target } : { target: {} };\n    const targetEntities =\n      ensureArray(\n        value?.target?.entity_id || value?.data?.entity_id\n      )?.slice() || [];\n    const targetDevices =\n      ensureArray(\n        value?.target?.device_id || value?.data?.device_id\n      )?.slice() || [];\n    const targetAreas =\n      ensureArray(value?.target?.area_id || value?.data?.area_id)?.slice() ||\n      [];\n    const targetFloors = ensureArray(\n      value?.target?.floor_id || value?.data?.floor_id\n    )?.slice();\n    const targetLabels = ensureArray(\n      value?.target?.label_id || value?.data?.label_id\n    )?.slice();\n    if (targetLabels) {\n      targetLabels.forEach((labelId) => {\n        const expanded = expandLabelTarget(\n          this.hass,\n          labelId,\n          this.hass.areas,\n          this.hass.devices,\n          this.hass.entities,\n          targetSelector\n        );\n        targetDevices.push(...expanded.devices);\n        targetEntities.push(...expanded.entities);\n        targetAreas.push(...expanded.areas);\n      });\n    }\n    if (targetFloors) {\n      targetFloors.forEach((floorId) => {\n        const expanded = expandFloorTarget(\n          this.hass,\n          floorId,\n          this.hass.areas,\n          targetSelector\n        );\n        targetAreas.push(...expanded.areas);\n      });\n    }\n    if (targetAreas.length) {\n      targetAreas.forEach((areaId) => {\n        const expanded = expandAreaTarget(\n          this.hass,\n          areaId,\n          this.hass.devices,\n          this.hass.entities,\n          targetSelector\n        );\n        targetEntities.push(...expanded.entities);\n        targetDevices.push(...expanded.devices);\n      });\n    }\n    if (targetDevices.length) {\n      targetDevices.forEach((deviceId) => {\n        targetEntities.push(\n          ...expandDeviceTarget(\n            this.hass,\n            deviceId,\n            this.hass.entities,\n            targetSelector\n          ).entities\n        );\n      });\n    }\n    return targetEntities;\n  });\n\n  private _filterField(\n    filter: ExtHassService[\"fields\"][number][\"filter\"],\n    targetEntities: string[]\n  ) {\n    if (!targetEntities.length) {\n      return false;\n    }\n    if (\n      targetEntities.some((entityId) => {\n        const entityState = this.hass.states[entityId];\n        if (!entityState) {\n          return false;\n        }\n        if (\n          filter!.supported_features?.some((feature) =>\n            supportsFeature(entityState, feature)\n          )\n        ) {\n          return true;\n        }\n        if (\n          filter!.attribute &&\n          Object.entries(filter!.attribute).some(\n            ([attribute, values]) =>\n              attribute in entityState.attributes &&\n              attributeFilter(values, entityState.attributes[attribute])\n          )\n        ) {\n          return true;\n        }\n        return false;\n      })\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private _targetSelector = memoizeOne(\n    (targetSelector: TargetSelector | null | undefined) =>\n      targetSelector ? { target: { ...targetSelector } } : { target: {} }\n  );\n\n  protected render() {\n    const serviceData = this._getServiceInfo(\n      this._value?.action,\n      this.hass.services\n    );\n\n    const shouldRenderServiceDataYaml =\n      (serviceData?.fields.length && !serviceData.hasSelector.length) ||\n      (serviceData &&\n        Object.keys(this._value?.data || {}).some(\n          (key) => !serviceData!.hasSelector.includes(key)\n        ));\n\n    const entityId =\n      shouldRenderServiceDataYaml &&\n      serviceData?.fields.find((field) => field.key === \"entity_id\");\n\n    const hasOptional = Boolean(\n      !shouldRenderServiceDataYaml &&\n        serviceData?.flatFields.some((field) => showOptionalToggle(field))\n    );\n\n    const targetEntities = this._getTargetedEntities(\n      serviceData?.target,\n      this._value\n    );\n\n    const domain = this._value?.action\n      ? computeDomain(this._value.action)\n      : undefined;\n    const serviceName = this._value?.action\n      ? computeObjectId(this._value.action)\n      : undefined;\n\n    const description =\n      (serviceName &&\n        this.hass.localize(\n          `component.${domain}.services.${serviceName}.description`\n        )) ||\n      serviceData?.description;\n\n    return html`${this.hidePicker\n      ? nothing\n      : html`<ha-service-picker\n          .hass=${this.hass}\n          .value=${this._value?.action}\n          .disabled=${this.disabled}\n          @value-changed=${this._serviceChanged}\n        ></ha-service-picker>`}\n    ${this.hideDescription\n      ? nothing\n      : html`\n          <div class=\"description\">\n            ${description ? html`<p>${description}</p>` : \"\"}\n            ${this._manifest\n              ? html` <a\n                  href=${this._manifest.is_built_in\n                    ? documentationUrl(\n                        this.hass,\n                        `/integrations/${this._manifest.domain}`\n                      )\n                    : this._manifest.documentation}\n                  title=${this.hass.localize(\n                    \"ui.components.service-control.integration_doc\"\n                  )}\n                  target=\"_blank\"\n                  rel=\"noreferrer\"\n                >\n                  <ha-icon-button\n                    .path=${mdiHelpCircle}\n                    class=\"help-icon\"\n                  ></ha-icon-button>\n                </a>`\n              : nothing}\n          </div>\n        `}\n    ${serviceData && \"target\" in serviceData\n      ? html`<ha-settings-row .narrow=${this.narrow}>\n          ${hasOptional\n            ? html`<div slot=\"prefix\" class=\"checkbox-spacer\"></div>`\n            : \"\"}\n          <span slot=\"heading\"\n            >${this.hass.localize(\"ui.components.service-control.target\")}</span\n          >\n          <span slot=\"description\"\n            >${this.hass.localize(\n              \"ui.components.service-control.target_secondary\"\n            )}</span\n          ><ha-selector\n            .hass=${this.hass}\n            .selector=${this._targetSelector(\n              serviceData.target as TargetSelector\n            )}\n            .disabled=${this.disabled}\n            @value-changed=${this._targetChanged}\n            .value=${this._value?.target}\n          ></ha-selector\n        ></ha-settings-row>`\n      : entityId\n        ? html`<ha-entity-picker\n            .hass=${this.hass}\n            .disabled=${this.disabled}\n            .value=${this._value?.data?.entity_id}\n            .label=${this.hass.localize(\n              `component.${domain}.services.${serviceName}.fields.entity_id.description`\n            ) || entityId.description}\n            @value-changed=${this._entityPicked}\n            allow-custom-entity\n          ></ha-entity-picker>`\n        : \"\"}\n    ${shouldRenderServiceDataYaml\n      ? html`<ha-yaml-editor\n          .hass=${this.hass}\n          .label=${this.hass.localize(\n            \"ui.components.service-control.action_data\"\n          )}\n          .name=${\"data\"}\n          .readOnly=${this.disabled}\n          .defaultValue=${this._value?.data}\n          @value-changed=${this._dataChanged}\n        ></ha-yaml-editor>`\n      : serviceData?.fields.map((dataField) => {\n          if (!dataField.fields) {\n            return this._renderField(\n              dataField,\n              hasOptional,\n              domain,\n              serviceName,\n              targetEntities\n            );\n          }\n\n          const fields = Object.entries(dataField.fields).map(\n            ([key, field]) => ({ key, ...field })\n          );\n\n          return fields.length &&\n            this._hasFilteredFields(fields, targetEntities)\n            ? html`<ha-expansion-panel\n                leftChevron\n                .expanded=${!dataField.collapsed}\n                .header=${this.hass.localize(\n                  `component.${domain}.services.${serviceName}.sections.${dataField.key}.name`\n                ) ||\n                dataField.name ||\n                dataField.key}\n                .secondary=${this._getSectionDescription(\n                  dataField,\n                  domain,\n                  serviceName\n                )}\n              >\n                <ha-service-section-icon\n                  slot=\"icons\"\n                  .hass=${this.hass}\n                  .service=${this._value!.action}\n                  .section=${dataField.key}\n                ></ha-service-section-icon>\n                ${Object.entries(dataField.fields).map(([key, field]) =>\n                  this._renderField(\n                    { key, ...field },\n                    hasOptional,\n                    domain,\n                    serviceName,\n                    targetEntities\n                  )\n                )}\n              </ha-expansion-panel>`\n            : nothing;\n        })} `;\n  }\n\n  private _getSectionDescription(\n    dataField: ExtHassService[\"fields\"][number],\n    domain: string | undefined,\n    serviceName: string | undefined\n  ) {\n    return this.hass!.localize(\n      `component.${domain}.services.${serviceName}.sections.${dataField.key}.description`\n    );\n  }\n\n  private _hasFilteredFields(\n    dataFields: ExtHassService[\"fields\"],\n    targetEntities: string[]\n  ) {\n    return dataFields.some(\n      (dataField) =>\n        !dataField.filter || this._filterField(dataField.filter, targetEntities)\n    );\n  }\n\n  private _renderField = (\n    dataField: ExtHassService[\"fields\"][number],\n    hasOptional: boolean,\n    domain: string | undefined,\n    serviceName: string | undefined,\n    targetEntities: string[]\n  ) => {\n    if (\n      dataField.filter &&\n      !this._filterField(dataField.filter, targetEntities)\n    ) {\n      return nothing;\n    }\n\n    const selector = dataField?.selector ?? { text: undefined };\n\n    const showOptional = showOptionalToggle(dataField);\n\n    return dataField.selector &&\n      (!dataField.advanced ||\n        this.showAdvanced ||\n        (this._value?.data && this._value.data[dataField.key] !== undefined))\n      ? html`<ha-settings-row .narrow=${this.narrow}>\n          ${!showOptional\n            ? hasOptional\n              ? html`<div slot=\"prefix\" class=\"checkbox-spacer\"></div>`\n              : \"\"\n            : html`<ha-checkbox\n                .key=${dataField.key}\n                .checked=${this._checkedKeys.has(dataField.key) ||\n                (this._value?.data &&\n                  this._value.data[dataField.key] !== undefined)}\n                .disabled=${this.disabled}\n                @change=${this._checkboxChanged}\n                slot=\"prefix\"\n              ></ha-checkbox>`}\n          <span slot=\"heading\"\n            >${this.hass.localize(\n              `component.${domain}.services.${serviceName}.fields.${dataField.key}.name`\n            ) ||\n            dataField.name ||\n            dataField.key}</span\n          >\n          <span slot=\"description\"\n            >${this.hass.localize(\n              `component.${domain}.services.${serviceName}.fields.${dataField.key}.description`\n            ) || dataField?.description}</span\n          >\n          <ha-selector\n            .disabled=${this.disabled ||\n            (showOptional &&\n              !this._checkedKeys.has(dataField.key) &&\n              (!this._value?.data ||\n                this._value.data[dataField.key] === undefined))}\n            .hass=${this.hass}\n            .selector=${selector}\n            .key=${dataField.key}\n            @value-changed=${this._serviceDataChanged}\n            .value=${this._value?.data\n              ? this._value.data[dataField.key]\n              : undefined}\n            .placeholder=${dataField.default}\n            .localizeValue=${this._localizeValueCallback}\n          ></ha-selector>\n        </ha-settings-row>`\n      : \"\";\n  };\n\n  private _localizeValueCallback = (key: string) => {\n    if (!this._value?.action) {\n      return \"\";\n    }\n    return this.hass.localize(\n      `component.${computeDomain(this._value.action)}.selector.${key}`\n    );\n  };\n\n  private _checkboxChanged(ev) {\n    const checked = ev.currentTarget.checked;\n    const key = ev.currentTarget.key;\n    let data;\n\n    if (checked) {\n      this._checkedKeys.add(key);\n      const field = this._getServiceInfo(\n        this._value?.action,\n        this.hass.services\n      )?.flatFields.find((_field) => _field.key === key);\n\n      let defaultValue = field?.default;\n\n      if (\n        defaultValue == null &&\n        field?.selector &&\n        \"constant\" in field.selector\n      ) {\n        defaultValue = field.selector.constant?.value;\n      }\n\n      if (\n        defaultValue == null &&\n        field?.selector &&\n        \"boolean\" in field.selector\n      ) {\n        defaultValue = false;\n      }\n\n      if (defaultValue != null) {\n        data = {\n          ...this._value?.data,\n          [key]: defaultValue,\n        };\n      }\n    } else {\n      this._checkedKeys.delete(key);\n      data = { ...this._value?.data };\n      delete data[key];\n    }\n    if (data) {\n      fireEvent(this, \"value-changed\", {\n        value: {\n          ...this._value,\n          data,\n        },\n      });\n    }\n    this.requestUpdate(\"_checkedKeys\");\n  }\n\n  private _serviceChanged(ev: ValueChangedEvent<string>) {\n    ev.stopPropagation();\n    if (ev.detail.value === this._value?.action) {\n      return;\n    }\n\n    const newService = ev.detail.value || \"\";\n    let target: HassServiceTarget | undefined;\n\n    if (newService) {\n      const serviceData = this._getServiceInfo(newService, this.hass.services);\n      const currentTarget = this._value?.target;\n      if (currentTarget && serviceData?.target) {\n        const targetSelector = { target: { ...serviceData.target } };\n        let targetEntities =\n          ensureArray(\n            currentTarget.entity_id || this._value!.data?.entity_id\n          )?.slice() || [];\n        let targetDevices =\n          ensureArray(\n            currentTarget.device_id || this._value!.data?.device_id\n          )?.slice() || [];\n        let targetAreas =\n          ensureArray(\n            currentTarget.area_id || this._value!.data?.area_id\n          )?.slice() || [];\n        if (targetAreas.length) {\n          targetAreas = targetAreas.filter((area) =>\n            areaMeetsTargetSelector(\n              this.hass,\n              this.hass.entities,\n              this.hass.devices,\n              area,\n              targetSelector\n            )\n          );\n        }\n        if (targetDevices.length) {\n          targetDevices = targetDevices.filter((device) =>\n            deviceMeetsTargetSelector(\n              this.hass,\n              Object.values(this.hass.entities),\n              this.hass.devices[device],\n              targetSelector\n            )\n          );\n        }\n        if (targetEntities.length) {\n          targetEntities = targetEntities.filter((entity) =>\n            entityMeetsTargetSelector(this.hass.states[entity], targetSelector)\n          );\n        }\n        target = {\n          ...(targetEntities.length ? { entity_id: targetEntities } : {}),\n          ...(targetDevices.length ? { device_id: targetDevices } : {}),\n          ...(targetAreas.length ? { area_id: targetAreas } : {}),\n        };\n      }\n    }\n\n    const value = {\n      action: newService,\n      target,\n    };\n\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  private _entityPicked(ev: CustomEvent) {\n    ev.stopPropagation();\n    const newValue = ev.detail.value;\n    if (this._value?.data?.entity_id === newValue) {\n      return;\n    }\n    let value;\n    if (!newValue && this._value?.data) {\n      value = { ...this._value };\n      delete value.data.entity_id;\n    } else {\n      value = {\n        ...this._value,\n        data: { ...this._value?.data, entity_id: ev.detail.value },\n      };\n    }\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  private _targetChanged(ev: CustomEvent) {\n    ev.stopPropagation();\n    const newValue = ev.detail.value;\n    if (this._value?.target === newValue) {\n      return;\n    }\n    let value;\n    if (!newValue) {\n      value = { ...this._value };\n      delete value.target;\n    } else {\n      value = { ...this._value, target: ev.detail.value };\n    }\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  private _serviceDataChanged(ev: CustomEvent) {\n    ev.stopPropagation();\n    const key = (ev.currentTarget as any).key;\n    const value = ev.detail.value;\n    if (\n      this._value?.data?.[key] === value ||\n      ((!this._value?.data || !(key in this._value.data)) &&\n        (value === \"\" || value === undefined))\n    ) {\n      return;\n    }\n\n    const data = { ...this._value?.data, [key]: value };\n\n    if (value === \"\" || value === undefined) {\n      delete data[key];\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value: {\n        ...this._value,\n        data,\n      },\n    });\n  }\n\n  private _dataChanged(ev: CustomEvent) {\n    ev.stopPropagation();\n    if (!ev.detail.isValid) {\n      return;\n    }\n    fireEvent(this, \"value-changed\", {\n      value: {\n        ...this._value,\n        data: ev.detail.value,\n      },\n    });\n  }\n\n  private async _fetchManifest(integration: string) {\n    this._manifest = undefined;\n    try {\n      this._manifest = await fetchIntegrationManifest(this.hass, integration);\n    } catch (err: any) {\n      // Ignore if loading manifest fails. Probably bad JSON in manifest\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-settings-row {\n        padding: var(--service-control-padding, 0 16px);\n      }\n      ha-settings-row {\n        --paper-time-input-justify-content: flex-end;\n        --settings-row-content-width: 100%;\n        --settings-row-prefix-display: contents;\n        border-top: var(\n          --service-control-items-border-top,\n          1px solid var(--divider-color)\n        );\n      }\n      ha-service-picker,\n      ha-entity-picker,\n      ha-yaml-editor {\n        display: block;\n        margin: var(--service-control-padding, 0 16px);\n      }\n      ha-yaml-editor {\n        padding: 16px 0;\n      }\n      p {\n        margin: var(--service-control-padding, 0 16px);\n        padding: 16px 0;\n      }\n      :host([hidePicker]) p {\n        padding-top: 0;\n      }\n      .checkbox-spacer {\n        width: 32px;\n      }\n      ha-checkbox {\n        margin-left: -16px;\n        margin-inline-start: -16px;\n        margin-inline-end: initial;\n      }\n      .help-icon {\n        color: var(--secondary-text-color);\n      }\n      .description {\n        justify-content: space-between;\n        display: flex;\n        align-items: center;\n        padding-right: 2px;\n        padding-inline-end: 2px;\n        padding-inline-start: initial;\n      }\n      .description p {\n        direction: ltr;\n      }\n      ha-expansion-panel {\n        --ha-card-border-radius: 0;\n        --expansion-panel-summary-padding: 0 16px;\n        --expansion-panel-content-padding: 0;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-service-control\": HaServiceControl;\n  }\n}\n","import { html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { until } from \"lit/directives/until\";\nimport { DEFAULT_SERVICE_ICON, FIXED_DOMAIN_ICONS } from \"../common/const\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport { serviceIcon } from \"../data/icons\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-icon\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-service-icon\")\nexport class HaServiceIcon extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public service?: string;\n\n  @property() public icon?: string;\n\n  protected render() {\n    if (this.icon) {\n      return html`<ha-icon .icon=${this.icon}></ha-icon>`;\n    }\n\n    if (!this.service) {\n      return nothing;\n    }\n\n    if (!this.hass) {\n      return this._renderFallback();\n    }\n\n    const icon = serviceIcon(this.hass, this.service).then((icn) => {\n      if (icn) {\n        return html`<ha-icon .icon=${icn}></ha-icon>`;\n      }\n      return this._renderFallback();\n    });\n\n    return html`${until(icon)}`;\n  }\n\n  private _renderFallback() {\n    const domain = computeDomain(this.service!);\n\n    return html`\n      <ha-svg-icon\n        .path=${FIXED_DOMAIN_ICONS[domain] || DEFAULT_SERVICE_ICON}\n      ></ha-svg-icon>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-service-icon\": HaServiceIcon;\n  }\n}\n","import type { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { html, LitElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport type { LocalizeFunc } from \"../common/translations/localize\";\nimport { domainToName } from \"../data/integration\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-combo-box\";\nimport \"./ha-list-item\";\nimport \"./ha-service-icon\";\nimport { getServiceIcons } from \"../data/icons\";\n\n@customElement(\"ha-service-picker\")\nclass HaServicePicker extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property() public value?: string;\n\n  @state() private _filter?: string;\n\n  protected willUpdate() {\n    if (!this.hasUpdated) {\n      this.hass.loadBackendTranslation(\"services\");\n      getServiceIcons(this.hass);\n    }\n  }\n\n  private _rowRenderer: ComboBoxLitRenderer<{ service: string; name: string }> =\n    (item) =>\n      html`<ha-list-item twoline graphic=\"icon\">\n        <ha-service-icon\n          slot=\"graphic\"\n          .hass=${this.hass}\n          .service=${item.service}\n        ></ha-service-icon>\n        <span>${item.name}</span>\n        <span slot=\"secondary\"\n          >${item.name === item.service ? \"\" : item.service}</span\n        >\n      </ha-list-item>`;\n\n  protected render() {\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .label=${this.hass.localize(\"ui.components.service-picker.action\")}\n        .filteredItems=${this._filteredServices(\n          this.hass.localize,\n          this.hass.services,\n          this._filter\n        )}\n        .value=${this.value}\n        .disabled=${this.disabled}\n        .renderer=${this._rowRenderer}\n        item-value-path=\"service\"\n        item-label-path=\"name\"\n        allow-custom-value\n        @filter-changed=${this._filterChanged}\n        @value-changed=${this._valueChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private _services = memoizeOne(\n    (\n      localize: LocalizeFunc,\n      services: HomeAssistant[\"services\"]\n    ): {\n      service: string;\n      name: string;\n    }[] => {\n      if (!services) {\n        return [];\n      }\n      const result: { service: string; name: string }[] = [];\n\n      Object.keys(services)\n        .sort()\n        .forEach((domain) => {\n          const services_keys = Object.keys(services[domain]).sort();\n\n          for (const service of services_keys) {\n            result.push({\n              service: `${domain}.${service}`,\n              name: `${domainToName(localize, domain)}: ${\n                this.hass.localize(\n                  `component.${domain}.services.${service}.name`\n                ) ||\n                services[domain][service].name ||\n                service\n              }`,\n            });\n          }\n        });\n\n      return result;\n    }\n  );\n\n  private _filteredServices = memoizeOne(\n    (\n      localize: LocalizeFunc,\n      services: HomeAssistant[\"services\"],\n      filter?: string\n    ) => {\n      if (!services) {\n        return [];\n      }\n      const processedServices = this._services(localize, services);\n\n      if (!filter) {\n        return processedServices;\n      }\n      const split_filter = filter.split(\" \");\n      return processedServices.filter((service) => {\n        const lower_service_name = service.name.toLowerCase();\n        const lower_service = service.service.toLowerCase();\n        return split_filter.every(\n          (f) => lower_service_name.includes(f) || lower_service.includes(f)\n        );\n      });\n    }\n  );\n\n  private _filterChanged(ev: CustomEvent): void {\n    this._filter = ev.detail.value.toLowerCase();\n  }\n\n  private _valueChanged(ev) {\n    this.value = ev.detail.value;\n    fireEvent(this, \"change\");\n    fireEvent(this, \"value-changed\", { value: this.value });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-service-picker\": HaServicePicker;\n  }\n}\n"],"names":[],"sourceRoot":""}