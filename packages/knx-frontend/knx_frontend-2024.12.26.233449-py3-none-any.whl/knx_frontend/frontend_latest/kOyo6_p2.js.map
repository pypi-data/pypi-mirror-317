{"version":3,"file":"kOyo6_p2.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AA0EA;;ACOA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgIA;;AC5KA;;AAGA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/data/camera.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/entity/state-badge.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-state-icon.ts"],"sourcesContent":["import type {\n  HassEntityAttributeBase,\n  HassEntityBase,\n} from \"home-assistant-js-websocket\";\nimport { timeCacheEntityPromiseFunc } from \"../common/util/time-cache-entity-promise-func\";\nimport type { HomeAssistant } from \"../types\";\nimport { getSignedPath } from \"./auth\";\n\nexport const CAMERA_ORIENTATIONS = [1, 2, 3, 4, 6, 8];\nexport const CAMERA_SUPPORT_ON_OFF = 1;\nexport const CAMERA_SUPPORT_STREAM = 2;\n\nexport const STREAM_TYPE_HLS = \"hls\";\nexport const STREAM_TYPE_WEB_RTC = \"web_rtc\";\n\nexport type StreamType = typeof STREAM_TYPE_HLS | typeof STREAM_TYPE_WEB_RTC;\n\ninterface CameraEntityAttributes extends HassEntityAttributeBase {\n  model_name: string;\n  access_token: string;\n  brand: string;\n  motion_detection: boolean;\n  frontend_stream_type: string;\n}\n\nexport interface CameraEntity extends HassEntityBase {\n  attributes: CameraEntityAttributes;\n}\n\nexport interface CameraPreferences {\n  preload_stream: boolean;\n  orientation: number;\n}\n\nexport interface CameraThumbnail {\n  content_type: string;\n  content: string;\n}\n\nexport interface Stream {\n  url: string;\n}\n\nexport type WebRtcOfferEvent =\n  | WebRtcId\n  | WebRtcAnswer\n  | WebRtcCandidate\n  | WebRtcError;\n\nexport interface WebRtcId {\n  type: \"session\";\n  session_id: string;\n}\n\nexport interface WebRtcAnswer {\n  type: \"answer\";\n  answer: string;\n}\n\nexport interface WebRtcCandidate {\n  type: \"candidate\";\n  candidate: string;\n}\n\nexport interface WebRtcError {\n  type: \"error\";\n  code: string;\n  message: string;\n}\n\nexport interface WebRtcOfferResponse {\n  id: string;\n}\n\nexport const cameraUrlWithWidthHeight = (\n  base_url: string,\n  width: number,\n  height: number\n) => `${base_url}&width=${width}&height=${height}`;\n\nexport const computeMJPEGStreamUrl = (entity: CameraEntity) =>\n  `/api/camera_proxy_stream/${entity.entity_id}?token=${entity.attributes.access_token}`;\n\nexport const fetchThumbnailUrlWithCache = async (\n  hass: HomeAssistant,\n  entityId: string,\n  width: number,\n  height: number\n) => {\n  const base_url = await timeCacheEntityPromiseFunc(\n    \"_cameraTmbUrl\",\n    9000,\n    fetchThumbnailUrl,\n    hass,\n    entityId\n  );\n  return cameraUrlWithWidthHeight(base_url, width, height);\n};\n\nexport const fetchThumbnailUrl = async (\n  hass: HomeAssistant,\n  entityId: string\n) => {\n  const path = await getSignedPath(hass, `/api/camera_proxy/${entityId}`);\n  return hass.hassUrl(path.path);\n};\n\nexport const fetchStreamUrl = async (\n  hass: HomeAssistant,\n  entityId: string,\n  format?: \"hls\"\n) => {\n  const data = {\n    type: \"camera/stream\",\n    entity_id: entityId,\n  };\n  if (format) {\n    // @ts-ignore\n    data.format = format;\n  }\n  const stream = await hass.callWS<Stream>(data);\n  stream.url = hass.hassUrl(stream.url);\n  return stream;\n};\n\nexport const webRtcOffer = (\n  hass: HomeAssistant,\n  entity_id: string,\n  offer: string,\n  callback: (event: WebRtcOfferEvent) => void\n) =>\n  hass.connection.subscribeMessage<WebRtcOfferEvent>(callback, {\n    type: \"camera/webrtc/offer\",\n    entity_id,\n    offer,\n  });\n\nexport const addWebRtcCandidate = (\n  hass: HomeAssistant,\n  entity_id: string,\n  session_id: string,\n  candidate: string\n) =>\n  hass.callWS({\n    type: \"camera/webrtc/candidate\",\n    entity_id,\n    session_id,\n    candidate,\n  });\n\nexport const fetchCameraPrefs = (hass: HomeAssistant, entityId: string) =>\n  hass.callWS<CameraPreferences>({\n    type: \"camera/get_prefs\",\n    entity_id: entityId,\n  });\n\ntype ValueOf<T extends any[]> = T[number];\nexport const updateCameraPrefs = (\n  hass: HomeAssistant,\n  entityId: string,\n  prefs: {\n    preload_stream?: boolean;\n    orientation?: ValueOf<typeof CAMERA_ORIENTATIONS>;\n  }\n) =>\n  hass.callWS<CameraPreferences>({\n    type: \"camera/update_prefs\",\n    entity_id: entityId,\n    ...prefs,\n  });\n\nconst CAMERA_MEDIA_SOURCE_PREFIX = \"media-source://camera/\";\n\nexport const isCameraMediaSource = (mediaContentId: string) =>\n  mediaContentId.startsWith(CAMERA_MEDIA_SOURCE_PREFIX);\n\nexport const getEntityIdFromCameraMediaSource = (mediaContentId: string) =>\n  mediaContentId.substring(CAMERA_MEDIA_SOURCE_PREFIX.length);\n\nexport interface CameraCapabilities {\n  frontend_stream_types: StreamType[];\n}\n\nexport const fetchCameraCapabilities = async (\n  hass: HomeAssistant,\n  entity_id: string\n) =>\n  hass.callWS<CameraCapabilities>({ type: \"camera/capabilities\", entity_id });\n\nexport interface WebRTCClientConfiguration {\n  configuration: RTCConfiguration;\n  dataChannel?: string;\n  getCandidatesUpfront: boolean;\n}\n\nexport const fetchWebRtcClientConfiguration = async (\n  hass: HomeAssistant,\n  entityId: string\n) =>\n  hass.callWS<WebRTCClientConfiguration>({\n    type: \"camera/webrtc/get_client_config\",\n    entity_id: entityId,\n  });\n","import { mdiAlert } from \"@mdi/js\";\nimport type { HassEntity } from \"home-assistant-js-websocket\";\nimport type { CSSResultGroup, PropertyValues } from \"lit\";\nimport { LitElement, css, html, nothing } from \"lit\";\nimport { property, state } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport {\n  stateColorBrightness,\n  stateColorCss,\n} from \"../../common/entity/state_color\";\nimport { iconColorCSS } from \"../../common/style/icon_color_css\";\nimport { cameraUrlWithWidthHeight } from \"../../data/camera\";\nimport { CLIMATE_HVAC_ACTION_TO_MODE } from \"../../data/climate\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../ha-state-icon\";\n\nexport class StateBadge extends LitElement {\n  public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: HassEntity;\n\n  @property() public overrideIcon?: string;\n\n  @property() public overrideImage?: string;\n\n  // Cannot be a boolean attribute because undefined is treated different than\n  // false.  When it is undefined, state is still colored for light entities.\n  @property({ attribute: false }) public stateColor?: boolean;\n\n  @property() public color?: string;\n\n  // @todo Consider reworking to eliminate need for attribute since it is manipulated internally\n  @property({ type: Boolean, reflect: true }) public icon = true;\n\n  @state() private _iconStyle: { [name: string]: string | undefined } = {};\n\n  connectedCallback(): void {\n    super.connectedCallback();\n    if (\n      this.hasUpdated &&\n      this.overrideImage === undefined &&\n      (this.stateObj?.attributes.entity_picture ||\n        this.stateObj?.attributes.entity_picture_local)\n    ) {\n      // Update image on connect, so we get new auth token\n      this.requestUpdate(\"stateObj\");\n    }\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    if (\n      this.overrideImage === undefined &&\n      (this.stateObj?.attributes.entity_picture ||\n        this.stateObj?.attributes.entity_picture_local)\n    ) {\n      // Clear image on disconnect so we don't fetch with old auth when we reconnect\n      this.style.backgroundImage = \"\";\n    }\n  }\n\n  private get _stateColor() {\n    const domain = this.stateObj\n      ? computeStateDomain(this.stateObj)\n      : undefined;\n    return this.stateColor ?? domain === \"light\";\n  }\n\n  protected render() {\n    const stateObj = this.stateObj;\n\n    // We either need a `stateObj` or one override\n    if (!stateObj && !this.overrideIcon && !this.overrideImage) {\n      return html`<div class=\"missing\">\n        <ha-svg-icon .path=${mdiAlert}></ha-svg-icon>\n      </div>`;\n    }\n\n    if (!this.icon) {\n      return nothing;\n    }\n\n    const domain = stateObj ? computeStateDomain(stateObj) : undefined;\n\n    return html`<ha-state-icon\n      .hass=${this.hass}\n      style=${styleMap(this._iconStyle)}\n      data-domain=${ifDefined(domain)}\n      data-state=${ifDefined(stateObj?.state)}\n      .icon=${this.overrideIcon}\n      .stateObj=${stateObj}\n    ></ha-state-icon>`;\n  }\n\n  public willUpdate(changedProps: PropertyValues<this>) {\n    super.willUpdate(changedProps);\n    if (\n      !changedProps.has(\"stateObj\") &&\n      !changedProps.has(\"overrideImage\") &&\n      !changedProps.has(\"overrideIcon\") &&\n      !changedProps.has(\"stateColor\") &&\n      !changedProps.has(\"color\")\n    ) {\n      return;\n    }\n    const stateObj = this.stateObj;\n\n    const iconStyle: { [name: string]: string } = {};\n    let backgroundImage = \"\";\n\n    this.icon = true;\n\n    if (stateObj && this.overrideImage === undefined) {\n      // hide icon if we have entity picture\n      if (\n        (stateObj.attributes.entity_picture_local ||\n          stateObj.attributes.entity_picture) &&\n        !this.overrideIcon\n      ) {\n        let imageUrl =\n          stateObj.attributes.entity_picture_local ||\n          stateObj.attributes.entity_picture;\n        if (this.hass) {\n          imageUrl = this.hass.hassUrl(imageUrl);\n        }\n        const domain = computeDomain(stateObj.entity_id);\n        if (domain === \"camera\") {\n          imageUrl = cameraUrlWithWidthHeight(imageUrl, 80, 80);\n        }\n        backgroundImage = `url(${imageUrl})`;\n        this.icon = false;\n        if (domain === \"update\") {\n          this.style.borderRadius = \"0\";\n        } else if (domain === \"media_player\") {\n          this.style.borderRadius = \"8%\";\n        }\n      } else if (this.color) {\n        // Externally provided overriding color wins over state color\n        iconStyle.color = this.color;\n      } else if (this._stateColor) {\n        const color = stateColorCss(stateObj);\n        if (color) {\n          iconStyle.color = color;\n        }\n        if (stateObj.attributes.rgb_color) {\n          iconStyle.color = `rgb(${stateObj.attributes.rgb_color.join(\",\")})`;\n        }\n        if (stateObj.attributes.brightness) {\n          const brightness = stateObj.attributes.brightness;\n          if (typeof brightness !== \"number\") {\n            const errorMessage = `Type error: state-badge expected number, but type of ${\n              stateObj.entity_id\n            }.attributes.brightness is ${typeof brightness} (${brightness})`;\n            // eslint-disable-next-line\n            console.warn(errorMessage);\n          }\n          iconStyle.filter = stateColorBrightness(stateObj);\n        }\n        if (stateObj.attributes.hvac_action) {\n          const hvacAction = stateObj.attributes.hvac_action;\n          if (hvacAction in CLIMATE_HVAC_ACTION_TO_MODE) {\n            iconStyle.color = stateColorCss(\n              stateObj,\n              CLIMATE_HVAC_ACTION_TO_MODE[hvacAction]\n            )!;\n          } else {\n            delete iconStyle.color;\n          }\n        }\n      }\n    } else if (this.overrideImage) {\n      let imageUrl = this.overrideImage;\n      if (this.hass) {\n        imageUrl = this.hass.hassUrl(imageUrl);\n      }\n      backgroundImage = `url(${imageUrl})`;\n      this.icon = false;\n    }\n\n    this._iconStyle = iconStyle;\n    this.style.backgroundImage = backgroundImage;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      iconColorCSS,\n      css`\n        :host {\n          position: relative;\n          display: inline-block;\n          width: 40px;\n          color: var(--paper-item-icon-color, #44739e);\n          border-radius: 50%;\n          height: 40px;\n          text-align: center;\n          background-size: cover;\n          line-height: 40px;\n          vertical-align: middle;\n          box-sizing: border-box;\n          --state-inactive-color: initial;\n        }\n        :host(:focus) {\n          outline: none;\n        }\n        :host(:not([icon]):focus) {\n          border: 2px solid var(--divider-color);\n        }\n        :host([icon]:focus) {\n          background: var(--divider-color);\n        }\n        ha-state-icon {\n          transition:\n            color 0.3s ease-in-out,\n            filter 0.3s ease-in-out;\n        }\n        .missing {\n          color: #fce588;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-badge\": StateBadge;\n  }\n}\n\ncustomElements.define(\"state-badge\", StateBadge);\n","import type { HassEntity } from \"home-assistant-js-websocket\";\nimport { html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { until } from \"lit/directives/until\";\nimport { DEFAULT_DOMAIN_ICON, FIXED_DOMAIN_ICONS } from \"../common/const\";\nimport { computeStateDomain } from \"../common/entity/compute_state_domain\";\nimport { entityIcon } from \"../data/icons\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-icon\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-state-icon\")\nexport class HaStateIcon extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: HassEntity;\n\n  @property({ attribute: false }) public stateValue?: string;\n\n  @property() public icon?: string;\n\n  protected render() {\n    const overrideIcon =\n      this.icon ||\n      (this.stateObj && this.hass?.entities[this.stateObj.entity_id]?.icon) ||\n      this.stateObj?.attributes.icon;\n    if (overrideIcon) {\n      return html`<ha-icon .icon=${overrideIcon}></ha-icon>`;\n    }\n    if (!this.stateObj) {\n      return nothing;\n    }\n    if (!this.hass) {\n      return this._renderFallback();\n    }\n    const icon = entityIcon(this.hass, this.stateObj, this.stateValue).then(\n      (icn) => {\n        if (icn) {\n          return html`<ha-icon .icon=${icn}></ha-icon>`;\n        }\n        return this._renderFallback();\n      }\n    );\n    return html`${until(icon)}`;\n  }\n\n  private _renderFallback() {\n    const domain = computeStateDomain(this.stateObj!);\n\n    return html`\n      <ha-svg-icon\n        .path=${FIXED_DOMAIN_ICONS[domain] || DEFAULT_DOMAIN_ICON}\n      ></ha-svg-icon>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-state-icon\": HaStateIcon;\n  }\n}\n"],"names":[],"sourceRoot":""}