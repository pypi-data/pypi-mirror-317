{"version":3,"file":"7JZqlSR5.js","mappings":";;AAoDA;AACA;AAoBA;AACA;;AAoFA;;AAIA;;;;AAKA;;AAEA;AAGA;AAWA;;;;AAKA;;AAEA;;AAGA;;AAMA;AAiBA;AACA;AAmBA;AACA;AChGA;AACA;AACA;;;;AAQA;AACA;;AAEA;;AAEA;;AAIA;AACA;;AAEA;;AAGA;;AAIA;;;;AAqBA;;;;AAMA;;AAMA;;AAEA;AACA;;;;;;;AAOA;;;;AASA;;;AAGA;;AAGA;;;AAOA;;AAIA;;;AAKA;AACA;;;AAGA;AACA;;AAmBA;;AAGA;;;;;;;;;;;;;;;;;;;;AA8FA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/JA;;;AAOA;;;AAIA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/dialogs/config-flow/show-dialog-config-flow.ts","webpack://knx-frontend/./homeassistant-frontend/src/panels/config/helpers/dialog-helper-detail.ts","webpack://knx-frontend/./node_modules/@lrnwebcomponents/simple-tooltip/simple-tooltip.js"],"sourcesContent":["import { html } from \"lit\";\nimport {\n  createConfigFlow,\n  deleteConfigFlow,\n  fetchConfigFlow,\n  handleConfigFlowStep,\n} from \"../../data/config_flow\";\nimport { domainToName } from \"../../data/integration\";\nimport type { DataEntryFlowDialogParams } from \"./show-dialog-data-entry-flow\";\nimport {\n  loadDataEntryFlowDialog,\n  showFlowDialog,\n} from \"./show-dialog-data-entry-flow\";\n\nexport const loadConfigFlowDialog = loadDataEntryFlowDialog;\n\nexport const showConfigFlowDialog = (\n  element: HTMLElement,\n  dialogParams: Omit<DataEntryFlowDialogParams, \"flowConfig\">\n): void =>\n  showFlowDialog(element, dialogParams, {\n    flowType: \"config_flow\",\n    showDevices: true,\n    createFlow: async (hass, handler) => {\n      const [step] = await Promise.all([\n        createConfigFlow(hass, handler, dialogParams.entryId),\n        hass.loadFragmentTranslation(\"config\"),\n        hass.loadBackendTranslation(\"config\", handler),\n        hass.loadBackendTranslation(\"selector\", handler),\n        // Used as fallback if no header defined for step\n        hass.loadBackendTranslation(\"title\", handler),\n      ]);\n      return step;\n    },\n    fetchFlow: async (hass, flowId) => {\n      const step = await fetchConfigFlow(hass, flowId);\n      await hass.loadFragmentTranslation(\"config\");\n      await hass.loadBackendTranslation(\"config\", step.handler);\n      await hass.loadBackendTranslation(\"selector\", step.handler);\n      return step;\n    },\n    handleFlowStep: handleConfigFlowStep,\n    deleteFlow: deleteConfigFlow,\n\n    renderAbortDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.translation_domain || step.handler}.config.abort.${step.reason}`,\n        step.description_placeholders\n      );\n\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : step.reason;\n    },\n\n    renderShowFormStepHeader(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.translation_domain || step.handler}.config.step.${step.step_id}.title`,\n          step.description_placeholders\n        ) || hass.localize(`component.${step.handler}.title`)\n      );\n    },\n\n    renderShowFormStepDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.translation_domain || step.handler}.config.step.${step.step_id}.description`,\n        step.description_placeholders\n      );\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : \"\";\n    },\n\n    renderShowFormStepFieldLabel(hass, step, field, options) {\n      if (field.type === \"expandable\") {\n        return hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.sections.${field.name}.name`\n        );\n      }\n\n      const prefix = options?.path?.[0] ? `sections.${options.path[0]}.` : \"\";\n\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.${prefix}data.${field.name}`\n        ) || field.name\n      );\n    },\n\n    renderShowFormStepFieldHelper(hass, step, field, options) {\n      if (field.type === \"expandable\") {\n        return hass.localize(\n          `component.${step.translation_domain || step.handler}.config.step.${step.step_id}.sections.${field.name}.description`\n        );\n      }\n\n      const prefix = options?.path?.[0] ? `sections.${options.path[0]}.` : \"\";\n\n      const description = hass.localize(\n        `component.${step.translation_domain || step.handler}.config.step.${step.step_id}.${prefix}data_description.${field.name}`,\n        step.description_placeholders\n      );\n\n      return description\n        ? html`<ha-markdown breaks .content=${description}></ha-markdown>`\n        : \"\";\n    },\n\n    renderShowFormStepFieldError(hass, step, error) {\n      return (\n        hass.localize(\n          `component.${step.translation_domain || step.translation_domain || step.handler}.config.error.${error}`,\n          step.description_placeholders\n        ) || error\n      );\n    },\n\n    renderShowFormStepFieldLocalizeValue(hass, step, key) {\n      return hass.localize(`component.${step.handler}.selector.${key}`);\n    },\n\n    renderShowFormStepSubmitButton(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.submit`\n        ) ||\n        hass.localize(\n          `ui.panel.config.integrations.config_flow.${\n            step.last_step === false ? \"next\" : \"submit\"\n          }`\n        )\n      );\n    },\n\n    renderExternalStepHeader(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.title`\n        ) ||\n        hass.localize(\n          \"ui.panel.config.integrations.config_flow.external_step.open_site\"\n        )\n      );\n    },\n\n    renderExternalStepDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.translation_domain || step.handler}.config.${step.step_id}.description`,\n        step.description_placeholders\n      );\n\n      return html`\n        <p>\n          ${hass.localize(\n            \"ui.panel.config.integrations.config_flow.external_step.description\"\n          )}\n        </p>\n        ${description\n          ? html`\n              <ha-markdown\n                allowsvg\n                breaks\n                .content=${description}\n              ></ha-markdown>\n            `\n          : \"\"}\n      `;\n    },\n\n    renderCreateEntryDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.translation_domain || step.handler}.config.create_entry.${\n          step.description || \"default\"\n        }`,\n        step.description_placeholders\n      );\n\n      return html`\n        ${description\n          ? html`\n              <ha-markdown\n                allowsvg\n                breaks\n                .content=${description}\n              ></ha-markdown>\n            `\n          : \"\"}\n        <p>\n          ${hass.localize(\n            \"ui.panel.config.integrations.config_flow.created_config\",\n            { name: step.title }\n          )}\n        </p>\n      `;\n    },\n\n    renderShowFormProgressHeader(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.title`\n        ) || hass.localize(`component.${step.handler}.title`)\n      );\n    },\n\n    renderShowFormProgressDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.translation_domain || step.handler}.config.progress.${step.progress_action}`,\n        step.description_placeholders\n      );\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : \"\";\n    },\n\n    renderMenuHeader(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.title`\n        ) || hass.localize(`component.${step.handler}.title`)\n      );\n    },\n\n    renderMenuDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.translation_domain || step.handler}.config.step.${step.step_id}.description`,\n        step.description_placeholders\n      );\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : \"\";\n    },\n\n    renderMenuOption(hass, step, option) {\n      return hass.localize(\n        `component.${step.translation_domain || step.handler}.config.step.${step.step_id}.menu_options.${option}`,\n        step.description_placeholders\n      );\n    },\n\n    renderLoadingDescription(hass, reason, handler, step) {\n      if (reason !== \"loading_flow\" && reason !== \"loading_step\") {\n        return \"\";\n      }\n      const domain = step?.handler || handler;\n      return hass.localize(\n        `ui.panel.config.integrations.config_flow.loading.${reason}`,\n        {\n          integration: domain\n            ? domainToName(hass.localize, domain)\n            : // when we are continuing a config flow, we only know the ID and not the domain\n              hass.localize(\n                \"ui.panel.config.integrations.config_flow.loading.fallback_title\"\n              ),\n        }\n      );\n    },\n  });\n","import \"@material/mwc-button/mwc-button\";\nimport type { RequestSelectedDetail } from \"@material/mwc-list/mwc-list-item-base\";\nimport \"@lrnwebcomponents/simple-tooltip/simple-tooltip\";\nimport type { CSSResultGroup, TemplateResult } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { isComponentLoaded } from \"../../../common/config/is_component_loaded\";\nimport { dynamicElement } from \"../../../common/dom/dynamic-element-directive\";\nimport { shouldHandleRequestSelectedEvent } from \"../../../common/mwc/handle-request-selected-event\";\nimport \"../../../components/ha-circular-progress\";\nimport { createCloseHeading } from \"../../../components/ha-dialog\";\nimport \"../../../components/ha-list-item\";\nimport { getConfigFlowHandlers } from \"../../../data/config_flow\";\nimport { createCounter } from \"../../../data/counter\";\nimport { createInputBoolean } from \"../../../data/input_boolean\";\nimport { createInputButton } from \"../../../data/input_button\";\nimport { createInputDateTime } from \"../../../data/input_datetime\";\nimport { createInputNumber } from \"../../../data/input_number\";\nimport { createInputSelect } from \"../../../data/input_select\";\nimport { createInputText } from \"../../../data/input_text\";\nimport {\n  domainToName,\n  fetchIntegrationManifest,\n} from \"../../../data/integration\";\nimport { createSchedule } from \"../../../data/schedule\";\nimport { createTimer } from \"../../../data/timer\";\nimport { showConfigFlowDialog } from \"../../../dialogs/config-flow/show-dialog-config-flow\";\nimport { haStyleDialog } from \"../../../resources/styles\";\nimport type { HomeAssistant } from \"../../../types\";\nimport { brandsUrl } from \"../../../util/brands-url\";\nimport type { Helper, HelperDomain } from \"./const\";\nimport { isHelperDomain } from \"./const\";\nimport type { ShowDialogHelperDetailParams } from \"./show-dialog-helper-detail\";\n\ntype HelperCreators = {\n  [domain in HelperDomain]: {\n    create: (\n      hass: HomeAssistant,\n      // Not properly typed because there is currently a mismatch for this._item between:\n      // 1. Type passed to form should be Helper\n      // 2. Type received by creator should be MutableParams version\n      // The two are not compatible.\n      params: any\n    ) => Promise<Helper>;\n    import: () => Promise<unknown>;\n  };\n};\n\nconst HELPERS: HelperCreators = {\n  input_boolean: {\n    create: createInputBoolean,\n    import: () => import(\"./forms/ha-input_boolean-form\"),\n  },\n  input_button: {\n    create: createInputButton,\n    import: () => import(\"./forms/ha-input_button-form\"),\n  },\n  input_text: {\n    create: createInputText,\n    import: () => import(\"./forms/ha-input_text-form\"),\n  },\n  input_number: {\n    create: createInputNumber,\n    import: () => import(\"./forms/ha-input_number-form\"),\n  },\n  input_datetime: {\n    create: createInputDateTime,\n    import: () => import(\"./forms/ha-input_datetime-form\"),\n  },\n  input_select: {\n    create: createInputSelect,\n    import: () => import(\"./forms/ha-input_select-form\"),\n  },\n  counter: {\n    create: createCounter,\n    import: () => import(\"./forms/ha-counter-form\"),\n  },\n  timer: {\n    create: createTimer,\n    import: () => import(\"./forms/ha-timer-form\"),\n  },\n  schedule: {\n    create: createSchedule,\n    import: () => import(\"./forms/ha-schedule-form\"),\n  },\n};\n\n@customElement(\"dialog-helper-detail\")\nexport class DialogHelperDetail extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _item?: Helper;\n\n  @state() private _opened = false;\n\n  @state() private _domain?: string;\n\n  @state() private _error?: string;\n\n  @state() private _submitting = false;\n\n  @query(\".form\") private _form?: HTMLDivElement;\n\n  @state() private _helperFlows?: string[];\n\n  @state() private _loading = false;\n\n  private _params?: ShowDialogHelperDetailParams;\n\n  public async showDialog(params: ShowDialogHelperDetailParams): Promise<void> {\n    this._params = params;\n    this._domain = params.domain;\n    this._item = undefined;\n    if (this._domain && this._domain in HELPERS) {\n      await HELPERS[this._domain].import();\n    }\n    this._opened = true;\n    await this.updateComplete;\n    this.hass.loadFragmentTranslation(\"config\");\n    const flows = await getConfigFlowHandlers(this.hass, [\"helper\"]);\n    await this.hass.loadBackendTranslation(\"title\", flows, true);\n    // Ensure the titles are loaded before we render the flows.\n    this._helperFlows = flows;\n  }\n\n  public closeDialog(): void {\n    this._opened = false;\n    this._error = undefined;\n    this._domain = undefined;\n    this._params = undefined;\n  }\n\n  protected render() {\n    if (!this._opened) {\n      return nothing;\n    }\n    let content: TemplateResult;\n\n    if (this._domain) {\n      content = html`\n        <div class=\"form\" @value-changed=${this._valueChanged}>\n          ${this._error ? html`<div class=\"error\">${this._error}</div>` : \"\"}\n          ${dynamicElement(`ha-${this._domain}-form`, {\n            hass: this.hass,\n            item: this._item,\n            new: true,\n          })}\n        </div>\n        <mwc-button\n          slot=\"primaryAction\"\n          @click=${this._createItem}\n          .disabled=${this._submitting}\n        >\n          ${this.hass!.localize(\"ui.panel.config.helpers.dialog.create\")}\n        </mwc-button>\n        ${this._params?.domain\n          ? nothing\n          : html`<mwc-button\n              slot=\"secondaryAction\"\n              @click=${this._goBack}\n              .disabled=${this._submitting}\n            >\n              ${this.hass!.localize(\"ui.common.back\")}\n            </mwc-button>`}\n      `;\n    } else if (this._loading || this._helperFlows === undefined) {\n      content = html`<ha-circular-progress\n        indeterminate\n      ></ha-circular-progress>`;\n    } else {\n      const items: [string, string][] = [];\n\n      for (const helper of Object.keys(HELPERS) as (keyof typeof HELPERS)[]) {\n        items.push([\n          helper,\n          this.hass.localize(`ui.panel.config.helpers.types.${helper}`) ||\n            helper,\n        ]);\n      }\n\n      for (const domain of this._helperFlows) {\n        items.push([domain, domainToName(this.hass.localize, domain)]);\n      }\n\n      items.sort((a, b) => a[1].localeCompare(b[1]));\n\n      content = html`\n        <mwc-list\n          innerRole=\"listbox\"\n          itemRoles=\"option\"\n          innerAriaLabel=${this.hass.localize(\n            \"ui.panel.config.helpers.dialog.create_helper\"\n          )}\n          rootTabbable\n          dialogInitialFocus\n        >\n          ${items.map(([domain, label]) => {\n            // Only OG helpers need to be loaded prior adding one\n            const isLoaded =\n              !(domain in HELPERS) || isComponentLoaded(this.hass, domain);\n            return html`\n              <ha-list-item\n                .disabled=${!isLoaded}\n                hasmeta\n                .domain=${domain}\n                @request-selected=${this._domainPicked}\n                graphic=\"icon\"\n              >\n                <img\n                  slot=\"graphic\"\n                  loading=\"lazy\"\n                  alt=\"\"\n                  src=${brandsUrl({\n                    domain,\n                    type: \"icon\",\n                    useFallback: true,\n                    darkOptimized: this.hass.themes?.darkMode,\n                  })}\n                  crossorigin=\"anonymous\"\n                  referrerpolicy=\"no-referrer\"\n                />\n                <span class=\"item-text\"> ${label} </span>\n                <ha-icon-next slot=\"meta\"></ha-icon-next>\n              </ha-list-item>\n              ${!isLoaded\n                ? html`\n                    <simple-tooltip animation-delay=\"0\"\n                      >${this.hass.localize(\n                        \"ui.dialogs.helper_settings.platform_not_loaded\",\n                        { platform: domain }\n                      )}</simple-tooltip\n                    >\n                  `\n                : \"\"}\n            `;\n          })}\n        </mwc-list>\n      `;\n    }\n\n    return html`\n      <ha-dialog\n        open\n        @closed=${this.closeDialog}\n        class=${classMap({ \"button-left\": !this._domain })}\n        scrimClickAction\n        escapeKeyAction\n        .hideActions=${!this._domain}\n        .heading=${createCloseHeading(\n          this.hass,\n          this._domain\n            ? this.hass.localize(\n                \"ui.panel.config.helpers.dialog.create_platform\",\n                {\n                  platform:\n                    (isHelperDomain(this._domain) &&\n                      this.hass.localize(\n                        `ui.panel.config.helpers.types.${\n                          this._domain as HelperDomain\n                        }`\n                      )) ||\n                    this._domain,\n                }\n              )\n            : this.hass.localize(\"ui.panel.config.helpers.dialog.create_helper\")\n        )}\n      >\n        ${content}\n      </ha-dialog>\n    `;\n  }\n\n  private _valueChanged(ev: CustomEvent): void {\n    this._item = ev.detail.value;\n  }\n\n  private async _createItem(): Promise<void> {\n    if (!this._domain || !this._item) {\n      return;\n    }\n    this._submitting = true;\n    this._error = \"\";\n    try {\n      const createdEntity = await HELPERS[this._domain].create(\n        this.hass,\n        this._item\n      );\n      if (this._params?.dialogClosedCallback && createdEntity.id) {\n        this._params.dialogClosedCallback({\n          flowFinished: true,\n          entityId: `${this._domain}.${createdEntity.id}`,\n        });\n      }\n      this.closeDialog();\n    } catch (err: any) {\n      this._error = err.message || \"Unknown error\";\n    } finally {\n      this._submitting = false;\n    }\n  }\n\n  private async _domainPicked(\n    ev: CustomEvent<RequestSelectedDetail>\n  ): Promise<void> {\n    if (!shouldHandleRequestSelectedEvent(ev)) {\n      return;\n    }\n    const domain = (ev.currentTarget! as any).domain;\n\n    if (domain in HELPERS) {\n      this._loading = true;\n      try {\n        await HELPERS[domain].import();\n        this._domain = domain;\n      } finally {\n        this._loading = false;\n      }\n      this._focusForm();\n    } else {\n      showConfigFlowDialog(this, {\n        startFlowHandler: domain,\n        manifest: await fetchIntegrationManifest(this.hass, domain),\n        dialogClosedCallback: this._params!.dialogClosedCallback,\n      });\n      this.closeDialog();\n    }\n  }\n\n  private async _focusForm(): Promise<void> {\n    await this.updateComplete;\n    (this._form?.lastElementChild as HTMLElement).focus();\n  }\n\n  private _goBack() {\n    this._domain = undefined;\n    this._item = undefined;\n    this._error = undefined;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyleDialog,\n      css`\n        ha-dialog.button-left {\n          --justify-action-buttons: flex-start;\n        }\n        ha-dialog {\n          --dialog-content-padding: 0;\n          --dialog-scroll-divider-color: transparent;\n          --mdc-dialog-max-height: 60vh;\n        }\n        @media all and (min-width: 550px) {\n          ha-dialog {\n            --mdc-dialog-min-width: 500px;\n          }\n        }\n        ha-icon-next {\n          width: 24px;\n        }\n        .form {\n          padding: 24px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"dialog-helper-detail\": DialogHelperDetail;\n  }\n}\n","/**\n * Copyright 2020 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement, html, css } from \"lit\";\n\n/**\n  * `simple-tooltip`\n  * `a simple tooltip forked from paper-tooltip with the same api minus apply removal`\n     ### Styling\n     The following custom properties and mixins are available for styling:\n \n     Custom property | Description | Default\n     ----------------|-------------|----------\n     `--simple-tooltip-background` | The background color of the tooltip | `#616161`\n     `--simple-tooltip-opacity` | The opacity of the tooltip | `0.9`\n     `--simple-tooltip-text-color` | The text color of the tooltip | `white`\n     `--simple-tooltip-delay-in` | Delay before tooltip starts to fade in | `500`\n     `--simple-tooltip-delay-out` | Delay before tooltip starts to fade out | `0`\n     `--simple-tooltip-duration-in` | Timing for animation when showing tooltip | `500`\n     `--simple-tooltip-duration-out` | Timing for animation when hiding tooltip | `0`\n  * @demo demo/index.html\n  * @element simple-tooltip\n  */\nclass SimpleTooltip extends LitElement {\n  //styles function\n  static get styles() {\n    return [\n      css`\n        :host {\n          display: block;\n          position: absolute;\n          outline: none;\n          z-index: 1002;\n          -moz-user-select: none;\n          -ms-user-select: none;\n          -webkit-user-select: none;\n          user-select: none;\n          cursor: default;\n          pointer-events: none;\n        }\n\n        #tooltip {\n          display: block;\n          outline: none;\n          font-size: var(--simple-tooltip-font-size, 10px);\n          line-height: 1;\n          background-color: var(--simple-tooltip-background, #616161);\n          color: var(--simple-tooltip-text-color, white);\n          padding: 8px;\n          border-radius: var(--simple-tooltip-border-radius, 2px);\n          width: var(--simple-tooltip-width);\n        }\n\n        @keyframes keyFrameScaleUp {\n          0% {\n            transform: scale(0);\n          }\n\n          100% {\n            transform: scale(1);\n          }\n        }\n\n        @keyframes keyFrameScaleDown {\n          0% {\n            transform: scale(1);\n          }\n\n          100% {\n            transform: scale(0);\n          }\n        }\n\n        @keyframes keyFrameFadeInOpacity {\n          0% {\n            opacity: 0;\n          }\n\n          100% {\n            opacity: var(--simple-tooltip-opacity, 0.9);\n          }\n        }\n\n        @keyframes keyFrameFadeOutOpacity {\n          0% {\n            opacity: var(--simple-tooltip-opacity, 0.9);\n          }\n\n          100% {\n            opacity: 0;\n          }\n        }\n\n        @keyframes keyFrameSlideDownIn {\n          0% {\n            transform: translateY(-2000px);\n            opacity: 0;\n          }\n\n          10% {\n            opacity: 0.2;\n          }\n\n          100% {\n            transform: translateY(0);\n            opacity: var(--simple-tooltip-opacity, 0.9);\n          }\n        }\n\n        @keyframes keyFrameSlideDownOut {\n          0% {\n            transform: translateY(0);\n            opacity: var(--simple-tooltip-opacity, 0.9);\n          }\n\n          10% {\n            opacity: 0.2;\n          }\n\n          100% {\n            transform: translateY(-2000px);\n            opacity: 0;\n          }\n        }\n\n        .fade-in-animation {\n          opacity: 0;\n          animation-delay: var(--simple-tooltip-delay-in, 500ms);\n          animation-name: keyFrameFadeInOpacity;\n          animation-iteration-count: 1;\n          animation-timing-function: ease-in;\n          animation-duration: var(--simple-tooltip-duration-in, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .fade-out-animation {\n          opacity: var(--simple-tooltip-opacity, 0.9);\n          animation-delay: var(--simple-tooltip-delay-out, 0ms);\n          animation-name: keyFrameFadeOutOpacity;\n          animation-iteration-count: 1;\n          animation-timing-function: ease-in;\n          animation-duration: var(--simple-tooltip-duration-out, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .scale-up-animation {\n          transform: scale(0);\n          opacity: var(--simple-tooltip-opacity, 0.9);\n          animation-delay: var(--simple-tooltip-delay-in, 500ms);\n          animation-name: keyFrameScaleUp;\n          animation-iteration-count: 1;\n          animation-timing-function: ease-in;\n          animation-duration: var(--simple-tooltip-duration-in, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .scale-down-animation {\n          transform: scale(1);\n          opacity: var(--simple-tooltip-opacity, 0.9);\n          animation-delay: var(--simple-tooltip-delay-out, 500ms);\n          animation-name: keyFrameScaleDown;\n          animation-iteration-count: 1;\n          animation-timing-function: ease-in;\n          animation-duration: var(--simple-tooltip-duration-out, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .slide-down-animation {\n          transform: translateY(-2000px);\n          opacity: 0;\n          animation-delay: var(--simple-tooltip-delay-out, 500ms);\n          animation-name: keyFrameSlideDownIn;\n          animation-iteration-count: 1;\n          animation-timing-function: cubic-bezier(0, 0, 0.2, 1);\n          animation-duration: var(--simple-tooltip-duration-out, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .slide-down-animation-out {\n          transform: translateY(0);\n          opacity: var(--simple-tooltip-opacity, 0.9);\n          animation-delay: var(--simple-tooltip-delay-out, 500ms);\n          animation-name: keyFrameSlideDownOut;\n          animation-iteration-count: 1;\n          animation-timing-function: cubic-bezier(0.4, 0, 1, 1);\n          animation-duration: var(--simple-tooltip-duration-out, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .cancel-animation {\n          animation-delay: -30s !important;\n        }\n\n        .hidden {\n          position: absolute;\n          left: -10000px;\n          inset-inline-start: -10000px;\n          inset-inline-end: initial;\n          top: auto;\n          width: 1px;\n          height: 1px;\n          overflow: hidden;\n        }\n      `,\n    ];\n  }\n\n  // render function\n  render() {\n    return html` <div\n      id=\"tooltip\"\n      class=\"hidden\"\n      @animationend=\"${this._onAnimationEnd}\"\n    >\n      <slot></slot>\n    </div>`;\n  }\n\n  // properties available to the custom element for data binding\n  static get properties() {\n    return {\n      ...super.properties,\n\n      /**\n       * The id of the element that the tooltip is anchored to. This element\n       * must be a sibling of the tooltip. If this property is not set,\n       * then the tooltip will be centered to the parent node containing it.\n       */\n      for: { type: String },\n      /**\n       * Set this to true if you want to manually control when the tooltip\n       * is shown or hidden.\n       */\n      manualMode: { type: Boolean, attribute: \"manual-mode\" },\n      /**\n       * Positions the tooltip to the top, right, bottom, left of its content.\n       */\n      position: { type: String },\n      /**\n       * If true, no parts of the tooltip will ever be shown offscreen.\n       */\n      fitToVisibleBounds: {\n        type: Boolean,\n        attribute: \"fit-to-visible-bounds\",\n      },\n      /**\n       * The spacing between the top of the tooltip and the element it is\n       * anchored to.\n       */\n      offset: { type: Number },\n      /**\n       * This property is deprecated, but left over so that it doesn't\n       * break exiting code. Please use `offset` instead. If both `offset` and\n       * `marginTop` are provided, `marginTop` will be ignored.\n       * @deprecated since version 1.0.3\n       */\n      marginTop: { type: Number, attribute: \"margin-top\" },\n      /**\n       * The delay that will be applied before the `entry` animation is\n       * played when showing the tooltip.\n       */\n      animationDelay: { type: Number, attribute: \"animation-delay\" },\n      /**\n       * The animation that will be played on entry.  This replaces the\n       * deprecated animationConfig.  Entries here will override the\n       * animationConfig settings.  You can enter your own animation\n       * by setting it to the css class name.\n       */\n      animationEntry: { type: String, attribute: \"animation-entry\" },\n      /**\n       * The animation that will be played on exit.  This replaces the\n       * deprecated animationConfig.  Entries here will override the\n       * animationConfig settings.  You can enter your own animation\n       * by setting it to the css class name.\n       */\n      animationExit: { type: String, attribute: \"animation-exit\" },\n      _showing: { type: Boolean },\n    };\n  }\n\n  /**\n   * Convention we use\n   */\n  static get tag() {\n    return \"simple-tooltip\";\n  }\n\n  /**\n   * HTMLElement\n   */\n  constructor() {\n    super();\n    this.manualMode = false;\n    this.position = \"bottom\";\n    this.fitToVisibleBounds = false;\n    this.offset = 14;\n    this.marginTop = 14;\n    this.animationEntry = \"\";\n    this.animationExit = \"\";\n    this.animationConfig = {\n      entry: [{ name: \"fade-in-animation\", node: this, timing: { delay: 0 } }],\n      exit: [{ name: \"fade-out-animation\", node: this }],\n    };\n    setTimeout(() => {\n      this.addEventListener(\n        \"webkitAnimationEnd\",\n        this._onAnimationEnd.bind(this),\n      );\n      this.addEventListener(\"mouseenter\", this.hide.bind(this));\n    }, 0);\n  }\n  /**\n   * Returns the target element that this tooltip is anchored to. It is\n   * either the element given by the `for` attribute, or the immediate parent\n   * of the tooltip.\n   *\n   * @type {Node}\n   */\n  get target() {\n    var parentNode = this.parentNode;\n    // If the parentNode is a document fragment, then we need to use the host.\n    var ownerRoot = this.getRootNode();\n    var target;\n    if (this.for) {\n      target = ownerRoot.querySelector(\"#\" + this.for);\n    } else {\n      target =\n        parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE\n          ? ownerRoot.host\n          : parentNode;\n    }\n    return target;\n  }\n  /**\n   * @return {void}\n   * @override\n   */\n  disconnectedCallback() {\n    if (!this.manualMode) {\n      this._removeListeners();\n    }\n    super.disconnectedCallback();\n  }\n\n  /**\n   * @deprecated Use show and hide instead.\n   * @param {string} type Either `entry` or `exit`\n   */\n  playAnimation(type) {\n    if (type === \"entry\") {\n      this.show();\n    } else if (type === \"exit\") {\n      this.hide();\n    }\n  }\n\n  /**\n   * Cancels the animation and either fully shows or fully hides tooltip\n   */\n  cancelAnimation() {\n    // Short-cut and cancel all animations and hide\n    this.shadowRoot.querySelector(\"#tooltip\").classList.add(\"cancel-animation\");\n  }\n\n  /**\n   * Shows the tooltip programatically\n   * @return {void}\n   */\n  show() {\n    // If the tooltip is already showing, there's nothing to do.\n    if (this._showing) return;\n\n    if (this.textContent.trim() === \"\") {\n      // Check if effective children are also empty\n      var allChildrenEmpty = true;\n      var effectiveChildren = this.children;\n      for (var i = 0; i < effectiveChildren.length; i++) {\n        if (effectiveChildren[i].textContent.trim() !== \"\") {\n          allChildrenEmpty = false;\n          break;\n        }\n      }\n      if (allChildrenEmpty) {\n        return;\n      }\n    }\n\n    this._showing = true;\n    this.shadowRoot.querySelector(\"#tooltip\").classList.remove(\"hidden\");\n    this.shadowRoot\n      .querySelector(\"#tooltip\")\n      .classList.remove(\"cancel-animation\");\n    this.shadowRoot\n      .querySelector(\"#tooltip\")\n      .classList.remove(this._getAnimationType(\"exit\"));\n    this.updatePosition();\n    this._animationPlaying = true;\n    this.shadowRoot\n      .querySelector(\"#tooltip\")\n      .classList.add(this._getAnimationType(\"entry\"));\n  }\n\n  /**\n   * Hides the tooltip programatically\n   * @return {void}\n   */\n  hide() {\n    // If the tooltip is already hidden, there's nothing to do.\n    if (!this._showing) {\n      return;\n    }\n\n    // If the entry animation is still playing, don't try to play the exit\n    // animation since this will reset the opacity to 1. Just end the animation.\n    if (this._animationPlaying) {\n      this._showing = false;\n      this._cancelAnimation();\n      return;\n    } else {\n      // Play Exit Animation\n      this._onAnimationFinish();\n    }\n    this._showing = false;\n    this._animationPlaying = true;\n    // force hide if we are open too long\n    // helps older platforms and the monster known as Safari\n    clearTimeout(this.__debounceCancel);\n    this.__debounceCancel = setTimeout(() => {\n      this._cancelAnimation();\n    }, 5000);\n  }\n\n  /**\n   * @return {void}\n   */\n  updatePosition() {\n    if (!this._target || !this.offsetParent) return;\n    var offset = this.offset;\n    // If a marginTop has been provided by the user (pre 1.0.3), use it.\n    if (this.marginTop != 14 && this.offset == 14) offset = this.marginTop;\n    var parentRect = this.offsetParent.getBoundingClientRect();\n    var targetRect = this._target.getBoundingClientRect();\n    var thisRect = this.getBoundingClientRect();\n    var horizontalCenterOffset = (targetRect.width - thisRect.width) / 2;\n    var verticalCenterOffset = (targetRect.height - thisRect.height) / 2;\n    var targetLeft = targetRect.left - parentRect.left;\n    var targetTop = targetRect.top - parentRect.top;\n    var tooltipLeft, tooltipTop;\n    switch (this.position) {\n      case \"top\":\n        tooltipLeft = targetLeft + horizontalCenterOffset;\n        tooltipTop = targetTop - thisRect.height - offset;\n        break;\n      case \"bottom\":\n        tooltipLeft = targetLeft + horizontalCenterOffset;\n        tooltipTop = targetTop + targetRect.height + offset;\n        break;\n      case \"left\":\n        tooltipLeft = targetLeft - thisRect.width - offset;\n        tooltipTop = targetTop + verticalCenterOffset;\n        break;\n      case \"right\":\n        tooltipLeft = targetLeft + targetRect.width + offset;\n        tooltipTop = targetTop + verticalCenterOffset;\n        break;\n    }\n    // TODO(noms): This should use IronFitBehavior if possible.\n    if (this.fitToVisibleBounds) {\n      // Clip the left/right side\n      if (parentRect.left + tooltipLeft + thisRect.width > window.innerWidth) {\n        this.style.right = \"0px\";\n        this.style.left = \"auto\";\n      } else {\n        this.style.left = Math.max(0, tooltipLeft) + \"px\";\n        this.style.right = \"auto\";\n      }\n      // Clip the top/bottom side.\n      if (parentRect.top + tooltipTop + thisRect.height > window.innerHeight) {\n        this.style.bottom = parentRect.height - targetTop + offset + \"px\";\n        this.style.top = \"auto\";\n      } else {\n        this.style.top = Math.max(-parentRect.top, tooltipTop) + \"px\";\n        this.style.bottom = \"auto\";\n      }\n    } else {\n      this.style.left = tooltipLeft + \"px\";\n      this.style.top = tooltipTop + \"px\";\n    }\n  }\n\n  _addListeners() {\n    if (this._target) {\n      this._target.addEventListener(\"mouseenter\", this.show.bind(this));\n      this._target.addEventListener(\"focus\", this.show.bind(this));\n      this._target.addEventListener(\"mouseleave\", this.hide.bind(this));\n      this._target.addEventListener(\"blur\", this.hide.bind(this));\n      this._target.addEventListener(\"tap\", this.hide.bind(this));\n    }\n  }\n\n  _findTarget() {\n    if (!this.manualMode) this._removeListeners();\n    this._target = this.target;\n    if (!this.manualMode) this._addListeners();\n  }\n\n  _manualModeChanged() {\n    if (this.manualMode) this._removeListeners();\n    else this._addListeners();\n  }\n\n  _cancelAnimation() {\n    // Short-cut and cancel all animations and hide\n    this.shadowRoot\n      .querySelector(\"#tooltip\")\n      .classList.remove(this._getAnimationType(\"entry\"));\n    this.shadowRoot\n      .querySelector(\"#tooltip\")\n      .classList.remove(this._getAnimationType(\"exit\"));\n    this.shadowRoot\n      .querySelector(\"#tooltip\")\n      .classList.remove(\"cancel-animation\");\n    this.shadowRoot.querySelector(\"#tooltip\").classList.add(\"hidden\");\n  }\n\n  _onAnimationFinish() {\n    if (this._showing) {\n      this.shadowRoot\n        .querySelector(\"#tooltip\")\n        .classList.remove(this._getAnimationType(\"entry\"));\n      this.shadowRoot\n        .querySelector(\"#tooltip\")\n        .classList.remove(\"cancel-animation\");\n      this.shadowRoot\n        .querySelector(\"#tooltip\")\n        .classList.add(this._getAnimationType(\"exit\"));\n    }\n  }\n\n  _onAnimationEnd() {\n    // If no longer showing add class hidden to completely hide tooltip\n    this._animationPlaying = false;\n    if (!this._showing) {\n      this.shadowRoot\n        .querySelector(\"#tooltip\")\n        .classList.remove(this._getAnimationType(\"exit\"));\n      this.shadowRoot.querySelector(\"#tooltip\").classList.add(\"hidden\");\n    }\n  }\n\n  _getAnimationType(type) {\n    // These properties have priority over animationConfig values\n    if (type === \"entry\" && this.animationEntry !== \"\") {\n      return this.animationEntry;\n    }\n    if (type === \"exit\" && this.animationExit !== \"\") {\n      return this.animationExit;\n    }\n    // If no results then return the legacy value from animationConfig\n    if (\n      this.animationConfig[type] &&\n      typeof this.animationConfig[type][0].name === \"string\"\n    ) {\n      // Checking Timing and Update if necessary - Legacy for animationConfig\n      if (\n        this.animationConfig[type][0].timing &&\n        this.animationConfig[type][0].timing.delay &&\n        this.animationConfig[type][0].timing.delay !== 0\n      ) {\n        var timingDelay = this.animationConfig[type][0].timing.delay;\n        // Has Timing Change - Update CSS\n        if (type === \"entry\") {\n          document.documentElement.style.setProperty(\n            \"--simple-tooltip-delay-in\",\n            timingDelay + \"ms\",\n          );\n        } else if (type === \"exit\") {\n          document.documentElement.style.setProperty(\n            \"--simple-tooltip-delay-out\",\n            timingDelay + \"ms\",\n          );\n        }\n      }\n      return this.animationConfig[type][0].name;\n    }\n  }\n\n  _removeListeners() {\n    if (this._target) {\n      this._target.removeEventListener(\"mouseover\", this.show.bind(this));\n      this._target.removeEventListener(\"focusin\", this.show.bind(this));\n      this._target.removeEventListener(\"mouseout\", this.hide.bind(this));\n      this._target.removeEventListener(\"focusout\", this.hide.bind(this));\n      this._target.removeEventListener(\"click\", this.hide.bind(this));\n    }\n  }\n  /**\n   * LitElement ready\n   */\n  firstUpdated(changedProperties) {\n    this.setAttribute(\"role\", \"tooltip\");\n    this.setAttribute(\"tabindex\", -1);\n    this._findTarget();\n  }\n  /**\n   * LitElement life cycle - property changed\n   */\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      if (propName == \"for\") {\n        this._findTarget(this[propName], oldValue);\n      }\n      if (propName == \"manualMode\") {\n        this._manualModeChanged(this[propName], oldValue);\n      }\n      if (propName == \"animationDelay\") {\n        this._delayChange(this[propName], oldValue);\n      }\n    });\n  }\n  _delayChange(newValue) {\n    // Only Update delay if different value set\n    if (newValue !== 500) {\n      document.documentElement.style.setProperty(\n        \"--simple-tooltip-delay-in\",\n        newValue + \"ms\",\n      );\n    }\n  }\n}\ncustomElements.define(SimpleTooltip.tag, SimpleTooltip);\nexport { SimpleTooltip };\n"],"names":[],"sourceRoot":""}