{"version":3,"file":"wJIwTL_6.js","mappings":";AAoDA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;;;;;;;AA+CA;;;ACkCA;AACA;;;;;;;AAOA;AA5JA;;;AAgKA;;AAEA;AACA;;;;;AAKA;;;AAxKA;;;AA8KA;AAGA;AAGA;AACA;AACA;;AAEA;;;AAxLA;;AA8LA;;AAIA;;AAGA;AACA;;AAIA;;;;AAKA;;;;;;AAMA;AArNA;;;;AA0NA;;AAIA;;;;;AAOA;AAIA;;;;;;;AAQA;AACA;AACA;;;;;AAKA;;;AAxPA;AA6PA;AACA;;;AAKA;AAEA;;;;;AAMA;;;;AA3QA;AAiRA;AACA;;;AAKA;;AAvRA;;;;;;;;;;AAsSA;;AA2JA;;;AAMA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkaA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-button-menu.ts","webpack://knx-frontend/./homeassistant-frontend/src/dialogs/voice-command-dialog/ha-voice-command-dialog.ts"],"sourcesContent":["import type { Button } from \"@material/mwc-button\";\nimport \"@material/mwc-menu\";\nimport type { Corner, Menu, MenuCorner } from \"@material/mwc-menu\";\nimport type { CSSResultGroup, TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { mainWindow } from \"../common/dom/get_main_window\";\nimport { FOCUS_TARGET } from \"../dialogs/make-dialog-manager\";\nimport type { HaIconButton } from \"./ha-icon-button\";\n\n@customElement(\"ha-button-menu\")\nexport class HaButtonMenu extends LitElement {\n  protected readonly [FOCUS_TARGET];\n\n  @property() public corner: Corner = \"BOTTOM_START\";\n\n  @property() public menuCorner: MenuCorner = \"START\";\n\n  @property({ type: Number }) public x: number | null = null;\n\n  @property({ type: Number }) public y: number | null = null;\n\n  @property({ type: Boolean }) public multi = false;\n\n  @property({ type: Boolean }) public activatable = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public fixed = false;\n\n  @property({ type: Boolean, attribute: \"no-anchor\" }) public noAnchor = false;\n\n  @query(\"mwc-menu\", true) private _menu?: Menu;\n\n  public get items() {\n    return this._menu?.items;\n  }\n\n  public get selected() {\n    return this._menu?.selected;\n  }\n\n  public override focus() {\n    if (this._menu?.open) {\n      this._menu.focusItemAtIndex(0);\n    } else {\n      this._triggerButton?.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div @click=${this._handleClick}>\n        <slot name=\"trigger\" @slotchange=${this._setTriggerAria}></slot>\n      </div>\n      <mwc-menu\n        .corner=${this.corner}\n        .menuCorner=${this.menuCorner}\n        .fixed=${this.fixed}\n        .multi=${this.multi}\n        .activatable=${this.activatable}\n        .y=${this.y}\n        .x=${this.x}\n      >\n        <slot></slot>\n      </mwc-menu>\n    `;\n  }\n\n  protected firstUpdated(changedProps): void {\n    super.firstUpdated(changedProps);\n\n    if (mainWindow.document.dir === \"rtl\") {\n      this.updateComplete.then(() => {\n        this.querySelectorAll(\"mwc-list-item\").forEach((item) => {\n          const style = document.createElement(\"style\");\n          style.innerHTML =\n            \"span.material-icons:first-of-type { margin-left: var(--mdc-list-item-graphic-margin, 32px) !important; margin-right: 0px !important;}\";\n          item!.shadowRoot!.appendChild(style);\n        });\n      });\n    }\n  }\n\n  private _handleClick(): void {\n    if (this.disabled) {\n      return;\n    }\n    this._menu!.anchor = this.noAnchor ? null : this;\n    this._menu!.show();\n  }\n\n  private get _triggerButton() {\n    return this.querySelector(\n      'ha-icon-button[slot=\"trigger\"], mwc-button[slot=\"trigger\"]'\n    ) as HaIconButton | Button | null;\n  }\n\n  private _setTriggerAria() {\n    if (this._triggerButton) {\n      this._triggerButton.ariaHasPopup = \"menu\";\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n        position: relative;\n      }\n      ::slotted([disabled]) {\n        color: var(--disabled-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button-menu\": HaButtonMenu;\n  }\n}\n","import \"@material/mwc-button/mwc-button\";\nimport {\n  mdiAlertCircle,\n  mdiChevronDown,\n  mdiClose,\n  mdiHelpCircleOutline,\n  mdiMicrophone,\n  mdiSend,\n  mdiStar,\n} from \"@mdi/js\";\nimport type { CSSResultGroup, PropertyValues, TemplateResult } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { storage } from \"../../common/decorators/storage\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { stopPropagation } from \"../../common/dom/stop_propagation\";\nimport \"../../components/ha-button\";\nimport \"../../components/ha-button-menu\";\nimport \"../../components/ha-dialog\";\nimport \"../../components/ha-dialog-header\";\nimport \"../../components/ha-icon-button\";\nimport \"../../components/ha-list-item\";\nimport \"../../components/ha-textfield\";\nimport \"../../components/ha-alert\";\nimport type { HaTextField } from \"../../components/ha-textfield\";\nimport type { AssistPipeline } from \"../../data/assist_pipeline\";\nimport {\n  getAssistPipeline,\n  listAssistPipelines,\n  runAssistPipeline,\n} from \"../../data/assist_pipeline\";\nimport { haStyleDialog } from \"../../resources/styles\";\nimport type { HomeAssistant } from \"../../types\";\nimport { AudioRecorder } from \"../../util/audio-recorder\";\nimport { documentationUrl } from \"../../util/documentation-url\";\nimport { showAlertDialog } from \"../generic/show-dialog-box\";\nimport type { VoiceCommandDialogParams } from \"./show-ha-voice-command-dialog\";\nimport { supportsFeature } from \"../../common/entity/supports-feature\";\nimport { ConversationEntityFeature } from \"../../data/conversation\";\n\ninterface Message {\n  who: string;\n  text?: string | TemplateResult;\n  error?: boolean;\n}\n\n@customElement(\"ha-voice-command-dialog\")\nexport class HaVoiceCommandDialog extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _conversation?: Message[];\n\n  @state() private _opened = false;\n\n  @storage({\n    key: \"AssistPipelineId\",\n    state: true,\n    subscribe: false,\n  })\n  private _pipelineId?: string;\n\n  @state() private _pipeline?: AssistPipeline;\n\n  @state() private _showSendButton = false;\n\n  @state() private _pipelines?: AssistPipeline[];\n\n  @state() private _preferredPipeline?: string;\n\n  @query(\"#scroll-container\") private _scrollContainer!: HTMLDivElement;\n\n  @query(\"#message-input\") private _messageInput!: HaTextField;\n\n  private _conversationId: string | null = null;\n\n  private _audioRecorder?: AudioRecorder;\n\n  private _audioBuffer?: Int16Array[];\n\n  private _audio?: HTMLAudioElement;\n\n  private _stt_binary_handler_id?: number | null;\n\n  private _pipelinePromise?: Promise<AssistPipeline>;\n\n  public async showDialog(\n    params: Required<VoiceCommandDialogParams>\n  ): Promise<void> {\n    if (params.pipeline_id === \"last_used\") {\n      // Do not set pipeline id (retrieve from storage)\n    } else if (params.pipeline_id === \"preferred\") {\n      await this._loadPipelines();\n      this._pipelineId = this._preferredPipeline;\n    } else {\n      this._pipelineId = params.pipeline_id;\n    }\n\n    this._conversation = [\n      {\n        who: \"hass\",\n        text: this.hass.localize(\"ui.dialogs.voice_command.how_can_i_help\"),\n      },\n    ];\n    this._opened = true;\n    await this.updateComplete;\n    this._scrollMessagesBottom();\n\n    await this._pipelinePromise;\n    if (\n      params?.start_listening &&\n      this._pipeline?.stt_engine &&\n      AudioRecorder.isSupported\n    ) {\n      this._toggleListening();\n    }\n  }\n\n  public async closeDialog(): Promise<void> {\n    this._opened = false;\n    this._pipeline = undefined;\n    this._pipelines = undefined;\n    this._conversation = undefined;\n    this._conversationId = null;\n    this._audioRecorder?.close();\n    this._audioRecorder = undefined;\n    this._audio?.pause();\n    fireEvent(this, \"dialog-closed\", { dialog: this.localName });\n  }\n\n  protected render() {\n    if (!this._opened) {\n      return nothing;\n    }\n\n    const controlHA = !this._pipeline\n      ? false\n      : this.hass.states[this._pipeline?.conversation_engine]\n        ? supportsFeature(\n            this.hass.states[this._pipeline?.conversation_engine],\n            ConversationEntityFeature.CONTROL\n          )\n        : true;\n    const supportsMicrophone = AudioRecorder.isSupported;\n    const supportsSTT = this._pipeline?.stt_engine;\n\n    return html`\n      <ha-dialog\n        open\n        @closed=${this.closeDialog}\n        .heading=${this.hass.localize(\"ui.dialogs.voice_command.title\")}\n        flexContent\n      >\n        <ha-dialog-header slot=\"heading\">\n          <ha-icon-button\n            slot=\"navigationIcon\"\n            dialogAction=\"cancel\"\n            .label=${this.hass.localize(\"ui.common.close\")}\n            .path=${mdiClose}\n          ></ha-icon-button>\n          <div slot=\"title\">\n            ${this.hass.localize(\"ui.dialogs.voice_command.title\")}\n            <ha-button-menu\n              @opened=${this._loadPipelines}\n              @closed=${stopPropagation}\n              activatable\n              fixed\n            >\n              <ha-button slot=\"trigger\">\n                ${this._pipeline?.name}\n                <ha-svg-icon\n                  slot=\"trailingIcon\"\n                  .path=${mdiChevronDown}\n                ></ha-svg-icon>\n              </ha-button>\n              ${this._pipelines?.map(\n                (pipeline) =>\n                  html`<ha-list-item\n                    ?selected=${pipeline.id === this._pipelineId ||\n                    (!this._pipelineId &&\n                      pipeline.id === this._preferredPipeline)}\n                    .pipeline=${pipeline.id}\n                    @click=${this._selectPipeline}\n                    .hasMeta=${pipeline.id === this._preferredPipeline}\n                  >\n                    ${pipeline.name}${pipeline.id === this._preferredPipeline\n                      ? html`\n                          <ha-svg-icon\n                            slot=\"meta\"\n                            .path=${mdiStar}\n                          ></ha-svg-icon>\n                        `\n                      : nothing}\n                  </ha-list-item>`\n              )}\n              ${this.hass.user?.is_admin\n                ? html`<li divider role=\"separator\"></li>\n                    <a href=\"/config/voice-assistants/assistants\"\n                      ><ha-list-item @click=${this.closeDialog}\n                        >${this.hass.localize(\n                          \"ui.dialogs.voice_command.manage_assistants\"\n                        )}</ha-list-item\n                      ></a\n                    >`\n                : nothing}\n            </ha-button-menu>\n          </div>\n          <a\n            href=${documentationUrl(this.hass, \"/docs/assist/\")}\n            slot=\"actionItems\"\n            target=\"_blank\"\n            rel=\"noopener noreferer\"\n          >\n            <ha-icon-button\n              .label=${this.hass.localize(\"ui.common.help\")}\n              .path=${mdiHelpCircleOutline}\n            ></ha-icon-button>\n          </a>\n        </ha-dialog-header>\n        ${controlHA\n          ? nothing\n          : html`\n              <ha-alert>\n                ${this.hass.localize(\n                  \"ui.dialogs.voice_command.conversation_no_control\"\n                )}\n              </ha-alert>\n            `}\n        <div class=\"messages\">\n          <div class=\"messages-container\" id=\"scroll-container\">\n            ${this._conversation!.map(\n              // New lines matter for messages\n              // prettier-ignore\n              (message) => html`\n                <div class=${this._computeMessageClasses(message)}>${message.text}</div>\n              `\n            )}\n          </div>\n        </div>\n        <div class=\"input\" slot=\"primaryAction\">\n          <ha-textfield\n            id=\"message-input\"\n            @keyup=${this._handleKeyUp}\n            @input=${this._handleInput}\n            .label=${this.hass.localize(`ui.dialogs.voice_command.input_label`)}\n            dialogInitialFocus\n            iconTrailing\n          >\n            <span slot=\"trailingIcon\">\n              ${this._showSendButton || !supportsSTT\n                ? html`\n                    <ha-icon-button\n                      class=\"listening-icon\"\n                      .path=${mdiSend}\n                      @click=${this._handleSendMessage}\n                      .label=${this.hass.localize(\n                        \"ui.dialogs.voice_command.send_text\"\n                      )}\n                    >\n                    </ha-icon-button>\n                  `\n                : html`\n                    ${this._audioRecorder?.active\n                      ? html`\n                          <div class=\"bouncer\">\n                            <div class=\"double-bounce1\"></div>\n                            <div class=\"double-bounce2\"></div>\n                          </div>\n                        `\n                      : nothing}\n\n                    <div class=\"listening-icon\">\n                      <ha-icon-button\n                        .path=${mdiMicrophone}\n                        @click=${this._handleListeningButton}\n                        .label=${this.hass.localize(\n                          \"ui.dialogs.voice_command.start_listening\"\n                        )}\n                      >\n                      </ha-icon-button>\n                      ${!supportsMicrophone\n                        ? html`\n                            <ha-svg-icon\n                              .path=${mdiAlertCircle}\n                              class=\"unsupported\"\n                            ></ha-svg-icon>\n                          `\n                        : null}\n                    </div>\n                  `}\n            </span>\n          </ha-textfield>\n        </div>\n      </ha-dialog>\n    `;\n  }\n\n  protected willUpdate(changedProperties: PropertyValues): void {\n    if (\n      changedProperties.has(\"_pipelineId\") ||\n      (changedProperties.has(\"_opened\") && this._opened === true)\n    ) {\n      this._getPipeline();\n    }\n  }\n\n  private async _getPipeline() {\n    try {\n      this._pipelinePromise = getAssistPipeline(this.hass, this._pipelineId);\n      this._pipeline = await this._pipelinePromise;\n    } catch (e: any) {\n      if (e.code === \"not_found\") {\n        this._pipelineId = undefined;\n      }\n    }\n  }\n\n  private async _loadPipelines() {\n    if (this._pipelines) {\n      return;\n    }\n    const { pipelines, preferred_pipeline } = await listAssistPipelines(\n      this.hass\n    );\n    this._pipelines = pipelines;\n    this._preferredPipeline = preferred_pipeline || undefined;\n  }\n\n  private async _selectPipeline(ev: CustomEvent) {\n    this._pipelineId = (ev.currentTarget as any).pipeline;\n    this._conversation = [\n      {\n        who: \"hass\",\n        text: this.hass.localize(\"ui.dialogs.voice_command.how_can_i_help\"),\n      },\n    ];\n    await this.updateComplete;\n    this._scrollMessagesBottom();\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n    if (changedProps.has(\"_conversation\") || changedProps.has(\"results\")) {\n      this._scrollMessagesBottom();\n    }\n  }\n\n  private _addMessage(message: Message) {\n    this._conversation = [...this._conversation!, message];\n  }\n\n  private _handleKeyUp(ev: KeyboardEvent) {\n    const input = ev.target as HaTextField;\n    if (ev.key === \"Enter\" && input.value) {\n      this._processText(input.value);\n      input.value = \"\";\n      this._showSendButton = false;\n    }\n  }\n\n  private _handleInput(ev: InputEvent) {\n    const value = (ev.target as HaTextField).value;\n    if (value && !this._showSendButton) {\n      this._showSendButton = true;\n    } else if (!value && this._showSendButton) {\n      this._showSendButton = false;\n    }\n  }\n\n  private _handleSendMessage() {\n    if (this._messageInput.value) {\n      this._processText(this._messageInput.value.trim());\n      this._messageInput.value = \"\";\n      this._showSendButton = false;\n    }\n  }\n\n  private async _processText(text: string) {\n    this._audio?.pause();\n    this._addMessage({ who: \"user\", text });\n    const message: Message = {\n      who: \"hass\",\n      text: \"…\",\n    };\n    // To make sure the answer is placed at the right user text, we add it before we process it\n    this._addMessage(message);\n    try {\n      const unsub = await runAssistPipeline(\n        this.hass,\n        (event) => {\n          if (event.type === \"intent-end\") {\n            this._conversationId = event.data.intent_output.conversation_id;\n            const plain = event.data.intent_output.response.speech?.plain;\n            if (plain) {\n              message.text = plain.speech;\n            }\n            this.requestUpdate(\"_conversation\");\n            unsub();\n          }\n          if (event.type === \"error\") {\n            message.text = event.data.message;\n            message.error = true;\n            this.requestUpdate(\"_conversation\");\n            unsub();\n          }\n        },\n        {\n          start_stage: \"intent\",\n          input: { text },\n          end_stage: \"intent\",\n          pipeline: this._pipeline?.id,\n          conversation_id: this._conversationId,\n        }\n      );\n    } catch {\n      message.text = this.hass.localize(\"ui.dialogs.voice_command.error\");\n      message.error = true;\n      this.requestUpdate(\"_conversation\");\n    }\n  }\n\n  private _handleListeningButton(ev) {\n    ev.stopPropagation();\n    ev.preventDefault();\n    this._toggleListening();\n  }\n\n  private _toggleListening() {\n    const supportsMicrophone = AudioRecorder.isSupported;\n    if (!supportsMicrophone) {\n      this._showNotSupportedMessage();\n      return;\n    }\n    if (!this._audioRecorder?.active) {\n      this._startListening();\n    } else {\n      this._stopListening();\n    }\n  }\n\n  private async _showNotSupportedMessage() {\n    this._addMessage({\n      who: \"hass\",\n      text:\n        // New lines matter for messages\n        // prettier-ignore\n        html`${this.hass.localize(\n          \"ui.dialogs.voice_command.not_supported_microphone_browser\"\n        )}\n\n        ${this.hass.localize(\n          \"ui.dialogs.voice_command.not_supported_microphone_documentation\",\n          {\n            documentation_link: html`<a\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n                href=${documentationUrl(\n                  this.hass,\n                  \"/docs/configuration/securing/#remote-access\"\n                )}\n              >${this.hass.localize(\n                  \"ui.dialogs.voice_command.not_supported_microphone_documentation_link\"\n                )}</a>`,\n          }\n        )}`,\n    });\n  }\n\n  private async _startListening() {\n    this._audio?.pause();\n    if (!this._audioRecorder) {\n      this._audioRecorder = new AudioRecorder((audio) => {\n        if (this._audioBuffer) {\n          this._audioBuffer.push(audio);\n        } else {\n          this._sendAudioChunk(audio);\n        }\n      });\n    }\n    this._stt_binary_handler_id = undefined;\n    this._audioBuffer = [];\n    const userMessage: Message = {\n      who: \"user\",\n      text: \"…\",\n    };\n    await this._audioRecorder.start();\n\n    this._addMessage(userMessage);\n    this.requestUpdate(\"_audioRecorder\");\n\n    const hassMessage: Message = {\n      who: \"hass\",\n      text: \"…\",\n    };\n    // To make sure the answer is placed at the right user text, we add it before we process it\n    try {\n      const unsub = await runAssistPipeline(\n        this.hass,\n        (event) => {\n          if (event.type === \"run-start\") {\n            this._stt_binary_handler_id =\n              event.data.runner_data.stt_binary_handler_id;\n          }\n\n          // When we start STT stage, the WS has a binary handler\n          if (event.type === \"stt-start\" && this._audioBuffer) {\n            // Send the buffer over the WS to the STT engine.\n            for (const buffer of this._audioBuffer) {\n              this._sendAudioChunk(buffer);\n            }\n            this._audioBuffer = undefined;\n          }\n\n          // Stop recording if the server is done with STT stage\n          if (event.type === \"stt-end\") {\n            this._stt_binary_handler_id = undefined;\n            this._stopListening();\n            userMessage.text = event.data.stt_output.text;\n            this.requestUpdate(\"_conversation\");\n            // To make sure the answer is placed at the right user text, we add it before we process it\n            this._addMessage(hassMessage);\n          }\n\n          if (event.type === \"intent-end\") {\n            this._conversationId = event.data.intent_output.conversation_id;\n            const plain = event.data.intent_output.response.speech?.plain;\n            if (plain) {\n              hassMessage.text = plain.speech;\n            }\n            this.requestUpdate(\"_conversation\");\n          }\n\n          if (event.type === \"tts-end\") {\n            const url = event.data.tts_output.url;\n            this._audio = new Audio(url);\n            this._audio.play();\n            this._audio.addEventListener(\"ended\", this._unloadAudio);\n            this._audio.addEventListener(\"pause\", this._unloadAudio);\n            this._audio.addEventListener(\"canplaythrough\", this._playAudio);\n            this._audio.addEventListener(\"error\", this._audioError);\n          }\n\n          if (event.type === \"run-end\") {\n            this._stt_binary_handler_id = undefined;\n            unsub();\n          }\n\n          if (event.type === \"error\") {\n            this._stt_binary_handler_id = undefined;\n            if (userMessage.text === \"…\") {\n              userMessage.text = event.data.message;\n              userMessage.error = true;\n            } else {\n              hassMessage.text = event.data.message;\n              hassMessage.error = true;\n            }\n            this._stopListening();\n            this.requestUpdate(\"_conversation\");\n            unsub();\n          }\n        },\n        {\n          start_stage: \"stt\",\n          end_stage: this._pipeline?.tts_engine ? \"tts\" : \"intent\",\n          input: { sample_rate: this._audioRecorder.sampleRate! },\n          pipeline: this._pipeline?.id,\n          conversation_id: this._conversationId,\n        }\n      );\n    } catch (err: any) {\n      await showAlertDialog(this, {\n        title: \"Error starting pipeline\",\n        text: err.message || err,\n      });\n      this._stopListening();\n    }\n  }\n\n  private _stopListening() {\n    this._audioRecorder?.stop();\n    this.requestUpdate(\"_audioRecorder\");\n    // We're currently STTing, so finish audio\n    if (this._stt_binary_handler_id) {\n      if (this._audioBuffer) {\n        for (const chunk of this._audioBuffer) {\n          this._sendAudioChunk(chunk);\n        }\n      }\n      // Send empty message to indicate we're done streaming.\n      this._sendAudioChunk(new Int16Array());\n      this._stt_binary_handler_id = undefined;\n    }\n    this._audioBuffer = undefined;\n  }\n\n  private _sendAudioChunk(chunk: Int16Array) {\n    this.hass.connection.socket!.binaryType = \"arraybuffer\";\n\n    // eslint-disable-next-line eqeqeq\n    if (this._stt_binary_handler_id == undefined) {\n      return;\n    }\n    // Turn into 8 bit so we can prefix our handler ID.\n    const data = new Uint8Array(1 + chunk.length * 2);\n    data[0] = this._stt_binary_handler_id;\n    data.set(new Uint8Array(chunk.buffer), 1);\n\n    this.hass.connection.socket!.send(data);\n  }\n\n  private _playAudio = () => {\n    this._audio?.play();\n  };\n\n  private _audioError = () => {\n    showAlertDialog(this, { title: \"Error playing audio.\" });\n    this._audio?.removeAttribute(\"src\");\n  };\n\n  private _unloadAudio = () => {\n    this._audio?.removeAttribute(\"src\");\n    this._audio = undefined;\n  };\n\n  private _scrollMessagesBottom() {\n    const scrollContainer = this._scrollContainer;\n    if (!scrollContainer) {\n      return;\n    }\n    scrollContainer.scrollTo(0, 99999);\n  }\n\n  private _computeMessageClasses(message: Message) {\n    return `message ${message.who} ${message.error ? \" error\" : \"\"}`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyleDialog,\n      css`\n        .listening-icon {\n          position: relative;\n          color: var(--secondary-text-color);\n          margin-right: -24px;\n          margin-inline-end: -24px;\n          margin-inline-start: initial;\n          direction: var(--direction);\n          transform: scaleX(var(--scale-direction));\n        }\n\n        .listening-icon[active] {\n          color: var(--primary-color);\n        }\n\n        .unsupported {\n          color: var(--error-color);\n          position: absolute;\n          --mdc-icon-size: 16px;\n          right: 5px;\n          inset-inline-end: 5px;\n          inset-inline-start: initial;\n          top: 0px;\n        }\n\n        ha-dialog {\n          --primary-action-button-flex: 1;\n          --secondary-action-button-flex: 0;\n          --mdc-dialog-max-width: 500px;\n          --mdc-dialog-max-height: 500px;\n          --dialog-content-padding: 0;\n        }\n        ha-dialog-header a {\n          color: var(--primary-text-color);\n        }\n        div[slot=\"title\"] {\n          display: flex;\n          flex-direction: column;\n          margin: -4px 0;\n        }\n        ha-button-menu {\n          --mdc-theme-on-primary: var(--text-primary-color);\n          --mdc-theme-primary: var(--primary-color);\n          margin-top: -8px;\n          margin-bottom: 0;\n          margin-right: 0;\n          margin-inline-end: 0;\n          margin-left: -8px;\n          margin-inline-start: -8px;\n        }\n        ha-button-menu ha-button {\n          --mdc-theme-primary: var(--secondary-text-color);\n          --mdc-typography-button-text-transform: none;\n          --mdc-typography-button-font-size: unset;\n          --mdc-typography-button-font-weight: 400;\n          --mdc-typography-button-letter-spacing: var(\n            --mdc-typography-headline6-letter-spacing,\n            0.0125em\n          );\n          --mdc-typography-button-line-height: var(\n            --mdc-typography-headline6-line-height,\n            2rem\n          );\n          --button-height: auto;\n        }\n        ha-button-menu ha-button ha-svg-icon {\n          height: 28px;\n          margin-left: 4px;\n          margin-inline-start: 4px;\n          margin-inline-end: initial;\n          direction: var(--direction);\n        }\n        ha-list-item {\n          --mdc-list-item-meta-size: 16px;\n        }\n        ha-list-item ha-svg-icon {\n          margin-left: 4px;\n          margin-inline-start: 4px;\n          margin-inline-end: initial;\n          direction: var(--direction);\n          display: block;\n        }\n        ha-button-menu a {\n          text-decoration: none;\n        }\n        ha-textfield {\n          display: block;\n          overflow: hidden;\n        }\n        a.button {\n          text-decoration: none;\n        }\n        a.button > mwc-button {\n          width: 100%;\n        }\n        .side-by-side {\n          display: flex;\n          margin: 8px 0;\n        }\n        .side-by-side > * {\n          flex: 1 0;\n          padding: 4px;\n        }\n        .messages {\n          display: block;\n          height: 400px;\n          box-sizing: border-box;\n          position: relative;\n        }\n        @media all and (max-width: 450px), all and (max-height: 500px) {\n          ha-dialog {\n            --mdc-dialog-max-width: 100%;\n          }\n          .messages {\n            height: 100%;\n            flex: 1;\n          }\n        }\n        .messages-container {\n          position: absolute;\n          bottom: 0px;\n          right: 0px;\n          left: 0px;\n          padding: 24px;\n          box-sizing: border-box;\n          overflow-y: auto;\n          max-height: 100%;\n        }\n        .message {\n          white-space: pre-line;\n          font-size: 18px;\n          clear: both;\n          margin: 8px 0;\n          padding: 8px;\n          border-radius: 15px;\n        }\n        .message p {\n          margin: 0;\n        }\n        .message p:not(:last-child) {\n          margin-bottom: 8px;\n        }\n\n        .message.user {\n          margin-left: 24px;\n          margin-inline-start: 24px;\n          margin-inline-end: initial;\n          float: var(--float-end);\n          text-align: right;\n          border-bottom-right-radius: 0px;\n          background-color: var(--primary-color);\n          color: var(--text-primary-color);\n          direction: var(--direction);\n        }\n\n        .message.hass {\n          margin-right: 24px;\n          margin-inline-end: 24px;\n          margin-inline-start: initial;\n          float: var(--float-start);\n          border-bottom-left-radius: 0px;\n          background-color: var(--secondary-background-color);\n          color: var(--primary-text-color);\n          direction: var(--direction);\n        }\n\n        .message.user a {\n          color: var(--text-primary-color);\n        }\n\n        .message.hass a {\n          color: var(--primary-text-color);\n        }\n\n        .message img {\n          width: 100%;\n          border-radius: 10px;\n        }\n\n        .message.error {\n          background-color: var(--error-color);\n          color: var(--text-primary-color);\n        }\n\n        .input {\n          margin-left: 0;\n          margin-right: 0;\n        }\n\n        .bouncer {\n          width: 48px;\n          height: 48px;\n          position: absolute;\n        }\n        .double-bounce1,\n        .double-bounce2 {\n          width: 48px;\n          height: 48px;\n          border-radius: 50%;\n          background-color: var(--primary-color);\n          opacity: 0.2;\n          position: absolute;\n          top: 0;\n          left: 0;\n          -webkit-animation: sk-bounce 2s infinite ease-in-out;\n          animation: sk-bounce 2s infinite ease-in-out;\n        }\n        .double-bounce2 {\n          -webkit-animation-delay: -1s;\n          animation-delay: -1s;\n        }\n        @-webkit-keyframes sk-bounce {\n          0%,\n          100% {\n            -webkit-transform: scale(0);\n          }\n          50% {\n            -webkit-transform: scale(1);\n          }\n        }\n        @keyframes sk-bounce {\n          0%,\n          100% {\n            transform: scale(0);\n            -webkit-transform: scale(0);\n          }\n          50% {\n            transform: scale(1);\n            -webkit-transform: scale(1);\n          }\n        }\n\n        @media all and (max-width: 450px), all and (max-height: 500px) {\n          .message {\n            font-size: 16px;\n          }\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-voice-command-dialog\": HaVoiceCommandDialog;\n  }\n}\n"],"names":[],"sourceRoot":""}