{"version":3,"file":"BRhLQwO2.js","mappings":";;AA0FA;AACA;;;;AASA;;AAiCA;AACA;;;AASA;AAGA;AAGA;;AAIA;AACA;;AAIA;AA0BA;AAJA;ACPA;;;AAIA;AACA;;;;AAIA;;AASA;AACA;AACA;;;;;;;;;AASA;;AAEA;;;AAKA;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;;AAmGA;;ACzSA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/state-display/state-display.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/entity/ha-entity-state-content-picker.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-selector/ha-selector-ui-state-content.ts"],"sourcesContent":["import type { HassEntity } from \"home-assistant-js-websocket\";\nimport type { TemplateResult } from \"lit\";\nimport { html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { ensureArray } from \"../common/array/ensure-array\";\nimport { computeStateDomain } from \"../common/entity/compute_state_domain\";\nimport \"../components/ha-relative-time\";\nimport { isUnavailableState } from \"../data/entity\";\nimport { SENSOR_DEVICE_CLASS_TIMESTAMP } from \"../data/sensor\";\nimport type { UpdateEntity } from \"../data/update\";\nimport { computeUpdateStateDisplay } from \"../data/update\";\nimport \"../panels/lovelace/components/hui-timestamp-display\";\nimport type { HomeAssistant } from \"../types\";\n\nconst TIMESTAMP_STATE_DOMAINS = [\"button\", \"input_button\", \"scene\"];\n\nexport const STATE_DISPLAY_SPECIAL_CONTENT = [\n  \"remaining_time\",\n  \"install_status\",\n] as const;\n\n// Special handling of state attributes per domain\nexport const STATE_DISPLAY_SPECIAL_CONTENT_DOMAINS: Record<\n  string,\n  (typeof STATE_DISPLAY_SPECIAL_CONTENT)[number][]\n> = {\n  timer: [\"remaining_time\"],\n  update: [\"install_status\"],\n};\n\n// Attributes that should not be shown if their value is 0 */\nexport const HIDDEN_ZERO_ATTRIBUTES_DOMAINS: Record<string, string[]> = {\n  valve: [\"current_position\"],\n  cover: [\"current_position\"],\n  fan: [\"percentage\"],\n  light: [\"brightness\"],\n};\n\ntype StateContent = string | string[];\n\nexport const DEFAULT_STATE_CONTENT_DOMAINS: Record<string, StateContent> = {\n  climate: [\"state\", \"current_temperature\"],\n  cover: [\"state\", \"current_position\"],\n  fan: \"percentage\",\n  humidifier: [\"state\", \"current_humidity\"],\n  light: \"brightness\",\n  timer: \"remaining_time\",\n  update: \"install_status\",\n  valve: [\"state\", \"current_position\"],\n};\n\n@customElement(\"state-display\")\nclass StateDisplay extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj!: HassEntity;\n\n  @property({ attribute: false }) public content?: StateContent;\n\n  @property({ attribute: false }) public name?: string;\n\n  @property({ type: Boolean, attribute: \"dash-unavailable\" })\n  public dashUnavailable?: boolean;\n\n  protected createRenderRoot() {\n    return this;\n  }\n\n  private get _content(): StateContent {\n    const domain = computeStateDomain(this.stateObj);\n    return this.content ?? DEFAULT_STATE_CONTENT_DOMAINS[domain] ?? \"state\";\n  }\n\n  private _computeContent(\n    content: string\n  ): TemplateResult<1> | string | undefined {\n    const stateObj = this.stateObj;\n    const domain = computeStateDomain(stateObj);\n\n    if (content === \"state\") {\n      if (this.dashUnavailable && isUnavailableState(stateObj.state)) {\n        return \"—\";\n      }\n      if (\n        (stateObj.attributes.device_class === SENSOR_DEVICE_CLASS_TIMESTAMP ||\n          TIMESTAMP_STATE_DOMAINS.includes(domain)) &&\n        !isUnavailableState(stateObj.state)\n      ) {\n        return html`\n          <hui-timestamp-display\n            .hass=${this.hass}\n            .ts=${new Date(stateObj.state)}\n            format=\"relative\"\n            capitalize\n          ></hui-timestamp-display>\n        `;\n      }\n\n      return this.hass!.formatEntityState(stateObj);\n    }\n    if (content === \"name\") {\n      return html`${this.name || stateObj.attributes.friendly_name}`;\n    }\n\n    let relativeDateTime: string | undefined;\n\n    // Check last-changed for backwards compatibility\n    if (content === \"last_changed\" || content === \"last-changed\") {\n      relativeDateTime = stateObj.last_changed;\n    }\n    // Check last_updated for backwards compatibility\n    if (content === \"last_updated\" || content === \"last-updated\") {\n      relativeDateTime = stateObj.last_updated;\n    }\n\n    if (\n      content === \"last_triggered\" ||\n      (domain === \"calendar\" &&\n        (content === \"start_time\" || content === \"end_time\")) ||\n      (domain === \"sun\" &&\n        (content === \"next_dawn\" ||\n          content === \"next_dusk\" ||\n          content === \"next_midnight\" ||\n          content === \"next_noon\" ||\n          content === \"next_rising\" ||\n          content === \"next_setting\"))\n    ) {\n      relativeDateTime = stateObj.attributes[content];\n    }\n\n    if (relativeDateTime) {\n      return html`\n        <ha-relative-time\n          .hass=${this.hass}\n          .datetime=${relativeDateTime}\n          capitalize\n        ></ha-relative-time>\n      `;\n    }\n\n    const specialContent = (STATE_DISPLAY_SPECIAL_CONTENT_DOMAINS[domain] ??\n      []) as string[];\n\n    if (specialContent.includes(content)) {\n      if (content === \"install_status\") {\n        return html`\n          ${computeUpdateStateDisplay(stateObj as UpdateEntity, this.hass!)}\n        `;\n      }\n      if (content === \"remaining_time\") {\n        import(\"./ha-timer-remaining-time\");\n        return html`\n          <ha-timer-remaining-time\n            .hass=${this.hass}\n            .stateObj=${stateObj}\n          ></ha-timer-remaining-time>\n        `;\n      }\n    }\n\n    const attribute = stateObj.attributes[content];\n\n    if (\n      attribute == null ||\n      (HIDDEN_ZERO_ATTRIBUTES_DOMAINS[domain]?.includes(content) && !attribute)\n    ) {\n      return undefined;\n    }\n    return this.hass!.formatEntityAttributeValue(stateObj, content);\n  }\n\n  protected render() {\n    const stateObj = this.stateObj;\n    const contents = ensureArray(this._content);\n\n    const values = contents\n      .map((content) => this._computeContent(content))\n      .filter(Boolean);\n\n    if (!values.length) {\n      return html`${this.hass!.formatEntityState(stateObj)}`;\n    }\n\n    return html`\n      ${values.map(\n        (value, index, array) =>\n          html`${value}${index < array.length - 1 ? \" ⸱ \" : nothing}`\n      )}\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-display\": StateDisplay;\n  }\n}\n","import { mdiDrag } from \"@mdi/js\";\nimport type { HassEntity } from \"home-assistant-js-websocket\";\nimport type { PropertyValues } from \"lit\";\nimport { LitElement, css, html, nothing } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { repeat } from \"lit/directives/repeat\";\nimport memoizeOne from \"memoize-one\";\nimport { ensureArray } from \"../../common/array/ensure-array\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport {\n  STATE_DISPLAY_SPECIAL_CONTENT,\n  STATE_DISPLAY_SPECIAL_CONTENT_DOMAINS,\n} from \"../../state-display/state-display\";\nimport type { HomeAssistant, ValueChangedEvent } from \"../../types\";\nimport \"../ha-combo-box\";\nimport \"../ha-sortable\";\nimport \"../chips/ha-input-chip\";\nimport \"../chips/ha-chip-set\";\nimport type { HaComboBox } from \"../ha-combo-box\";\n\nconst HIDDEN_ATTRIBUTES = [\n  \"access_token\",\n  \"available_modes\",\n  \"battery_icon\",\n  \"battery_level\",\n  \"code_arm_required\",\n  \"code_format\",\n  \"color_modes\",\n  \"device_class\",\n  \"editable\",\n  \"effect_list\",\n  \"entity_id\",\n  \"entity_picture\",\n  \"event_types\",\n  \"fan_modes\",\n  \"fan_speed_list\",\n  \"friendly_name\",\n  \"frontend_stream_type\",\n  \"has_date\",\n  \"has_time\",\n  \"hvac_modes\",\n  \"icon\",\n  \"id\",\n  \"max_color_temp_kelvin\",\n  \"max_mireds\",\n  \"max_temp\",\n  \"max\",\n  \"min_color_temp_kelvin\",\n  \"min_mireds\",\n  \"min_temp\",\n  \"min\",\n  \"mode\",\n  \"operation_list\",\n  \"options\",\n  \"percentage_step\",\n  \"precipitation_unit\",\n  \"preset_modes\",\n  \"pressure_unit\",\n  \"remaining\",\n  \"sound_mode_list\",\n  \"source_list\",\n  \"state_class\",\n  \"step\",\n  \"supported_color_modes\",\n  \"supported_features\",\n  \"swing_modes\",\n  \"target_temp_step\",\n  \"temperature_unit\",\n  \"token\",\n  \"unit_of_measurement\",\n  \"visibility_unit\",\n  \"wind_speed_unit\",\n];\n\n@customElement(\"ha-entity-state-content-picker\")\nclass HaEntityStatePicker extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entityId?: string;\n\n  @property({ type: Boolean }) public autofocus = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @property({ type: Boolean, attribute: \"allow-name\" }) public allowName =\n    false;\n\n  @property() public label?: string;\n\n  @property() public value?: string[] | string;\n\n  @property() public helper?: string;\n\n  @state() private _opened = false;\n\n  @query(\"ha-combo-box\", true) private _comboBox!: HaComboBox;\n\n  protected shouldUpdate(changedProps: PropertyValues) {\n    return !(!changedProps.has(\"_opened\") && this._opened);\n  }\n\n  private options = memoizeOne(\n    (entityId?: string, stateObj?: HassEntity, allowName?: boolean) => {\n      const domain = entityId ? computeDomain(entityId) : undefined;\n      return [\n        {\n          label: this.hass.localize(\"ui.components.state-content-picker.state\"),\n          value: \"state\",\n        },\n        ...(allowName\n          ? [\n              {\n                label: this.hass.localize(\n                  \"ui.components.state-content-picker.name\"\n                ),\n                value: \"name\",\n              },\n            ]\n          : []),\n        {\n          label: this.hass.localize(\n            \"ui.components.state-content-picker.last_changed\"\n          ),\n          value: \"last_changed\",\n        },\n        {\n          label: this.hass.localize(\n            \"ui.components.state-content-picker.last_updated\"\n          ),\n          value: \"last_updated\",\n        },\n        ...(domain\n          ? STATE_DISPLAY_SPECIAL_CONTENT.filter((content) =>\n              STATE_DISPLAY_SPECIAL_CONTENT_DOMAINS[domain]?.includes(content)\n            ).map((content) => ({\n              label: this.hass.localize(\n                `ui.components.state-content-picker.${content}`\n              ),\n              value: content,\n            }))\n          : []),\n        ...Object.keys(stateObj?.attributes ?? {})\n          .filter((a) => !HIDDEN_ATTRIBUTES.includes(a))\n          .map((attribute) => ({\n            value: attribute,\n            label: this.hass.formatEntityAttributeName(stateObj!, attribute),\n          })),\n      ];\n    }\n  );\n\n  private _filter = \"\";\n\n  protected render() {\n    if (!this.hass) {\n      return nothing;\n    }\n\n    const value = this._value;\n\n    const stateObj = this.entityId\n      ? this.hass.states[this.entityId]\n      : undefined;\n\n    const options = this.options(this.entityId, stateObj, this.allowName);\n    const optionItems = options.filter(\n      (option) => !this._value.includes(option.value)\n    );\n\n    return html`\n      ${value?.length\n        ? html`\n            <ha-sortable\n              no-style\n              @item-moved=${this._moveItem}\n              .disabled=${this.disabled}\n              filter=\"button.trailing.action\"\n            >\n              <ha-chip-set>\n                ${repeat(\n                  this._value,\n                  (item) => item,\n                  (item, idx) => {\n                    const label =\n                      options.find((option) => option.value === item)?.label ||\n                      item;\n                    return html`\n                      <ha-input-chip\n                        .idx=${idx}\n                        @remove=${this._removeItem}\n                        .label=${label}\n                        selected\n                      >\n                        <ha-svg-icon\n                          slot=\"icon\"\n                          .path=${mdiDrag}\n                          data-handle\n                        ></ha-svg-icon>\n\n                        ${label}\n                      </ha-input-chip>\n                    `;\n                  }\n                )}\n              </ha-chip-set>\n            </ha-sortable>\n          `\n        : nothing}\n\n      <ha-combo-box\n        item-value-path=\"value\"\n        item-label-path=\"label\"\n        .hass=${this.hass}\n        .label=${this.label}\n        .helper=${this.helper}\n        .disabled=${this.disabled}\n        .required=${this.required && !value.length}\n        .value=${\"\"}\n        .items=${optionItems}\n        allow-custom-value\n        @filter-changed=${this._filterChanged}\n        @value-changed=${this._comboBoxValueChanged}\n        @opened-changed=${this._openedChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return !this.value ? [] : ensureArray(this.value);\n  }\n\n  private _openedChanged(ev: ValueChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n    this._comboBox.filteredItems = this._comboBox.items;\n  }\n\n  private _filterChanged(ev?: CustomEvent): void {\n    this._filter = ev?.detail.value || \"\";\n\n    const filteredItems = this._comboBox.items?.filter((item) => {\n      const label = item.label || item.value;\n      return label.toLowerCase().includes(this._filter?.toLowerCase());\n    });\n\n    if (this._filter) {\n      filteredItems?.unshift({ label: this._filter, value: this._filter });\n    }\n\n    this._comboBox.filteredItems = filteredItems;\n  }\n\n  private async _moveItem(ev: CustomEvent) {\n    ev.stopPropagation();\n    const { oldIndex, newIndex } = ev.detail;\n    const value = this._value;\n    const newValue = value.concat();\n    const element = newValue.splice(oldIndex, 1)[0];\n    newValue.splice(newIndex, 0, element);\n    this._setValue(newValue);\n    await this.updateComplete;\n    this._filterChanged();\n  }\n\n  private async _removeItem(ev) {\n    ev.stopPropagation();\n    const value: string[] = [...this._value];\n    value.splice(ev.target.idx, 1);\n    this._setValue(value);\n    await this.updateComplete;\n    this._filterChanged();\n  }\n\n  private _comboBoxValueChanged(ev: CustomEvent): void {\n    ev.stopPropagation();\n    const newValue = ev.detail.value;\n\n    if (this.disabled || newValue === \"\") {\n      return;\n    }\n\n    const currentValue = this._value;\n\n    if (currentValue.includes(newValue)) {\n      return;\n    }\n\n    setTimeout(() => {\n      this._filterChanged();\n      this._comboBox.setInputValue(\"\");\n    }, 0);\n\n    this._setValue([...currentValue, newValue]);\n  }\n\n  private _setValue(value: string[]) {\n    const newValue =\n      value.length === 0 ? undefined : value.length === 1 ? value[0] : value;\n    this.value = newValue;\n    fireEvent(this, \"value-changed\", {\n      value: newValue,\n    });\n  }\n\n  static styles = css`\n    :host {\n      position: relative;\n    }\n\n    ha-chip-set {\n      padding: 8px 0;\n    }\n\n    .sortable-fallback {\n      display: none;\n      opacity: 0;\n    }\n\n    .sortable-ghost {\n      opacity: 0.4;\n    }\n\n    .sortable-drag {\n      cursor: grabbing;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-entity-state-content-picker\": HaEntityStatePicker;\n  }\n}\n","import { html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport type { UiStateContentSelector } from \"../../data/selector\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../entity/ha-entity-state-content-picker\";\n\n@customElement(\"ha-selector-ui_state_content\")\nexport class HaSelectorUiStateContent extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public selector!: UiStateContentSelector;\n\n  @property() public value?: string | string[];\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = true;\n\n  @property({ attribute: false }) public context?: {\n    filter_entity?: string;\n  };\n\n  protected render() {\n    return html`\n      <ha-entity-state-content-picker\n        .hass=${this.hass}\n        .entityId=${this.selector.ui_state_content?.entity_id ||\n        this.context?.filter_entity}\n        .value=${this.value}\n        .label=${this.label}\n        .helper=${this.helper}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        .allowName=${this.selector.ui_state_content?.allow_name}\n      ></ha-entity-state-content-picker>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-ui_state_content\": HaSelectorUiStateContent;\n  }\n}\n"],"names":[],"sourceRoot":""}