{"version":3,"file":"RWkmms3x.js","mappings":";AAoDA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;;;;;;;AA+CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCA;AAIA;;AAKA;;;;ACpEA;;;;;AC4BA;ACPA;;AAGA;AACA;;;;;AAKA;AA5CA;;;;AAiDA;;AAKA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;AAGA;;AAGA;AAMA;;;;AAKA;AACA;;AAGA;AACA;AACA;AACA;;;;AAMA;;;;;;;;;;;;;;;AAwCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;;;;;;AAOA;;ACxBA;AACA;;AAEA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2HA;;;;;;;;;;AAWA;ACrMA;AAGA;;AAGA;AACA;;AAEA;;AAGA;AACA;;;;;;AAMA;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA;ACtBA;AACA;AACA;;AAMA;AACA;AAGA;AAMA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwHA;ACtFA;AACA;AAaA;AACA;AAYA;AACA;;AAmCA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;;AAEA;AACA;;AAGA;;AAGA;AACA;;AAEA;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-button-menu.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-card.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-checkbox.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-circular-progress.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-icon-overflow-menu.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-list-item.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-textfield.ts","webpack://knx-frontend/./homeassistant-frontend/src/layouts/hass-loading-screen.ts","webpack://knx-frontend/./src/components/knx-project-tree-view.ts","webpack://knx-frontend/./src/views/project_view.ts"],"sourcesContent":["import type { Button } from \"@material/mwc-button\";\nimport \"@material/mwc-menu\";\nimport type { Corner, Menu, MenuCorner } from \"@material/mwc-menu\";\nimport type { CSSResultGroup, TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { mainWindow } from \"../common/dom/get_main_window\";\nimport { FOCUS_TARGET } from \"../dialogs/make-dialog-manager\";\nimport type { HaIconButton } from \"./ha-icon-button\";\n\n@customElement(\"ha-button-menu\")\nexport class HaButtonMenu extends LitElement {\n  protected readonly [FOCUS_TARGET];\n\n  @property() public corner: Corner = \"BOTTOM_START\";\n\n  @property() public menuCorner: MenuCorner = \"START\";\n\n  @property({ type: Number }) public x: number | null = null;\n\n  @property({ type: Number }) public y: number | null = null;\n\n  @property({ type: Boolean }) public multi = false;\n\n  @property({ type: Boolean }) public activatable = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public fixed = false;\n\n  @property({ type: Boolean, attribute: \"no-anchor\" }) public noAnchor = false;\n\n  @query(\"mwc-menu\", true) private _menu?: Menu;\n\n  public get items() {\n    return this._menu?.items;\n  }\n\n  public get selected() {\n    return this._menu?.selected;\n  }\n\n  public override focus() {\n    if (this._menu?.open) {\n      this._menu.focusItemAtIndex(0);\n    } else {\n      this._triggerButton?.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div @click=${this._handleClick}>\n        <slot name=\"trigger\" @slotchange=${this._setTriggerAria}></slot>\n      </div>\n      <mwc-menu\n        .corner=${this.corner}\n        .menuCorner=${this.menuCorner}\n        .fixed=${this.fixed}\n        .multi=${this.multi}\n        .activatable=${this.activatable}\n        .y=${this.y}\n        .x=${this.x}\n      >\n        <slot></slot>\n      </mwc-menu>\n    `;\n  }\n\n  protected firstUpdated(changedProps): void {\n    super.firstUpdated(changedProps);\n\n    if (mainWindow.document.dir === \"rtl\") {\n      this.updateComplete.then(() => {\n        this.querySelectorAll(\"mwc-list-item\").forEach((item) => {\n          const style = document.createElement(\"style\");\n          style.innerHTML =\n            \"span.material-icons:first-of-type { margin-left: var(--mdc-list-item-graphic-margin, 32px) !important; margin-right: 0px !important;}\";\n          item!.shadowRoot!.appendChild(style);\n        });\n      });\n    }\n  }\n\n  private _handleClick(): void {\n    if (this.disabled) {\n      return;\n    }\n    this._menu!.anchor = this.noAnchor ? null : this;\n    this._menu!.show();\n  }\n\n  private get _triggerButton() {\n    return this.querySelector(\n      'ha-icon-button[slot=\"trigger\"], mwc-button[slot=\"trigger\"]'\n    ) as HaIconButton | Button | null;\n  }\n\n  private _setTriggerAria() {\n    if (this._triggerButton) {\n      this._triggerButton.ariaHasPopup = \"menu\";\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n        position: relative;\n      }\n      ::slotted([disabled]) {\n        color: var(--disabled-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button-menu\": HaButtonMenu;\n  }\n}\n","import type { CSSResultGroup } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-card\")\nexport class HaCard extends LitElement {\n  @property() public header?: string;\n\n  @property({ type: Boolean, reflect: true }) public raised = false;\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        background: var(\n          --ha-card-background,\n          var(--card-background-color, white)\n        );\n        -webkit-backdrop-filter: var(--ha-card-backdrop-filter, none);\n        backdrop-filter: var(--ha-card-backdrop-filter, none);\n        box-shadow: var(--ha-card-box-shadow, none);\n        box-sizing: border-box;\n        border-radius: var(--ha-card-border-radius, 12px);\n        border-width: var(--ha-card-border-width, 1px);\n        border-style: solid;\n        border-color: var(\n          --ha-card-border-color,\n          var(--divider-color, #e0e0e0)\n        );\n        color: var(--primary-text-color);\n        display: block;\n        transition: all 0.3s ease-out;\n        position: relative;\n      }\n\n      :host([raised]) {\n        border: none;\n        box-shadow: var(\n          --ha-card-box-shadow,\n          0px 2px 1px -1px rgba(0, 0, 0, 0.2),\n          0px 1px 1px 0px rgba(0, 0, 0, 0.14),\n          0px 1px 3px 0px rgba(0, 0, 0, 0.12)\n        );\n      }\n\n      .card-header,\n      :host ::slotted(.card-header) {\n        color: var(--ha-card-header-color, var(--primary-text-color));\n        font-family: var(--ha-card-header-font-family, inherit);\n        font-size: var(--ha-card-header-font-size, 24px);\n        letter-spacing: -0.012em;\n        line-height: 48px;\n        padding: 12px 16px 16px;\n        display: block;\n        margin-block-start: 0px;\n        margin-block-end: 0px;\n        font-weight: normal;\n      }\n\n      :host ::slotted(.card-content:not(:first-child)),\n      slot:not(:first-child)::slotted(.card-content) {\n        padding-top: 0px;\n        margin-top: -8px;\n      }\n\n      :host ::slotted(.card-content) {\n        padding: 16px;\n      }\n\n      :host ::slotted(.card-actions) {\n        border-top: 1px solid var(--divider-color, #e8e8e8);\n        padding: 5px 16px;\n      }\n    `;\n  }\n\n  protected render() {\n    return html`\n      ${this.header\n        ? html`<h1 class=\"card-header\">${this.header}</h1>`\n        : nothing}\n      <slot></slot>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-card\": HaCard;\n  }\n}\n","import { CheckboxBase } from \"@material/mwc-checkbox/mwc-checkbox-base\";\nimport { styles } from \"@material/mwc-checkbox/mwc-checkbox.css\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-checkbox\")\nexport class HaCheckbox extends CheckboxBase {\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--primary-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-checkbox\": HaCheckbox;\n  }\n}\n","import { MdCircularProgress } from \"@material/web/progress/circular-progress\";\nimport type { PropertyValues } from \"lit\";\nimport { css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-circular-progress\")\nexport class HaCircularProgress extends MdCircularProgress {\n  @property({ attribute: \"aria-label\", type: String }) public ariaLabel =\n    \"Loading\";\n\n  @property() public size: \"tiny\" | \"small\" | \"medium\" | \"large\" = \"medium\";\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n\n    if (changedProps.has(\"size\")) {\n      switch (this.size) {\n        case \"tiny\":\n          this.style.setProperty(\"--md-circular-progress-size\", \"16px\");\n          break;\n        case \"small\":\n          this.style.setProperty(\"--md-circular-progress-size\", \"28px\");\n          break;\n        // medium is default size\n        case \"medium\":\n          this.style.setProperty(\"--md-circular-progress-size\", \"48px\");\n          break;\n        case \"large\":\n          this.style.setProperty(\"--md-circular-progress-size\", \"68px\");\n          break;\n      }\n    }\n  }\n\n  static override styles = [\n    ...super.styles,\n    css`\n      :host {\n        --md-sys-color-primary: var(--primary-color);\n        --md-circular-progress-size: 48px;\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-circular-progress\": HaCircularProgress;\n  }\n}\n","import \"@lrnwebcomponents/simple-tooltip/simple-tooltip\";\nimport { mdiDotsVertical } from \"@mdi/js\";\nimport type { TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { haStyle } from \"../resources/styles\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-button-menu\";\nimport \"./ha-icon-button\";\nimport \"./ha-list-item\";\nimport \"./ha-svg-icon\";\n\nexport interface IconOverflowMenuItem {\n  [key: string]: any;\n  path: string;\n  label: string;\n  narrowOnly?: boolean;\n  disabled?: boolean;\n  tooltip?: string;\n  action: () => any;\n  warning?: boolean;\n  divider?: boolean;\n}\n\n@customElement(\"ha-icon-overflow-menu\")\nexport class HaIconOverflowMenu extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Array }) public items: IconOverflowMenuItem[] = [];\n\n  @property({ type: Boolean }) public narrow = false;\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.narrow\n        ? html` <!-- Collapsed representation for small screens -->\n            <ha-button-menu\n              @click=${this._handleIconOverflowMenuOpened}\n              @closed=${this._handleIconOverflowMenuClosed}\n              class=\"ha-icon-overflow-menu-overflow\"\n              absolute\n            >\n              <ha-icon-button\n                .label=${this.hass.localize(\"ui.common.overflow_menu\")}\n                .path=${mdiDotsVertical}\n                slot=\"trigger\"\n              ></ha-icon-button>\n\n              ${this.items.map((item) =>\n                item.divider\n                  ? html`<li divider role=\"separator\"></li>`\n                  : html`<ha-list-item\n                      graphic=\"icon\"\n                      ?disabled=${item.disabled}\n                      @click=${item.action}\n                      class=${classMap({ warning: Boolean(item.warning) })}\n                    >\n                      <div slot=\"graphic\">\n                        <ha-svg-icon\n                          class=${classMap({ warning: Boolean(item.warning) })}\n                          .path=${item.path}\n                        ></ha-svg-icon>\n                      </div>\n                      ${item.label}\n                    </ha-list-item> `\n              )}\n            </ha-button-menu>`\n        : html`\n            <!-- Icon representation for big screens -->\n            ${this.items.map((item) =>\n              item.narrowOnly\n                ? \"\"\n                : item.divider\n                  ? html`<div role=\"separator\"></div>`\n                  : html`<div>\n                      ${item.tooltip\n                        ? html`<simple-tooltip\n                            animation-delay=\"0\"\n                            position=\"left\"\n                          >\n                            ${item.tooltip}\n                          </simple-tooltip>`\n                        : \"\"}\n                      <ha-icon-button\n                        @click=${item.action}\n                        .label=${item.label}\n                        .path=${item.path}\n                        ?disabled=${item.disabled}\n                      ></ha-icon-button>\n                    </div> `\n            )}\n          `}\n    `;\n  }\n\n  protected _handleIconOverflowMenuOpened(e) {\n    e.stopPropagation();\n    // If this component is used inside a data table, the z-index of the row\n    // needs to be increased. Otherwise the ha-button-menu would be displayed\n    // underneath the next row in the table.\n    const row = this.closest(\".mdc-data-table__row\") as HTMLDivElement | null;\n    if (row) {\n      row.style.zIndex = \"1\";\n    }\n  }\n\n  protected _handleIconOverflowMenuClosed() {\n    const row = this.closest(\".mdc-data-table__row\") as HTMLDivElement | null;\n    if (row) {\n      row.style.zIndex = \"\";\n    }\n  }\n\n  static get styles() {\n    return [\n      haStyle,\n      css`\n        :host {\n          display: flex;\n          justify-content: flex-end;\n        }\n        li[role=\"separator\"] {\n          border-bottom-color: var(--divider-color);\n        }\n        div[role=\"separator\"] {\n          border-right: 1px solid var(--divider-color);\n          width: 1px;\n        }\n        ha-list-item[disabled] ha-svg-icon {\n          color: var(--disabled-text-color);\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-icon-overflow-menu\": HaIconOverflowMenu;\n  }\n}\n","import { ListItemBase } from \"@material/mwc-list/mwc-list-item-base\";\nimport { styles } from \"@material/mwc-list/mwc-list-item.css\";\nimport type { CSSResultGroup } from \"lit\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-list-item\")\nexport class HaListItem extends ListItemBase {\n  protected renderRipple() {\n    if (this.noninteractive) {\n      return \"\";\n    }\n    return super.renderRipple();\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      styles,\n      css`\n        :host {\n          padding-left: var(\n            --mdc-list-side-padding-left,\n            var(--mdc-list-side-padding, 20px)\n          );\n          padding-inline-start: var(\n            --mdc-list-side-padding-left,\n            var(--mdc-list-side-padding, 20px)\n          );\n          padding-right: var(\n            --mdc-list-side-padding-right,\n            var(--mdc-list-side-padding, 20px)\n          );\n          padding-inline-end: var(\n            --mdc-list-side-padding-right,\n            var(--mdc-list-side-padding, 20px)\n          );\n        }\n        :host([graphic=\"avatar\"]:not([twoLine])),\n        :host([graphic=\"icon\"]:not([twoLine])) {\n          height: 48px;\n        }\n        span.material-icons:first-of-type {\n          margin-inline-start: 0px !important;\n          margin-inline-end: var(\n            --mdc-list-item-graphic-margin,\n            16px\n          ) !important;\n          direction: var(--direction) !important;\n        }\n        span.material-icons:last-of-type {\n          margin-inline-start: auto !important;\n          margin-inline-end: 0px !important;\n          direction: var(--direction) !important;\n        }\n        .mdc-deprecated-list-item__meta {\n          display: var(--mdc-list-item-meta-display);\n          align-items: center;\n          flex-shrink: 0;\n        }\n        :host([graphic=\"icon\"]:not([twoline]))\n          .mdc-deprecated-list-item__graphic {\n          margin-inline-end: var(\n            --mdc-list-item-graphic-margin,\n            20px\n          ) !important;\n        }\n        :host([multiline-secondary]) {\n          height: auto;\n        }\n        :host([multiline-secondary]) .mdc-deprecated-list-item__text {\n          padding: 8px 0;\n        }\n        :host([multiline-secondary]) .mdc-deprecated-list-item__secondary-text {\n          text-overflow: initial;\n          white-space: normal;\n          overflow: auto;\n          display: inline-block;\n          margin-top: 10px;\n        }\n        :host([multiline-secondary]) .mdc-deprecated-list-item__primary-text {\n          margin-top: 10px;\n        }\n        :host([multiline-secondary])\n          .mdc-deprecated-list-item__secondary-text::before {\n          display: none;\n        }\n        :host([multiline-secondary])\n          .mdc-deprecated-list-item__primary-text::before {\n          display: none;\n        }\n        :host([disabled]) {\n          color: var(--disabled-text-color);\n        }\n        :host([noninteractive]) {\n          pointer-events: unset;\n        }\n      `,\n      // safari workaround - must be explicit\n      document.dir === \"rtl\"\n        ? css`\n            span.material-icons:first-of-type,\n            span.material-icons:last-of-type {\n              direction: rtl !important;\n              --direction: rtl;\n            }\n          `\n        : css``,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-list-item\": HaListItem;\n  }\n}\n","import { TextFieldBase } from \"@material/mwc-textfield/mwc-textfield-base\";\nimport { styles } from \"@material/mwc-textfield/mwc-textfield.css\";\nimport type { TemplateResult, PropertyValues } from \"lit\";\nimport { html, css } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { mainWindow } from \"../common/dom/get_main_window\";\n\n@customElement(\"ha-textfield\")\nexport class HaTextField extends TextFieldBase {\n  @property({ type: Boolean }) public invalid?: boolean;\n\n  @property({ attribute: \"error-message\" }) public errorMessage?: string;\n\n  // @ts-ignore\n  @property({ type: Boolean }) public icon = false;\n\n  // @ts-ignore\n  @property({ type: Boolean }) public iconTrailing = false;\n\n  @property() public autocomplete?: string;\n\n  @property() public autocorrect?: string;\n\n  @property({ attribute: \"input-spellcheck\" })\n  public inputSpellcheck?: string;\n\n  @query(\"input\") public formElement!: HTMLInputElement;\n\n  override updated(changedProperties: PropertyValues) {\n    super.updated(changedProperties);\n    if (\n      changedProperties.has(\"invalid\") ||\n      changedProperties.has(\"errorMessage\")\n    ) {\n      this.setCustomValidity(\n        this.invalid\n          ? this.errorMessage || this.validationMessage || \"Invalid\"\n          : \"\"\n      );\n      if (\n        this.invalid ||\n        this.validateOnInitialRender ||\n        (changedProperties.has(\"invalid\") &&\n          changedProperties.get(\"invalid\") !== undefined)\n      ) {\n        // Only report validity if the field is invalid or the invalid state has changed from\n        // true to false to prevent setting empty required fields to invalid on first render\n        this.reportValidity();\n      }\n    }\n    if (changedProperties.has(\"autocomplete\")) {\n      if (this.autocomplete) {\n        this.formElement.setAttribute(\"autocomplete\", this.autocomplete);\n      } else {\n        this.formElement.removeAttribute(\"autocomplete\");\n      }\n    }\n    if (changedProperties.has(\"autocorrect\")) {\n      if (this.autocorrect) {\n        this.formElement.setAttribute(\"autocorrect\", this.autocorrect);\n      } else {\n        this.formElement.removeAttribute(\"autocorrect\");\n      }\n    }\n    if (changedProperties.has(\"inputSpellcheck\")) {\n      if (this.inputSpellcheck) {\n        this.formElement.setAttribute(\"spellcheck\", this.inputSpellcheck);\n      } else {\n        this.formElement.removeAttribute(\"spellcheck\");\n      }\n    }\n  }\n\n  protected override renderIcon(\n    _icon: string,\n    isTrailingIcon = false\n  ): TemplateResult {\n    const type = isTrailingIcon ? \"trailing\" : \"leading\";\n\n    return html`\n      <span\n        class=\"mdc-text-field__icon mdc-text-field__icon--${type}\"\n        tabindex=${isTrailingIcon ? 1 : -1}\n      >\n        <slot name=\"${type}Icon\"></slot>\n      </span>\n    `;\n  }\n\n  static override styles = [\n    styles,\n    css`\n      .mdc-text-field__input {\n        width: var(--ha-textfield-input-width, 100%);\n      }\n      .mdc-text-field:not(.mdc-text-field--with-leading-icon) {\n        padding: var(--text-field-padding, 0px 16px);\n      }\n      .mdc-text-field__affix--suffix {\n        padding-left: var(--text-field-suffix-padding-left, 12px);\n        padding-right: var(--text-field-suffix-padding-right, 0px);\n        padding-inline-start: var(--text-field-suffix-padding-left, 12px);\n        padding-inline-end: var(--text-field-suffix-padding-right, 0px);\n        direction: ltr;\n      }\n      .mdc-text-field--with-leading-icon {\n        padding-inline-start: var(--text-field-suffix-padding-left, 0px);\n        padding-inline-end: var(--text-field-suffix-padding-right, 16px);\n        direction: var(--direction);\n      }\n\n      .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon {\n        padding-left: var(--text-field-suffix-padding-left, 0px);\n        padding-right: var(--text-field-suffix-padding-right, 0px);\n        padding-inline-start: var(--text-field-suffix-padding-left, 0px);\n        padding-inline-end: var(--text-field-suffix-padding-right, 0px);\n      }\n      .mdc-text-field:not(.mdc-text-field--disabled)\n        .mdc-text-field__affix--suffix {\n        color: var(--secondary-text-color);\n      }\n\n      .mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon {\n        color: var(--secondary-text-color);\n      }\n\n      .mdc-text-field__icon--leading {\n        margin-inline-start: 16px;\n        margin-inline-end: 8px;\n        direction: var(--direction);\n      }\n\n      .mdc-text-field__icon--trailing {\n        padding: var(--textfield-icon-trailing-padding, 12px);\n      }\n\n      .mdc-floating-label:not(.mdc-floating-label--float-above) {\n        text-overflow: ellipsis;\n        width: inherit;\n        padding-right: 30px;\n        padding-inline-end: 30px;\n        padding-inline-start: initial;\n        box-sizing: border-box;\n        direction: var(--direction);\n      }\n\n      input {\n        text-align: var(--text-field-text-align, start);\n      }\n\n      /* Edge, hide reveal password icon */\n      ::-ms-reveal {\n        display: none;\n      }\n\n      /* Chrome, Safari, Edge, Opera */\n      :host([no-spinner]) input::-webkit-outer-spin-button,\n      :host([no-spinner]) input::-webkit-inner-spin-button {\n        -webkit-appearance: none;\n        margin: 0;\n      }\n\n      /* Firefox */\n      :host([no-spinner]) input[type=\"number\"] {\n        -moz-appearance: textfield;\n      }\n\n      .mdc-text-field__ripple {\n        overflow: hidden;\n      }\n\n      .mdc-text-field {\n        overflow: var(--text-field-overflow);\n      }\n\n      .mdc-floating-label {\n        inset-inline-start: 16px !important;\n        inset-inline-end: initial !important;\n        transform-origin: var(--float-start);\n        direction: var(--direction);\n        text-align: var(--float-start);\n      }\n\n      .mdc-text-field--with-leading-icon.mdc-text-field--filled\n        .mdc-floating-label {\n        max-width: calc(\n          100% - 48px - var(--text-field-suffix-padding-left, 0px)\n        );\n        inset-inline-start: calc(\n          48px + var(--text-field-suffix-padding-left, 0px)\n        ) !important;\n        inset-inline-end: initial !important;\n        direction: var(--direction);\n      }\n\n      .mdc-text-field__input[type=\"number\"] {\n        direction: var(--direction);\n      }\n      .mdc-text-field__affix--prefix {\n        padding-right: var(--text-field-prefix-padding-right, 2px);\n        padding-inline-end: var(--text-field-prefix-padding-right, 2px);\n        padding-inline-start: initial;\n      }\n\n      .mdc-text-field:not(.mdc-text-field--disabled)\n        .mdc-text-field__affix--prefix {\n        color: var(--mdc-text-field-label-ink-color);\n      }\n    `,\n    // safari workaround - must be explicit\n    mainWindow.document.dir === \"rtl\"\n      ? css`\n          .mdc-text-field--with-leading-icon,\n          .mdc-text-field__icon--leading,\n          .mdc-floating-label,\n          .mdc-text-field--with-leading-icon.mdc-text-field--filled\n            .mdc-floating-label,\n          .mdc-text-field__input[type=\"number\"] {\n            direction: rtl;\n            --direction: rtl;\n          }\n        `\n      : css``,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-textfield\": HaTextField;\n  }\n}\n","import type { CSSResultGroup, TemplateResult } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport \"../components/ha-circular-progress\";\nimport \"../components/ha-icon-button-arrow-prev\";\nimport \"../components/ha-menu-button\";\nimport { haStyle } from \"../resources/styles\";\nimport type { HomeAssistant } from \"../types\";\n\n@customElement(\"hass-loading-screen\")\nclass HassLoadingScreen extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ type: Boolean, attribute: \"no-toolbar\" })\n  public noToolbar = false;\n\n  @property({ type: Boolean }) public rootnav = false;\n\n  @property({ type: Boolean }) public narrow = false;\n\n  @property() public message?: string;\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.noToolbar\n        ? \"\"\n        : html`<div class=\"toolbar\">\n            ${this.rootnav || history.state?.root\n              ? html`\n                  <ha-menu-button\n                    .hass=${this.hass}\n                    .narrow=${this.narrow}\n                  ></ha-menu-button>\n                `\n              : html`\n                  <ha-icon-button-arrow-prev\n                    .hass=${this.hass}\n                    @click=${this._handleBack}\n                  ></ha-icon-button-arrow-prev>\n                `}\n          </div>`}\n      <div class=\"content\">\n        <ha-circular-progress indeterminate></ha-circular-progress>\n        ${this.message\n          ? html`<div id=\"loading-text\">${this.message}</div>`\n          : nothing}\n      </div>\n    `;\n  }\n\n  private _handleBack() {\n    history.back();\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        :host {\n          display: block;\n          height: 100%;\n          background-color: var(--primary-background-color);\n        }\n        .toolbar {\n          display: flex;\n          align-items: center;\n          font-size: 20px;\n          height: var(--header-height);\n          padding: 8px 12px;\n          pointer-events: none;\n          background-color: var(--app-header-background-color);\n          font-weight: 400;\n          color: var(--app-header-text-color, white);\n          border-bottom: var(--app-header-border-bottom, none);\n          box-sizing: border-box;\n        }\n        @media (max-width: 599px) {\n          .toolbar {\n            padding: 4px;\n          }\n        }\n        ha-menu-button,\n        ha-icon-button-arrow-prev {\n          pointer-events: auto;\n        }\n        .content {\n          height: calc(100% - var(--header-height));\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n        }\n        #loading-text {\n          max-width: 350px;\n          margin-top: 16px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hass-loading-screen\": HassLoadingScreen;\n  }\n}\n","import type { CSSResultGroup, TemplateResult } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\n\nimport { fireEvent } from \"@ha/common/dom/fire_event\";\n\nimport type { GroupRange, KNXProject } from \"../types/websocket\";\nimport { KNXLogger } from \"../tools/knx-logger\";\n\nconst logger = new KNXLogger(\"knx-project-tree-view\");\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"knx-group-range-selection-changed\": GroupRangeSelectionChangedEvent;\n  }\n}\n\nexport interface GroupRangeSelectionChangedEvent {\n  groupAddresses: string[];\n}\n\ninterface RangeInfo {\n  selected: boolean;\n  groupAddresses: string[];\n}\n\n@customElement(\"knx-project-tree-view\")\nexport class KNXProjectTreeView extends LitElement {\n  @property({ attribute: false }) data!: KNXProject;\n\n  @property({ attribute: false }) multiselect = false;\n\n  @state() private _selectableRanges: { [key: string]: RangeInfo } = {};\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    const initSelectableRanges = (data: { [key: string]: GroupRange }) => {\n      Object.entries(data).forEach(([key, groupRange]) => {\n        if (groupRange.group_addresses.length > 0) {\n          this._selectableRanges[key] = {\n            selected: false,\n            groupAddresses: groupRange.group_addresses,\n          };\n        }\n        initSelectableRanges(groupRange.group_ranges);\n      });\n    };\n    initSelectableRanges(this.data.group_ranges);\n    logger.debug(\"ranges\", this._selectableRanges);\n  }\n\n  protected render(): TemplateResult {\n    return html`<div class=\"ha-tree-view\">${this._recurseData(this.data.group_ranges)}</div>`;\n  }\n\n  protected _recurseData(data: { [key: string]: GroupRange }, level: number = 0): TemplateResult {\n    const childTemplates = Object.entries(data).map(([key, groupRange]) => {\n      const hasSubRange = Object.keys(groupRange.group_ranges).length > 0;\n      const empty = !(hasSubRange || groupRange.group_addresses.length > 0);\n      if (empty) {\n        return nothing;\n      }\n      const selectable = key in this._selectableRanges;\n      const selected = selectable ? this._selectableRanges[key].selected : false;\n      const rangeClasses = {\n        \"range-item\": true,\n        \"root-range\": level === 0,\n        \"sub-range\": level > 0,\n        selectable: selectable,\n        \"selected-range\": selected,\n        \"non-selected-range\": selectable && !selected,\n      };\n      const rangeContent = html`<div\n        class=${classMap(rangeClasses)}\n        toggle-range=${selectable ? key : nothing}\n        @click=${selectable\n          ? this.multiselect\n            ? this._selectionChangedMulti\n            : this._selectionChangedSingle\n          : nothing}\n      >\n        <span class=\"range-key\">${key}</span>\n        <span class=\"range-text\">${groupRange.name}</span>\n      </div>`;\n\n      if (hasSubRange) {\n        const groupClasses = {\n          \"root-group\": level === 0,\n          \"sub-group\": level !== 0,\n        };\n        return html`<div class=${classMap(groupClasses)}>\n          ${rangeContent} ${this._recurseData(groupRange.group_ranges, level + 1)}\n        </div>`;\n      }\n\n      return html`${rangeContent}`;\n    });\n    return html`${childTemplates}`;\n  }\n\n  private _selectionChangedMulti(ev) {\n    const rangeKey = (ev.target as Element).getAttribute(\"toggle-range\")!;\n    this._selectableRanges[rangeKey].selected = !this._selectableRanges[rangeKey].selected;\n    this._selectionUpdate();\n    this.requestUpdate();\n  }\n\n  private _selectionChangedSingle(ev) {\n    const rangeKey = (ev.target as Element).getAttribute(\"toggle-range\")!;\n    const rangePreviouslySelected = this._selectableRanges[rangeKey].selected;\n    Object.values(this._selectableRanges).forEach((rangeInfo) => {\n      rangeInfo.selected = false;\n    });\n    this._selectableRanges[rangeKey].selected = !rangePreviouslySelected;\n    this._selectionUpdate();\n    this.requestUpdate();\n  }\n\n  private _selectionUpdate() {\n    const _gaOfSelectedRanges = Object.values(this._selectableRanges).reduce(\n      (result, rangeInfo) =>\n        rangeInfo.selected ? result.concat(rangeInfo.groupAddresses) : result,\n      [] as string[],\n    );\n    logger.debug(\"selection changed\", _gaOfSelectedRanges);\n    fireEvent(this, \"knx-group-range-selection-changed\", { groupAddresses: _gaOfSelectedRanges });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        margin: 0;\n        height: 100%;\n        overflow-y: scroll;\n        overflow-x: hidden;\n        background-color: var(--card-background-color);\n      }\n\n      .ha-tree-view {\n        cursor: default;\n      }\n\n      .root-group {\n        margin-bottom: 8px;\n      }\n\n      .root-group > * {\n        padding-top: 5px;\n        padding-bottom: 5px;\n      }\n\n      .range-item {\n        display: block;\n        overflow: hidden;\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        font-size: 0.875rem;\n      }\n\n      .range-item > * {\n        vertical-align: middle;\n        pointer-events: none;\n      }\n\n      .range-key {\n        color: var(--text-primary-color);\n        font-size: 0.75rem;\n        font-weight: 700;\n        background-color: var(--label-badge-grey);\n        border-radius: 4px;\n        padding: 1px 4px;\n        margin-right: 2px;\n      }\n\n      .root-range {\n        padding-left: 8px;\n        font-weight: 500;\n        background-color: var(--secondary-background-color);\n\n        & .range-key {\n          color: var(--primary-text-color);\n          background-color: var(--card-background-color);\n        }\n      }\n\n      .sub-range {\n        padding-left: 13px;\n      }\n\n      .selectable {\n        cursor: pointer;\n      }\n\n      .selectable:hover {\n        background-color: rgba(var(--rgb-primary-text-color), 0.04);\n      }\n\n      .selected-range {\n        background-color: rgba(var(--rgb-primary-color), 0.12);\n\n        & .range-key {\n          background-color: var(--primary-color);\n        }\n      }\n\n      .selected-range:hover {\n        background-color: rgba(var(--rgb-primary-color), 0.07);\n      }\n\n      .non-selected-range {\n        background-color: var(--card-background-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"knx-project-tree-view\": KNXProjectTreeView;\n  }\n}\n","import { mdiFilterVariant } from \"@mdi/js\";\nimport type { TemplateResult } from \"lit\";\nimport { LitElement, html, css, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\n\nimport memoize from \"memoize-one\";\n\nimport type { HASSDomEvent } from \"@ha/common/dom/fire_event\";\nimport \"@ha/layouts/hass-loading-screen\";\nimport \"@ha/layouts/hass-tabs-subpage\";\nimport type { PageNavigation } from \"@ha/layouts/hass-tabs-subpage\";\nimport \"@ha/components/ha-card\";\nimport \"@ha/components/ha-icon-button\";\nimport \"@ha/components/ha-icon-overflow-menu\";\nimport \"@ha/components/data-table/ha-data-table\";\nimport type { DataTableColumnContainer } from \"@ha/components/data-table/ha-data-table\";\nimport { relativeTime } from \"@ha/common/datetime/relative_time\";\nimport { navigate } from \"@ha/common/navigate\";\n\nimport \"../components/knx-project-tree-view\";\n\nimport { compare } from \"compare-versions\";\n\nimport type { HomeAssistant, Route } from \"@ha/types\";\nimport type { KNX } from \"../types/knx\";\nimport type { GroupRangeSelectionChangedEvent } from \"../components/knx-project-tree-view\";\nimport { subscribeKnxTelegrams, getGroupTelegrams } from \"../services/websocket.service\";\nimport type { GroupAddress, TelegramDict } from \"../types/websocket\";\nimport { KNXLogger } from \"../tools/knx-logger\";\nimport { TelegramDictFormatter } from \"../utils/format\";\n\nconst logger = new KNXLogger(\"knx-project-view\");\n// Minimum XKNXProject Version needed which was used for parsing the ETS Project\nconst MIN_XKNXPROJECT_VERSION = \"3.3.0\";\n\n@customElement(\"knx-project-view\")\nexport class KNXProjectView extends LitElement {\n  @property({ type: Object }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public knx!: KNX;\n\n  @property({ type: Boolean, reflect: true }) public narrow!: boolean;\n\n  @property({ type: Object }) public route?: Route;\n\n  @property({ type: Array, reflect: false }) public tabs!: PageNavigation[];\n\n  @property({ type: Boolean, reflect: true, attribute: \"range-selector-hidden\" })\n  public rangeSelectorHidden = true;\n\n  @state() private _visibleGroupAddresses: string[] = [];\n\n  @state() private _groupRangeAvailable: boolean = false;\n\n  @state() private _subscribed?: () => void;\n\n  @state() private _lastTelegrams: { [ga: string]: TelegramDict } = {};\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this._subscribed) {\n      this._subscribed();\n      this._subscribed = undefined;\n    }\n  }\n\n  protected async firstUpdated() {\n    if (!this.knx.project) {\n      this.knx.loadProject().then(() => {\n        this._isGroupRangeAvailable();\n        this.requestUpdate();\n      });\n    } else {\n      // project was already loaded\n      this._isGroupRangeAvailable();\n    }\n\n    getGroupTelegrams(this.hass)\n      .then((groupTelegrams) => {\n        this._lastTelegrams = groupTelegrams;\n      })\n      .catch((err) => {\n        logger.error(\"getGroupTelegrams\", err);\n        navigate(\"/knx/error\", { replace: true, data: err });\n      });\n    this._subscribed = await subscribeKnxTelegrams(this.hass, (telegram) => {\n      this.telegram_callback(telegram);\n    });\n  }\n\n  private _isGroupRangeAvailable() {\n    const projectVersion = this.knx.project?.knxproject.info.xknxproject_version ?? \"0.0.0\";\n    logger.debug(\"project version: \" + projectVersion);\n    this._groupRangeAvailable = compare(projectVersion, MIN_XKNXPROJECT_VERSION, \">=\");\n  }\n\n  protected telegram_callback(telegram: TelegramDict): void {\n    this._lastTelegrams = {\n      ...this._lastTelegrams,\n      [telegram.destination]: telegram,\n    };\n  }\n\n  private _columns = memoize((_narrow, _language): DataTableColumnContainer<GroupAddress> => {\n    const addressWidth = \"100px\";\n    const dptWidth = \"82px\";\n\n    return {\n      address: {\n        filterable: true,\n        sortable: true,\n        title: this.knx.localize(\"project_view_table_address\"),\n        flex: 1,\n        minWidth: addressWidth,\n      },\n      name: {\n        filterable: true,\n        sortable: true,\n        title: this.knx.localize(\"project_view_table_name\"),\n        flex: 3,\n      },\n      dpt: {\n        sortable: true,\n        filterable: true,\n        title: this.knx.localize(\"project_view_table_dpt\"),\n        flex: 1,\n        minWidth: dptWidth,\n        template: (ga: GroupAddress) =>\n          ga.dpt\n            ? html`<span style=\"display:inline-block;width:24px;text-align:right;\"\n                  >${ga.dpt.main}</span\n                >${ga.dpt.sub ? \".\" + ga.dpt.sub.toString().padStart(3, \"0\") : \"\"} `\n            : \"\",\n      },\n      lastValue: {\n        filterable: true,\n        title: this.knx.localize(\"project_view_table_last_value\"),\n        flex: 2,\n        template: (ga: GroupAddress) => {\n          const lastTelegram: TelegramDict | undefined = this._lastTelegrams[ga.address];\n          if (!lastTelegram) return \"\";\n          const payload = TelegramDictFormatter.payload(lastTelegram);\n          if (lastTelegram.value == null) return html`<code>${payload}</code>`;\n          return html`<div title=${payload}>\n            ${TelegramDictFormatter.valueWithUnit(this._lastTelegrams[ga.address])}\n          </div>`;\n        },\n      },\n      updated: {\n        title: this.knx.localize(\"project_view_table_updated\"),\n        flex: 1,\n        showNarrow: false,\n        template: (ga: GroupAddress) => {\n          const lastTelegram: TelegramDict | undefined = this._lastTelegrams[ga.address];\n          if (!lastTelegram) return \"\";\n          const tooltip = `${TelegramDictFormatter.dateWithMilliseconds(lastTelegram)}\\n\\n${lastTelegram.source} ${lastTelegram.source_name}`;\n          return html`<div title=${tooltip}>\n            ${relativeTime(new Date(lastTelegram.timestamp), this.hass.locale)}\n          </div>`;\n        },\n      },\n    };\n  });\n\n  private _getRows(visibleGroupAddresses: string[]): GroupAddress[] {\n    if (!visibleGroupAddresses.length)\n      // if none is set, default to show all\n      return Object.values(this.knx.project!.knxproject.group_addresses);\n\n    return Object.entries(this.knx.project!.knxproject.group_addresses).reduce(\n      (result, [key, groupAddress]) => {\n        if (visibleGroupAddresses.includes(key)) {\n          result.push(groupAddress);\n        }\n        return result;\n      },\n      [] as GroupAddress[],\n    );\n  }\n\n  private _visibleAddressesChanged(ev: HASSDomEvent<GroupRangeSelectionChangedEvent>) {\n    this._visibleGroupAddresses = ev.detail.groupAddresses;\n  }\n\n  protected render(): TemplateResult | void {\n    if (!this.hass || !this.knx.project) {\n      return html` <hass-loading-screen></hass-loading-screen> `;\n    }\n\n    const filtered = this._getRows(this._visibleGroupAddresses);\n\n    return html`\n      <hass-tabs-subpage\n        .hass=${this.hass}\n        .narrow=${this.narrow!}\n        .route=${this.route!}\n        .tabs=${this.tabs}\n        .localizeFunc=${this.knx.localize}\n      >\n        ${this.knx.project.project_loaded\n          ? html`${this.narrow && this._groupRangeAvailable\n                ? html`<ha-icon-button\n                    slot=\"toolbar-icon\"\n                    .label=${this.hass.localize(\"ui.components.related-filter-menu.filter\")}\n                    .path=${mdiFilterVariant}\n                    @click=${this._toggleRangeSelector}\n                  ></ha-icon-button>`\n                : nothing}\n              <div class=\"sections\">\n                ${this._groupRangeAvailable\n                  ? html`\n                      <knx-project-tree-view\n                        .data=${this.knx.project.knxproject}\n                        @knx-group-range-selection-changed=${this._visibleAddressesChanged}\n                      ></knx-project-tree-view>\n                    `\n                  : nothing}\n                <ha-data-table\n                  class=\"ga-table\"\n                  .hass=${this.hass}\n                  .columns=${this._columns(this.narrow, this.hass.language)}\n                  .data=${filtered}\n                  .hasFab=${false}\n                  .searchLabel=${this.hass.localize(\"ui.components.data-table.search\")}\n                  .clickable=${false}\n                ></ha-data-table>\n              </div>`\n          : html` <ha-card .header=${this.knx.localize(\"attention\")}>\n              <div class=\"card-content\">\n                <p>${this.knx.localize(\"project_view_upload\")}</p>\n              </div>\n            </ha-card>`}\n      </hass-tabs-subpage>\n    `;\n  }\n\n  private _toggleRangeSelector() {\n    this.rangeSelectorHidden = !this.rangeSelectorHidden;\n  }\n\n  static get styles() {\n    return css`\n      hass-loading-screen {\n        --app-header-background-color: var(--sidebar-background-color);\n        --app-header-text-color: var(--sidebar-text-color);\n      }\n      .sections {\n        display: flex;\n        flex-direction: row;\n        height: 100%;\n      }\n\n      :host([narrow]) knx-project-tree-view {\n        position: absolute;\n        max-width: calc(100% - 60px); /* 100% -> max 871px before not narrow */\n        z-index: 1;\n        right: 0;\n        transition: 0.5s;\n        border-left: 1px solid var(--divider-color);\n      }\n\n      :host([narrow][range-selector-hidden]) knx-project-tree-view {\n        width: 0;\n      }\n\n      :host(:not([narrow])) knx-project-tree-view {\n        max-width: 255px; /* min 616px - 816px for tree-view + ga-table (depending on side menu) */\n      }\n\n      .ga-table {\n        flex: 1;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"knx-project-view\": KNXProjectView;\n  }\n}\n"],"names":[],"sourceRoot":""}