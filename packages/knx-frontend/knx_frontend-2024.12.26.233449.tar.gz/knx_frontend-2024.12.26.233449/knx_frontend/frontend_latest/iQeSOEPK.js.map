{"version":3,"file":"iQeSOEPK.js","mappings":";;;;;;;;;;;;;;;;;;;;AA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0DA;;AC/DA;AACA;AACA;;AAGA;;;;ACdA;;;;;;;;;;;;ACQA;;;;ACRA;;ACiCA;;AAGA;;ACdA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AAUA;;AAGA;AACA;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;AAqCA;AClDA;AAGA;;;AASA;;;;AAKA;;;;AAUA;;ACiPA;AACA;;;AAIA;;AAqCA;AACA;;AAGA;;;;AAsHA;AACA;AACA;;;;;AAKA;;AAMA;;AAGA;AACA;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;AAWA;AACA;;AAKA;;;;AAQA;AACA;;AAEA;;AAIA;;;;;;AASA;;;AAIA;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAKA;AACA;AAEA;;AAIA;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-dialog-header.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-icon-button-prev.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-md-divider.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-md-list-item.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-md-list.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-service-icon.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/search-input.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-domain-icon.ts","webpack://knx-frontend/./homeassistant-frontend/src/panels/config/automation/add-automation-element-dialog.ts"],"sourcesContent":["import { css, html, LitElement } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-dialog-header\")\nexport class HaDialogHeader extends LitElement {\n  protected render() {\n    return html`\n      <header class=\"header\">\n        <div class=\"header-bar\">\n          <section class=\"header-navigation-icon\">\n            <slot name=\"navigationIcon\"></slot>\n          </section>\n          <section class=\"header-content\">\n            <div class=\"header-title\">\n              <slot name=\"title\"></slot>\n            </div>\n            <div class=\"header-subtitle\">\n              <slot name=\"subtitle\"></slot>\n            </div>\n          </section>\n          <section class=\"header-action-items\">\n            <slot name=\"actionItems\"></slot>\n          </section>\n        </div>\n        <slot></slot>\n      </header>\n    `;\n  }\n\n  static get styles() {\n    return [\n      css`\n        :host {\n          display: block;\n        }\n        :host([show-border]) {\n          border-bottom: 1px solid\n            var(--mdc-dialog-scroll-divider-color, rgba(0, 0, 0, 0.12));\n        }\n        .header-bar {\n          display: flex;\n          flex-direction: row;\n          align-items: flex-start;\n          padding: 4px;\n          box-sizing: border-box;\n        }\n        .header-content {\n          flex: 1;\n          padding: 10px 4px;\n          min-width: 0;\n          overflow: hidden;\n          text-overflow: ellipsis;\n          white-space: nowrap;\n        }\n        .header-title {\n          font-size: 22px;\n          line-height: 28px;\n          font-weight: 400;\n        }\n        .header-subtitle {\n          font-size: 14px;\n          line-height: 20px;\n          color: var(--secondary-text-color);\n        }\n        @media all and (min-width: 450px) and (min-height: 500px) {\n          .header-bar {\n            padding: 12px;\n          }\n        }\n        .header-navigation-icon {\n          flex: none;\n          min-width: 8px;\n          height: 100%;\n          display: flex;\n          flex-direction: row;\n        }\n        .header-action-items {\n          flex: none;\n          min-width: 8px;\n          height: 100%;\n          display: flex;\n          flex-direction: row;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-dialog-header\": HaDialogHeader;\n  }\n}\n","import { mdiChevronLeft, mdiChevronRight } from \"@mdi/js\";\nimport type { TemplateResult } from \"lit\";\nimport { html, LitElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { mainWindow } from \"../common/dom/get_main_window\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-icon-button\";\n\n@customElement(\"ha-icon-button-prev\")\nexport class HaIconButtonPrev extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property() public label?: string;\n\n  @state() private _icon =\n    mainWindow.document.dir === \"rtl\" ? mdiChevronRight : mdiChevronLeft;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-icon-button\n        .disabled=${this.disabled}\n        .label=${this.label || this.hass?.localize(\"ui.common.back\") || \"Back\"}\n        .path=${this._icon}\n      ></ha-icon-button>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-icon-button-prev\": HaIconButtonPrev;\n  }\n}\n","import { MdDivider } from \"@material/web/divider/divider\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-md-divider\")\nexport class HaMdDivider extends MdDivider {\n  static override styles = [\n    ...super.styles,\n    css`\n      :host {\n        --md-divider-color: var(--divider-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-md-divider\": HaMdDivider;\n  }\n}\n","import { MdListItem } from \"@material/web/list/list-item\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-md-list-item\")\nexport class HaMdListItem extends MdListItem {\n  static override styles = [\n    ...super.styles,\n    css`\n      :host {\n        --ha-icon-display: block;\n        --md-sys-color-primary: var(--primary-text-color);\n        --md-sys-color-secondary: var(--secondary-text-color);\n        --md-sys-color-surface: var(--card-background-color);\n        --md-sys-color-on-surface: var(--primary-text-color);\n        --md-sys-color-on-surface-variant: var(--secondary-text-color);\n      }\n      md-item {\n        overflow: var(--md-item-overflow, hidden);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-md-list-item\": HaMdListItem;\n  }\n}\n","import { MdList } from \"@material/web/list/list\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\n\n@customElement(\"ha-md-list\")\nexport class HaMdList extends MdList {\n  static override styles = [\n    ...super.styles,\n    css`\n      :host {\n        --md-sys-color-surface: var(--card-background-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-md-list\": HaMdList;\n  }\n}\n","import { html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { until } from \"lit/directives/until\";\nimport { DEFAULT_SERVICE_ICON, FIXED_DOMAIN_ICONS } from \"../common/const\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport { serviceIcon } from \"../data/icons\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-icon\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-service-icon\")\nexport class HaServiceIcon extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public service?: string;\n\n  @property() public icon?: string;\n\n  protected render() {\n    if (this.icon) {\n      return html`<ha-icon .icon=${this.icon}></ha-icon>`;\n    }\n\n    if (!this.service) {\n      return nothing;\n    }\n\n    if (!this.hass) {\n      return this._renderFallback();\n    }\n\n    const icon = serviceIcon(this.hass, this.service).then((icn) => {\n      if (icn) {\n        return html`<ha-icon .icon=${icn}></ha-icon>`;\n      }\n      return this._renderFallback();\n    });\n\n    return html`${until(icon)}`;\n  }\n\n  private _renderFallback() {\n    const domain = computeDomain(this.service!);\n\n    return html`\n      <ha-svg-icon\n        .path=${FIXED_DOMAIN_ICONS[domain] || DEFAULT_SERVICE_ICON}\n      ></ha-svg-icon>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-service-icon\": HaServiceIcon;\n  }\n}\n","import { mdiClose, mdiMagnify } from \"@mdi/js\";\nimport type { CSSResultGroup, TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport \"./ha-icon-button\";\nimport \"./ha-svg-icon\";\nimport \"./ha-textfield\";\nimport type { HaTextField } from \"./ha-textfield\";\nimport type { HomeAssistant } from \"../types\";\nimport { fireEvent } from \"../common/dom/fire_event\";\n\n@customElement(\"search-input\")\nclass SearchInput extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public filter?: string;\n\n  @property({ type: Boolean })\n  public suffix = false;\n\n  @property({ type: Boolean })\n  public autofocus = false;\n\n  @property({ type: String })\n  public label?: string;\n\n  public focus() {\n    this._input?.focus();\n  }\n\n  @query(\"ha-textfield\", true) private _input!: HaTextField;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-textfield\n        .autofocus=${this.autofocus}\n        .label=${this.label || this.hass.localize(\"ui.common.search\")}\n        .value=${this.filter || \"\"}\n        icon\n        .iconTrailing=${this.filter || this.suffix}\n        @input=${this._filterInputChanged}\n      >\n        <slot name=\"prefix\" slot=\"leadingIcon\">\n          <ha-svg-icon\n            tabindex=\"-1\"\n            class=\"prefix\"\n            .path=${mdiMagnify}\n          ></ha-svg-icon>\n        </slot>\n        <div class=\"trailing\" slot=\"trailingIcon\">\n          ${this.filter &&\n          html`\n            <ha-icon-button\n              @click=${this._clearSearch}\n              .label=${this.hass.localize(\"ui.common.clear\")}\n              .path=${mdiClose}\n              class=\"clear-button\"\n            ></ha-icon-button>\n          `}\n          <slot name=\"suffix\"></slot>\n        </div>\n      </ha-textfield>\n    `;\n  }\n\n  private async _filterChanged(value: string) {\n    fireEvent(this, \"value-changed\", { value: String(value) });\n  }\n\n  private async _filterInputChanged(e) {\n    this._filterChanged(e.target.value);\n  }\n\n  private async _clearSearch() {\n    this._filterChanged(\"\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-flex;\n      }\n      ha-svg-icon,\n      ha-icon-button {\n        color: var(--primary-text-color);\n      }\n      ha-svg-icon {\n        outline: none;\n      }\n      .clear-button {\n        --mdc-icon-size: 20px;\n      }\n      ha-textfield {\n        display: inherit;\n      }\n      .trailing {\n        display: flex;\n        align-items: center;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"search-input\": SearchInput;\n  }\n}\n","import type { CSSResultGroup } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { until } from \"lit/directives/until\";\nimport { DEFAULT_DOMAIN_ICON, FIXED_DOMAIN_ICONS } from \"../common/const\";\nimport { domainIcon } from \"../data/icons\";\nimport type { HomeAssistant } from \"../types\";\nimport { brandsUrl } from \"../util/brands-url\";\nimport \"./ha-icon\";\n\n@customElement(\"ha-domain-icon\")\nexport class HaDomainIcon extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public domain?: string;\n\n  @property() public deviceClass?: string;\n\n  @property() public icon?: string;\n\n  @property({ type: Boolean }) public brandFallback?: boolean;\n\n  protected render() {\n    if (this.icon) {\n      return html`<ha-icon .icon=${this.icon}></ha-icon>`;\n    }\n\n    if (!this.domain) {\n      return nothing;\n    }\n\n    if (!this.hass) {\n      return this._renderFallback();\n    }\n\n    const icon = domainIcon(this.hass, this.domain, this.deviceClass).then(\n      (icn) => {\n        if (icn) {\n          return html`<ha-icon .icon=${icn}></ha-icon>`;\n        }\n        return this._renderFallback();\n      }\n    );\n\n    return html`${until(icon)}`;\n  }\n\n  private _renderFallback() {\n    if (this.domain! in FIXED_DOMAIN_ICONS) {\n      return html`\n        <ha-svg-icon .path=${FIXED_DOMAIN_ICONS[this.domain!]}></ha-svg-icon>\n      `;\n    }\n    if (this.brandFallback) {\n      const image = brandsUrl({\n        domain: this.domain!,\n        type: \"icon\",\n        darkOptimized: this.hass.themes?.darkMode,\n      });\n      return html`\n        <img\n          alt=\"\"\n          src=${image}\n          crossorigin=\"anonymous\"\n          referrerpolicy=\"no-referrer\"\n        />\n      `;\n    }\n    return html`<ha-svg-icon .path=${DEFAULT_DOMAIN_ICON}></ha-svg-icon>`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      img {\n        width: var(--mdc-icon-size, 24px);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-domain-icon\": HaDomainIcon;\n  }\n}\n","import { mdiClose, mdiContentPaste, mdiPlus } from \"@mdi/js\";\nimport type { IFuseOptions } from \"fuse.js\";\nimport Fuse from \"fuse.js\";\nimport type { CSSResultGroup, PropertyValues, TemplateResult } from \"lit\";\nimport { LitElement, css, html, nothing } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { repeat } from \"lit/directives/repeat\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../../common/dom/fire_event\";\nimport { computeDomain } from \"../../../common/entity/compute_domain\";\nimport { stringCompare } from \"../../../common/string/compare\";\nimport { stripDiacritics } from \"../../../common/string/strip-diacritics\";\nimport type { LocalizeFunc } from \"../../../common/translations/localize\";\nimport { deepEqual } from \"../../../common/util/deep-equal\";\nimport \"../../../components/ha-dialog\";\nimport type { HaDialog } from \"../../../components/ha-dialog\";\nimport \"../../../components/ha-dialog-header\";\nimport \"../../../components/ha-md-divider\";\nimport \"../../../components/ha-domain-icon\";\nimport \"../../../components/ha-icon-button\";\nimport \"../../../components/ha-icon-button-prev\";\nimport \"../../../components/ha-icon-next\";\nimport \"../../../components/ha-md-list\";\nimport \"../../../components/ha-md-list-item\";\nimport \"../../../components/ha-service-icon\";\nimport \"../../../components/search-input\";\nimport {\n  ACTION_GROUPS,\n  ACTION_ICONS,\n  SERVICE_PREFIX,\n  getService,\n  isService,\n} from \"../../../data/action\";\nimport type { AutomationElementGroup } from \"../../../data/automation\";\nimport { CONDITION_GROUPS, CONDITION_ICONS } from \"../../../data/condition\";\nimport { getServiceIcons } from \"../../../data/icons\";\nimport type { IntegrationManifest } from \"../../../data/integration\";\nimport {\n  domainToName,\n  fetchIntegrationManifests,\n} from \"../../../data/integration\";\nimport { TRIGGER_GROUPS, TRIGGER_ICONS } from \"../../../data/trigger\";\nimport type { HassDialog } from \"../../../dialogs/make-dialog-manager\";\nimport { haStyle, haStyleDialog } from \"../../../resources/styles\";\nimport type { HomeAssistant } from \"../../../types\";\nimport { getStripDiacriticsFn } from \"../../../util/fuse\";\nimport type { AddAutomationElementDialogParams } from \"./show-add-automation-element-dialog\";\nimport { PASTE_VALUE } from \"./show-add-automation-element-dialog\";\n\nconst TYPES = {\n  trigger: { groups: TRIGGER_GROUPS, icons: TRIGGER_ICONS },\n  condition: {\n    groups: CONDITION_GROUPS,\n    icons: CONDITION_ICONS,\n  },\n  action: {\n    groups: ACTION_GROUPS,\n    icons: ACTION_ICONS,\n  },\n};\n\ninterface ListItem {\n  key: string;\n  name: string;\n  description: string;\n  iconPath?: string;\n  icon?: TemplateResult;\n  group: boolean;\n}\n\ninterface DomainManifestLookup {\n  [domain: string]: IntegrationManifest;\n}\n\nconst ENTITY_DOMAINS_OTHER = new Set([\n  \"date\",\n  \"datetime\",\n  \"device_tracker\",\n  \"text\",\n  \"time\",\n  \"tts\",\n  \"update\",\n  \"weather\",\n  \"image_processing\",\n]);\n\nconst ENTITY_DOMAINS_MAIN = new Set([\"notify\"]);\n\n@customElement(\"add-automation-element-dialog\")\nclass DialogAddAutomationElement extends LitElement implements HassDialog {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _params?: AddAutomationElementDialogParams;\n\n  @state() private _group?: string;\n\n  @state() private _prev?: string;\n\n  @state() private _filter = \"\";\n\n  @state() private _manifests?: DomainManifestLookup;\n\n  @state() private _domains?: Set<string>;\n\n  @query(\"ha-dialog\") private _dialog?: HaDialog;\n\n  private _fullScreen = false;\n\n  @state() private _width?: number;\n\n  @state() private _height?: number;\n\n  public showDialog(params): void {\n    this._params = params;\n    this._group = params.group;\n    if (this._params?.type === \"action\") {\n      this.hass.loadBackendTranslation(\"services\");\n      this._fetchManifests();\n      this._calculateUsedDomains();\n      getServiceIcons(this.hass);\n    }\n    this._fullScreen = matchMedia(\n      \"all and (max-width: 450px), all and (max-height: 500px)\"\n    ).matches;\n  }\n\n  public closeDialog(): void {\n    if (this._params) {\n      fireEvent(this, \"dialog-closed\", { dialog: this.localName });\n    }\n    this._height = undefined;\n    this._width = undefined;\n    this._params = undefined;\n    this._group = undefined;\n    this._prev = undefined;\n    this._filter = \"\";\n    this._manifests = undefined;\n    this._domains = undefined;\n  }\n\n  private _getGroups = (\n    type: AddAutomationElementDialogParams[\"type\"],\n    group: string | undefined\n  ): AutomationElementGroup =>\n    group\n      ? isService(group)\n        ? {}\n        : TYPES[type].groups[group].members!\n      : TYPES[type].groups;\n\n  private _convertToItem = (\n    key: string,\n    options,\n    type: AddAutomationElementDialogParams[\"type\"],\n    localize: LocalizeFunc\n  ): ListItem => ({\n    group: Boolean(options.members),\n    key,\n    name: localize(\n      // @ts-ignore\n      `ui.panel.config.automation.editor.${type}s.${\n        options.members ? \"groups\" : \"type\"\n      }.${key}.label`\n    ),\n    description: localize(\n      // @ts-ignore\n      `ui.panel.config.automation.editor.${type}s.${\n        options.members ? \"groups\" : \"type\"\n      }.${key}.description${options.members ? \"\" : \".picker\"}`\n    ),\n    iconPath: options.icon || TYPES[type].icons[key],\n  });\n\n  private _getFilteredItems = memoizeOne(\n    (\n      type: AddAutomationElementDialogParams[\"type\"],\n      group: string | undefined,\n      filter: string,\n      localize: LocalizeFunc,\n      services: HomeAssistant[\"services\"],\n      manifests?: DomainManifestLookup\n    ): ListItem[] => {\n      const groups = this._getGroups(type, group);\n\n      const flattenGroups = (grp: AutomationElementGroup) =>\n        Object.entries(grp).map(([key, options]) =>\n          options.members\n            ? flattenGroups(options.members)\n            : this._convertToItem(key, options, type, localize)\n        );\n\n      const items = flattenGroups(groups).flat();\n\n      if (type === \"action\") {\n        items.push(...this._services(localize, services, manifests, group));\n      }\n\n      const options: IFuseOptions<ListItem> = {\n        keys: [\"key\", \"name\", \"description\"],\n        isCaseSensitive: false,\n        ignoreLocation: true,\n        minMatchCharLength: Math.min(filter.length, 2),\n        threshold: 0.2,\n        getFn: getStripDiacriticsFn,\n      };\n      const fuse = new Fuse(items, options);\n      return fuse.search(stripDiacritics(filter)).map((result) => result.item);\n    }\n  );\n\n  private _getGroupItems = memoizeOne(\n    (\n      type: AddAutomationElementDialogParams[\"type\"],\n      group: string | undefined,\n      domains: Set<string> | undefined,\n      localize: LocalizeFunc,\n      services: HomeAssistant[\"services\"],\n      manifests?: DomainManifestLookup\n    ): ListItem[] => {\n      if (type === \"action\" && isService(group)) {\n        let result = this._services(localize, services, manifests, group);\n        if (group === `${SERVICE_PREFIX}media_player`) {\n          result = [\n            this._convertToItem(\"play_media\", {}, type, localize),\n            ...result,\n          ];\n        }\n        return result;\n      }\n\n      const groups = this._getGroups(type, group);\n\n      const result = Object.entries(groups).map(([key, options]) =>\n        this._convertToItem(key, options, type, localize)\n      );\n\n      if (type === \"action\") {\n        if (!this._group) {\n          result.unshift(\n            ...this._serviceGroups(\n              localize,\n              services,\n              manifests,\n              domains,\n              undefined\n            )\n          );\n        } else if (this._group === \"helpers\") {\n          result.unshift(\n            ...this._serviceGroups(\n              localize,\n              services,\n              manifests,\n              domains,\n              \"helper\"\n            )\n          );\n        } else if (this._group === \"other\") {\n          result.unshift(\n            ...this._serviceGroups(\n              localize,\n              services,\n              manifests,\n              domains,\n              \"other\"\n            )\n          );\n        }\n      }\n\n      return result.sort((a, b) => {\n        if (a.group && b.group) {\n          return 0;\n        }\n        if (a.group && !b.group) {\n          return 1;\n        }\n        if (!a.group && b.group) {\n          return -1;\n        }\n        return stringCompare(a.name, b.name, this.hass.locale.language);\n      });\n    }\n  );\n\n  private _serviceGroups = (\n    localize: LocalizeFunc,\n    services: HomeAssistant[\"services\"],\n    manifests: DomainManifestLookup | undefined,\n    domains: Set<string> | undefined,\n    type: \"helper\" | \"other\" | undefined\n  ): ListItem[] => {\n    if (!services || !manifests) {\n      return [];\n    }\n    const result: ListItem[] = [];\n    Object.keys(services).forEach((domain) => {\n      const manifest = manifests[domain];\n      const domainUsed = !domains ? true : domains.has(domain);\n      if (\n        (type === undefined &&\n          (ENTITY_DOMAINS_MAIN.has(domain) ||\n            (manifest?.integration_type === \"entity\" &&\n              domainUsed &&\n              !ENTITY_DOMAINS_OTHER.has(domain)))) ||\n        (type === \"helper\" && manifest?.integration_type === \"helper\") ||\n        (type === \"other\" &&\n          !ENTITY_DOMAINS_MAIN.has(domain) &&\n          (ENTITY_DOMAINS_OTHER.has(domain) ||\n            (!domainUsed && manifest?.integration_type === \"entity\") ||\n            ![\"helper\", \"entity\"].includes(manifest?.integration_type || \"\")))\n      ) {\n        result.push({\n          group: true,\n          icon: html`\n            <ha-domain-icon\n              .hass=${this.hass}\n              .domain=${domain}\n              brandFallback\n            ></ha-domain-icon>\n          `,\n          key: `${SERVICE_PREFIX}${domain}`,\n          name: domainToName(localize, domain, manifest),\n          description: \"\",\n        });\n      }\n    });\n    return result.sort((a, b) =>\n      stringCompare(a.name, b.name, this.hass.locale.language)\n    );\n  };\n\n  private _services = memoizeOne(\n    (\n      localize: LocalizeFunc,\n      services: HomeAssistant[\"services\"],\n      manifests: DomainManifestLookup | undefined,\n      group?: string\n    ): ListItem[] => {\n      if (!services) {\n        return [];\n      }\n      const result: ListItem[] = [];\n\n      let domain: string | undefined;\n\n      if (isService(group)) {\n        domain = getService(group!);\n      }\n\n      const addDomain = (dmn: string) => {\n        const services_keys = Object.keys(services[dmn]);\n\n        for (const service of services_keys) {\n          result.push({\n            group: false,\n            icon: html`\n              <ha-service-icon\n                .hass=${this.hass}\n                .service=${`${dmn}.${service}`}\n              ></ha-service-icon>\n            `,\n            key: `${SERVICE_PREFIX}${dmn}.${service}`,\n            name: `${domain ? \"\" : `${domainToName(localize, dmn)}: `}${\n              this.hass.localize(`component.${dmn}.services.${service}.name`) ||\n              services[dmn][service]?.name ||\n              service\n            }`,\n            description:\n              this.hass.localize(\n                `component.${dmn}.services.${service}.description`\n              ) || services[dmn][service]?.description,\n          });\n        }\n      };\n\n      if (domain) {\n        addDomain(domain);\n        return result.sort((a, b) =>\n          stringCompare(a.name, b.name, this.hass.locale.language)\n        );\n      }\n\n      if (group && ![\"helpers\", \"other\"].includes(group)) {\n        return [];\n      }\n\n      Object.keys(services)\n        .sort()\n        .forEach((dmn) => {\n          const manifest = manifests?.[dmn];\n          if (group === \"helpers\" && manifest?.integration_type !== \"helper\") {\n            return;\n          }\n          if (\n            group === \"other\" &&\n            (ENTITY_DOMAINS_OTHER.has(dmn) ||\n              [\"helper\", \"entity\"].includes(manifest?.integration_type || \"\"))\n          ) {\n            return;\n          }\n          addDomain(dmn);\n        });\n\n      return result;\n    }\n  );\n\n  private async _fetchManifests() {\n    const manifests = {};\n    const fetched = await fetchIntegrationManifests(this.hass);\n    for (const manifest of fetched) {\n      manifests[manifest.domain] = manifest;\n    }\n    this._manifests = manifests;\n  }\n\n  private _calculateUsedDomains() {\n    const domains = new Set(Object.keys(this.hass.states).map(computeDomain));\n    if (!deepEqual(domains, this._domains)) {\n      this._domains = domains;\n    }\n  }\n\n  protected _opened(): void {\n    // Store the width and height so that when we search, box doesn't jump\n    const boundingRect =\n      this.shadowRoot!.querySelector(\"ha-md-list\")?.getBoundingClientRect();\n    this._width = boundingRect?.width;\n    this._height = boundingRect?.height;\n  }\n\n  protected willUpdate(changedProperties: PropertyValues): void {\n    if (\n      this._params?.type === \"action\" &&\n      changedProperties.has(\"hass\") &&\n      changedProperties.get(\"hass\")?.states !== this.hass.states\n    ) {\n      this._calculateUsedDomains();\n    }\n  }\n\n  protected render() {\n    if (!this._params) {\n      return nothing;\n    }\n\n    const items = this._filter\n      ? this._getFilteredItems(\n          this._params.type,\n          this._group,\n          this._filter,\n          this.hass.localize,\n          this.hass.services,\n          this._manifests\n        )\n      : this._getGroupItems(\n          this._params.type,\n          this._group,\n          this._domains,\n          this.hass.localize,\n          this.hass.services,\n          this._manifests\n        );\n\n    const groupName = isService(this._group)\n      ? domainToName(\n          this.hass.localize,\n          getService(this._group!),\n          this._manifests?.[getService(this._group!)]\n        )\n      : this.hass.localize(\n          // @ts-ignore\n          `ui.panel.config.automation.editor.${this._params.type}s.groups.${this._group}.label`\n        );\n\n    return html`\n      <ha-dialog\n        open\n        hideActions\n        @opened=${this._opened}\n        @closed=${this.closeDialog}\n        .heading=${true}\n      >\n        <div slot=\"heading\">\n          <ha-dialog-header>\n            <span slot=\"title\"\n              >${this._group\n                ? groupName\n                : this.hass.localize(\n                    `ui.panel.config.automation.editor.${this._params.type}s.add`\n                  )}</span\n            >\n            ${this._group && this._group !== this._params.group\n              ? html`<ha-icon-button-prev\n                  slot=\"navigationIcon\"\n                  @click=${this._back}\n                ></ha-icon-button-prev>`\n              : html`<ha-icon-button\n                  .path=${mdiClose}\n                  slot=\"navigationIcon\"\n                  dialogAction=\"cancel\"\n                ></ha-icon-button>`}\n          </ha-dialog-header>\n          <search-input\n            dialogInitialFocus=${ifDefined(this._fullScreen ? undefined : \"\")}\n            .hass=${this.hass}\n            .filter=${this._filter}\n            @value-changed=${this._filterChanged}\n            .label=${groupName\n              ? this.hass.localize(\n                  \"ui.panel.config.automation.editor.search_in\",\n                  { group: groupName }\n                )\n              : this.hass.localize(\n                  `ui.panel.config.automation.editor.${this._params.type}s.search`\n                )}\n          ></search-input>\n        </div>\n        <ha-md-list\n          dialogInitialFocus=${ifDefined(this._fullScreen ? \"\" : undefined)}\n          style=${styleMap({\n            width: this._width ? `${this._width}px` : \"auto\",\n            height: this._height ? `${Math.min(468, this._height)}px` : \"auto\",\n          })}\n        >\n          ${this._params.clipboardItem &&\n          !this._filter &&\n          (!this._group ||\n            items.find((item) => item.key === this._params!.clipboardItem))\n            ? html`<ha-md-list-item\n                  interactive\n                  type=\"button\"\n                  class=\"paste\"\n                  .value=${PASTE_VALUE}\n                  @click=${this._selected}\n                >\n                  ${this.hass.localize(\n                    `ui.panel.config.automation.editor.${this._params.type}s.paste`\n                  )}\n                  <span slot=\"supporting-text\"\n                    >${this.hass.localize(\n                      // @ts-ignore\n                      `ui.panel.config.automation.editor.${this._params.type}s.type.${this._params.clipboardItem}.label`\n                    )}</span\n                  >\n                  <ha-svg-icon\n                    slot=\"start\"\n                    .path=${mdiContentPaste}\n                  ></ha-svg-icon\n                  ><ha-svg-icon slot=\"end\" .path=${mdiPlus}></ha-svg-icon>\n                </ha-md-list-item>\n                <ha-md-divider role=\"separator\" tabindex=\"-1\"></ha-md-divider>`\n            : \"\"}\n          ${repeat(\n            items,\n            (item) => item.key,\n            (item) => html`\n              <ha-md-list-item\n                interactive\n                type=\"button\"\n                .value=${item.key}\n                .group=${item.group}\n                @click=${this._selected}\n              >\n                <div slot=\"headline\">${item.name}</div>\n                <div slot=\"supporting-text\">${item.description}</div>\n                ${item.icon\n                  ? html`<span slot=\"start\">${item.icon}</span>`\n                  : item.iconPath\n                    ? html`<ha-svg-icon\n                        slot=\"start\"\n                        .path=${item.iconPath}\n                      ></ha-svg-icon>`\n                    : nothing}\n                ${item.group\n                  ? html`<ha-icon-next slot=\"end\"></ha-icon-next>`\n                  : html`<ha-svg-icon\n                      slot=\"end\"\n                      .path=${mdiPlus}\n                    ></ha-svg-icon>`}\n              </ha-md-list-item>\n            `\n          )}\n        </ha-md-list>\n      </ha-dialog>\n    `;\n  }\n\n  private _back() {\n    this._dialog!.scrollToPos(0, 0);\n    if (this._filter) {\n      this._filter = \"\";\n      return;\n    }\n    if (this._prev) {\n      this._group = this._prev;\n      this._prev = undefined;\n      return;\n    }\n    this._group = undefined;\n  }\n\n  private _selected(ev) {\n    this._dialog!.scrollToPos(0, 0);\n    const item = ev.currentTarget;\n    if (item.group) {\n      this._prev = this._group;\n      this._group = item.value;\n      return;\n    }\n    this._params!.add(item.value);\n    this.closeDialog();\n  }\n\n  private _filterChanged(ev) {\n    this._filter = ev.detail.value;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      haStyleDialog,\n      css`\n        ha-dialog {\n          --dialog-content-padding: 0;\n          --mdc-dialog-max-height: 60vh;\n        }\n        @media all and (min-width: 550px) {\n          ha-dialog {\n            --mdc-dialog-min-width: 500px;\n          }\n        }\n        ha-icon-next {\n          width: 24px;\n        }\n        ha-md-list {\n          max-height: 468px;\n          max-width: 100vw;\n          --md-list-item-leading-space: 24px;\n          --md-list-item-trailing-space: 24px;\n        }\n        ha-md-list-item img {\n          width: 24px;\n        }\n        search-input {\n          display: block;\n          margin: 0 16px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"add-automation-element-dialog\": DialogAddAutomationElement;\n  }\n}\n"],"names":[],"sourceRoot":""}