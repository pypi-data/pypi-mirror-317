{"version":3,"file":"PgXmL3Dg.js","mappings":";;AA6CA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AAEA;AACA;;AAIA;AAEA;AACA;;AAMA;AAGA;AACA;;;AAKA;;;;AAkBA;;;;ACwPA;AClUA;AACA;AACA;AACA;;AAIA;;AA8CA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIA;;;;;;;;;;;;AAuHA;;;;ACnMA;AACA;AACA;;AAGA;;;;;AASA;;;ACuGA;AACA;AACA;AACA;AACA;;;;;AAKA;AAGA;;AAMA;AAEA;AACA;;;;AAOA;AAEA;AACA;;AAGA;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AAEA;;AAGA;AAGA;AACA;AACA;;AAEA;AAEA;;AAIA;AACA;AACA;;AAEA;;AAEA;AAEA;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyIA;;AC5UA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AC8DA;;AAIA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;AAGA;AAEA;AACA;;AAIA;;;AAIA;AAGA;;;;;;;;;;;;;AAwDA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-assist-pipeline-picker.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-code-editor.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-navigation-picker.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-help-tooltip.ts","webpack://knx-frontend/./homeassistant-frontend/src/panels/lovelace/components/hui-action-editor.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-selector/ha-selector-ui-action.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-yaml-editor.ts"],"sourcesContent":["import type { CSSResultGroup, PropertyValueMap } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { stopPropagation } from \"../common/dom/stop_propagation\";\nimport { formatLanguageCode } from \"../common/language/format_language\";\nimport type { AssistPipeline } from \"../data/assist_pipeline\";\nimport { listAssistPipelines } from \"../data/assist_pipeline\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-list-item\";\nimport \"./ha-select\";\nimport type { HaSelect } from \"./ha-select\";\n\nconst PREFERRED = \"preferred\";\nconst LAST_USED = \"last_used\";\n\n@customElement(\"ha-assist-pipeline-picker\")\nexport class HaAssistPipelinePicker extends LitElement {\n  @property() public value?: string;\n\n  @property() public label?: string;\n\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true }) public disabled = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @property({ type: Boolean }) public includeLastUsed = false;\n\n  @state() _pipelines?: AssistPipeline[];\n\n  @state() _preferredPipeline: string | null = null;\n\n  private get _default() {\n    return this.includeLastUsed ? LAST_USED : PREFERRED;\n  }\n\n  protected render() {\n    if (!this._pipelines) {\n      return nothing;\n    }\n    const value = this.value ?? this._default;\n    return html`\n      <ha-select\n        .label=${this.label ||\n        this.hass!.localize(\"ui.components.pipeline-picker.pipeline\")}\n        .value=${value}\n        .required=${this.required}\n        .disabled=${this.disabled}\n        @selected=${this._changed}\n        @closed=${stopPropagation}\n        fixedMenuPosition\n        naturalMenuWidth\n      >\n        ${this.includeLastUsed\n          ? html`\n              <ha-list-item .value=${LAST_USED}>\n                ${this.hass!.localize(\n                  \"ui.components.pipeline-picker.last_used\"\n                )}\n              </ha-list-item>\n            `\n          : null}\n        <ha-list-item .value=${PREFERRED}>\n          ${this.hass!.localize(\"ui.components.pipeline-picker.preferred\", {\n            preferred: this._pipelines.find(\n              (pipeline) => pipeline.id === this._preferredPipeline\n            )?.name,\n          })}\n        </ha-list-item>\n        ${this._pipelines.map(\n          (pipeline) =>\n            html`<ha-list-item .value=${pipeline.id}>\n              ${pipeline.name}\n              (${formatLanguageCode(pipeline.language, this.hass.locale)})\n            </ha-list-item>`\n        )}\n      </ha-select>\n    `;\n  }\n\n  protected firstUpdated(\n    changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>\n  ): void {\n    super.firstUpdated(changedProperties);\n    listAssistPipelines(this.hass).then((pipelines) => {\n      this._pipelines = pipelines.pipelines;\n      this._preferredPipeline = pipelines.preferred_pipeline;\n    });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-select {\n        width: 100%;\n      }\n    `;\n  }\n\n  private _changed(ev): void {\n    const target = ev.target as HaSelect;\n    if (\n      !this.hass ||\n      target.value === \"\" ||\n      target.value === this.value ||\n      (this.value === undefined && target.value === this._default)\n    ) {\n      return;\n    }\n    this.value = target.value === this._default ? undefined : target.value;\n    fireEvent(this, \"value-changed\", { value: this.value });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-assist-pipeline-picker\": HaAssistPipelinePicker;\n  }\n}\n","import type {\n  Completion,\n  CompletionContext,\n  CompletionResult,\n  CompletionSource,\n} from \"@codemirror/autocomplete\";\nimport type { Extension, TransactionSpec } from \"@codemirror/state\";\nimport type { EditorView, KeyBinding, ViewUpdate } from \"@codemirror/view\";\nimport type { HassEntities } from \"home-assistant-js-websocket\";\nimport type { CSSResultGroup, PropertyValues } from \"lit\";\nimport { css, ReactiveElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { stopPropagation } from \"../common/dom/stop_propagation\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-icon\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"editor-save\": undefined;\n  }\n}\n\nconst saveKeyBinding: KeyBinding = {\n  key: \"Mod-s\",\n  run: (view: EditorView) => {\n    fireEvent(view.dom, \"editor-save\");\n    return true;\n  },\n};\n\nconst renderIcon = (completion: Completion) => {\n  const icon = document.createElement(\"ha-icon\");\n  icon.icon = completion.label;\n  return icon;\n};\n\n@customElement(\"ha-code-editor\")\nexport class HaCodeEditor extends ReactiveElement {\n  public codemirror?: EditorView;\n\n  @property() public mode = \"yaml\";\n\n  public hass?: HomeAssistant;\n\n  @property({ type: Boolean }) public autofocus = false;\n\n  @property({ type: Boolean }) public readOnly = false;\n\n  @property({ type: Boolean }) public linewrap = false;\n\n  @property({ type: Boolean, attribute: \"autocomplete-entities\" })\n  public autocompleteEntities = false;\n\n  @property({ type: Boolean, attribute: \"autocomplete-icons\" })\n  public autocompleteIcons = false;\n\n  @property({ type: Boolean }) public error = false;\n\n  @state() private _value = \"\";\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-imports\n  private _loadedCodeMirror?: typeof import(\"../resources/codemirror\");\n\n  private _iconList?: Completion[];\n\n  public set value(value: string) {\n    this._value = value;\n  }\n\n  public get value(): string {\n    return this.codemirror ? this.codemirror.state.doc.toString() : this._value;\n  }\n\n  public get hasComments(): boolean {\n    if (!this.codemirror || !this._loadedCodeMirror) {\n      return false;\n    }\n    const className = this._loadedCodeMirror.highlightingFor(\n      this.codemirror.state,\n      [this._loadedCodeMirror.tags.comment]\n    );\n    return !!this.renderRoot.querySelector(`span.${className}`);\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    // Force update on reconnection so editor is recreated\n    if (this.hasUpdated) {\n      this.requestUpdate();\n    }\n    this.addEventListener(\"keydown\", stopPropagation);\n    // This is unreachable as editor will not exist yet,\n    // but focus should not behave like this for good a11y.\n    // (@steverep to fix in autofocus PR)\n    if (!this.codemirror) {\n      return;\n    }\n    if (this.autofocus !== false) {\n      this.codemirror.focus();\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeEventListener(\"keydown\", stopPropagation);\n    this.updateComplete.then(() => {\n      this.codemirror!.destroy();\n      delete this.codemirror;\n    });\n  }\n\n  // Ensure CodeMirror module is loaded before any update\n  protected override async scheduleUpdate() {\n    this._loadedCodeMirror ??= await import(\"../resources/codemirror\");\n    super.scheduleUpdate();\n  }\n\n  protected update(changedProps: PropertyValues): void {\n    super.update(changedProps);\n    if (!this.codemirror) {\n      this._createCodeMirror();\n      return;\n    }\n    const transactions: TransactionSpec[] = [];\n    if (changedProps.has(\"mode\")) {\n      transactions.push({\n        effects: [\n          this._loadedCodeMirror!.langCompartment!.reconfigure(this._mode),\n          this._loadedCodeMirror!.foldingCompartment.reconfigure(\n            this._getFoldingExtensions()\n          ),\n        ],\n      });\n    }\n    if (changedProps.has(\"readOnly\")) {\n      transactions.push({\n        effects: this._loadedCodeMirror!.readonlyCompartment!.reconfigure(\n          this._loadedCodeMirror!.EditorView!.editable.of(!this.readOnly)\n        ),\n      });\n    }\n    if (changedProps.has(\"linewrap\")) {\n      transactions.push({\n        effects: this._loadedCodeMirror!.linewrapCompartment!.reconfigure(\n          this.linewrap ? this._loadedCodeMirror!.EditorView.lineWrapping : []\n        ),\n      });\n    }\n    if (changedProps.has(\"_value\") && this._value !== this.value) {\n      transactions.push({\n        changes: {\n          from: 0,\n          to: this.codemirror.state.doc.length,\n          insert: this._value,\n        },\n      });\n    }\n    if (transactions.length > 0) {\n      this.codemirror.dispatch(...transactions);\n    }\n    if (changedProps.has(\"error\")) {\n      this.classList.toggle(\"error-state\", this.error);\n    }\n  }\n\n  private get _mode() {\n    return this._loadedCodeMirror!.langs[this.mode];\n  }\n\n  private _createCodeMirror() {\n    if (!this._loadedCodeMirror) {\n      throw new Error(\"Cannot create editor before CodeMirror is loaded\");\n    }\n    const extensions: Extension[] = [\n      this._loadedCodeMirror.lineNumbers(),\n      this._loadedCodeMirror.history(),\n      this._loadedCodeMirror.drawSelection(),\n      this._loadedCodeMirror.EditorState.allowMultipleSelections.of(true),\n      this._loadedCodeMirror.rectangularSelection(),\n      this._loadedCodeMirror.crosshairCursor(),\n      this._loadedCodeMirror.highlightSelectionMatches(),\n      this._loadedCodeMirror.highlightActiveLine(),\n      this._loadedCodeMirror.indentationMarkers({\n        thickness: 0,\n        activeThickness: 1,\n        colors: {\n          activeLight: \"var(--secondary-text-color)\",\n          activeDark: \"var(--secondary-text-color)\",\n        },\n      }),\n      this._loadedCodeMirror.keymap.of([\n        ...this._loadedCodeMirror.defaultKeymap,\n        ...this._loadedCodeMirror.searchKeymap,\n        ...this._loadedCodeMirror.historyKeymap,\n        ...this._loadedCodeMirror.tabKeyBindings,\n        saveKeyBinding,\n      ]),\n      this._loadedCodeMirror.langCompartment.of(this._mode),\n      this._loadedCodeMirror.haTheme,\n      this._loadedCodeMirror.haSyntaxHighlighting,\n      this._loadedCodeMirror.readonlyCompartment.of(\n        this._loadedCodeMirror.EditorView.editable.of(!this.readOnly)\n      ),\n      this._loadedCodeMirror.linewrapCompartment.of(\n        this.linewrap ? this._loadedCodeMirror.EditorView.lineWrapping : []\n      ),\n      this._loadedCodeMirror.EditorView.updateListener.of(this._onUpdate),\n      this._loadedCodeMirror.foldingCompartment.of(\n        this._getFoldingExtensions()\n      ),\n    ];\n\n    if (!this.readOnly) {\n      const completionSources: CompletionSource[] = [];\n      if (this.autocompleteEntities && this.hass) {\n        completionSources.push(this._entityCompletions.bind(this));\n      }\n      if (this.autocompleteIcons) {\n        completionSources.push(this._mdiCompletions.bind(this));\n      }\n      if (completionSources.length > 0) {\n        extensions.push(\n          this._loadedCodeMirror.autocompletion({\n            override: completionSources,\n            maxRenderedOptions: 10,\n          })\n        );\n      }\n    }\n\n    this.codemirror = new this._loadedCodeMirror.EditorView({\n      state: this._loadedCodeMirror.EditorState.create({\n        doc: this._value,\n        extensions,\n      }),\n      parent: this.renderRoot,\n    });\n  }\n\n  private _getStates = memoizeOne((states: HassEntities): Completion[] => {\n    if (!states) {\n      return [];\n    }\n    const options = Object.keys(states).map((key) => ({\n      type: \"variable\",\n      label: key,\n      detail: states[key].attributes.friendly_name,\n      info: `State: ${states[key].state}`,\n    }));\n\n    return options;\n  });\n\n  private _entityCompletions(\n    context: CompletionContext\n  ): CompletionResult | null | Promise<CompletionResult | null> {\n    const entityWord = context.matchBefore(/[a-z_]{3,}\\.\\w*/);\n\n    if (\n      !entityWord ||\n      (entityWord.from === entityWord.to && !context.explicit)\n    ) {\n      return null;\n    }\n\n    const states = this._getStates(this.hass!.states);\n\n    if (!states || !states.length) {\n      return null;\n    }\n\n    return {\n      from: Number(entityWord.from),\n      options: states,\n      validFor: /^[a-z_]{3,}\\.\\w*$/,\n    };\n  }\n\n  private _getIconItems = async (): Promise<Completion[]> => {\n    if (!this._iconList) {\n      let iconList: {\n        name: string;\n        keywords: string[];\n      }[];\n      if (__SUPERVISOR__) {\n        iconList = [];\n      } else {\n        iconList = (await import(\"../../build/mdi/iconList.json\")).default;\n      }\n\n      this._iconList = iconList.map((icon) => ({\n        type: \"variable\",\n        label: `mdi:${icon.name}`,\n        detail: icon.keywords.join(\", \"),\n        info: renderIcon,\n      }));\n    }\n\n    return this._iconList;\n  };\n\n  private async _mdiCompletions(\n    context: CompletionContext\n  ): Promise<CompletionResult | null> {\n    const match = context.matchBefore(/mdi:\\S*/);\n\n    if (!match || (match.from === match.to && !context.explicit)) {\n      return null;\n    }\n\n    const iconItems = await this._getIconItems();\n\n    return {\n      from: Number(match.from),\n      options: iconItems,\n      validFor: /^mdi:\\S*$/,\n    };\n  }\n\n  private _onUpdate = (update: ViewUpdate): void => {\n    if (!update.docChanged) {\n      return;\n    }\n    this._value = update.state.doc.toString();\n    fireEvent(this, \"value-changed\", { value: this._value });\n  };\n\n  private _getFoldingExtensions = (): Extension => {\n    if (this.mode === \"yaml\") {\n      return [\n        this._loadedCodeMirror!.foldGutter(),\n        this._loadedCodeMirror!.foldingOnIndent,\n      ];\n    }\n\n    return [];\n  };\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host(.error-state) .cm-gutters {\n        border-color: var(--error-state-color, red);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-code-editor\": HaCodeEditor;\n  }\n}\n","import \"@material/mwc-list/mwc-list-item\";\nimport type { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport type { PropertyValues, TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { titleCase } from \"../common/string/title-case\";\nimport { fetchConfig } from \"../data/lovelace/config/types\";\nimport type { LovelaceViewRawConfig } from \"../data/lovelace/config/view\";\nimport type { HomeAssistant, PanelInfo, ValueChangedEvent } from \"../types\";\nimport \"./ha-combo-box\";\nimport type { HaComboBox } from \"./ha-combo-box\";\nimport \"./ha-icon\";\n\ntype NavigationItem = {\n  path: string;\n  icon: string;\n  title: string;\n};\n\nconst DEFAULT_ITEMS: NavigationItem[] = [];\n\n// eslint-disable-next-line lit/prefer-static-styles\nconst rowRenderer: ComboBoxLitRenderer<NavigationItem> = (item) => html`\n  <mwc-list-item graphic=\"icon\" .twoline=${!!item.title}>\n    <ha-icon .icon=${item.icon} slot=\"graphic\"></ha-icon>\n    <span>${item.title || item.path}</span>\n    <span slot=\"secondary\">${item.path}</span>\n  </mwc-list-item>\n`;\n\nconst createViewNavigationItem = (\n  prefix: string,\n  view: LovelaceViewRawConfig,\n  index: number\n) => ({\n  path: `/${prefix}/${view.path ?? index}`,\n  icon: view.icon ?? \"mdi:view-compact\",\n  title: view.title ?? (view.path ? titleCase(view.path) : `${index}`),\n});\n\nconst createPanelNavigationItem = (hass: HomeAssistant, panel: PanelInfo) => ({\n  path: `/${panel.url_path}`,\n  icon: panel.icon ?? \"mdi:view-dashboard\",\n  title:\n    panel.url_path === hass.defaultPanel\n      ? hass.localize(\"panel.states\")\n      : hass.localize(`panel.${panel.title}`) ||\n        panel.title ||\n        (panel.url_path ? titleCase(panel.url_path) : \"\"),\n});\n\n@customElement(\"ha-navigation-picker\")\nexport class HaNavigationPicker extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @state() private _opened = false;\n\n  private navigationItemsLoaded = false;\n\n  private navigationItems: NavigationItem[] = DEFAULT_ITEMS;\n\n  @query(\"ha-combo-box\", true) private comboBox!: HaComboBox;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        item-value-path=\"path\"\n        item-label-path=\"path\"\n        .value=${this._value}\n        allow-custom-value\n        .filteredItems=${this.navigationItems}\n        .label=${this.label}\n        .helper=${this.helper}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        .renderer=${rowRenderer}\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._valueChanged}\n        @filter-changed=${this._filterChanged}\n      >\n      </ha-combo-box>\n    `;\n  }\n\n  private async _openedChanged(ev: ValueChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n    if (this._opened && !this.navigationItemsLoaded) {\n      this._loadNavigationItems();\n    }\n  }\n\n  private async _loadNavigationItems() {\n    this.navigationItemsLoaded = true;\n\n    const panels = Object.entries(this.hass!.panels).map(([id, panel]) => ({\n      id,\n      ...panel,\n    }));\n    const lovelacePanels = panels.filter(\n      (panel) => panel.component_name === \"lovelace\"\n    );\n\n    const viewConfigs = await Promise.all(\n      lovelacePanels.map((panel) =>\n        fetchConfig(\n          this.hass!.connection,\n          // path should be null to fetch default lovelace panel\n          panel.url_path === \"lovelace\" ? null : panel.url_path,\n          true\n        )\n          .then((config) => [panel.id, config] as [string, typeof config])\n          .catch((_) => [panel.id, undefined] as [string, undefined])\n      )\n    );\n\n    const panelViewConfig = new Map(viewConfigs);\n\n    this.navigationItems = [];\n\n    for (const panel of panels) {\n      this.navigationItems.push(createPanelNavigationItem(this.hass!, panel));\n\n      const config = panelViewConfig.get(panel.id);\n\n      if (!config || !(\"views\" in config)) continue;\n\n      config.views.forEach((view, index) =>\n        this.navigationItems.push(\n          createViewNavigationItem(panel.url_path, view, index)\n        )\n      );\n    }\n\n    this.comboBox.filteredItems = this.navigationItems;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues) {\n    return !this._opened || changedProps.has(\"_opened\");\n  }\n\n  private _valueChanged(ev: ValueChangedEvent<string>) {\n    ev.stopPropagation();\n    this._setValue(ev.detail.value);\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    fireEvent(\n      this,\n      \"value-changed\",\n      { value: this._value },\n      {\n        bubbles: false,\n        composed: false,\n      }\n    );\n  }\n\n  private _filterChanged(ev: CustomEvent): void {\n    const filterString = ev.detail.value.toLowerCase();\n    const characterCount = filterString.length;\n    if (characterCount >= 2) {\n      const filteredItems: NavigationItem[] = [];\n\n      this.navigationItems.forEach((item) => {\n        if (\n          item.path.toLowerCase().includes(filterString) ||\n          item.title.toLowerCase().includes(filterString)\n        ) {\n          filteredItems.push(item);\n        }\n      });\n\n      if (filteredItems.length > 0) {\n        this.comboBox.filteredItems = filteredItems;\n      } else {\n        this.comboBox.filteredItems = [];\n      }\n    } else {\n      this.comboBox.filteredItems = this.navigationItems;\n    }\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  static get styles() {\n    return css`\n      ha-icon,\n      ha-svg-icon {\n        color: var(--primary-text-color);\n        position: relative;\n        bottom: 0px;\n      }\n      *[slot=\"prefix\"] {\n        margin-right: 8px;\n        margin-inline-end: 8px;\n        margin-inline-start: initial;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-navigation-picker\": HaNavigationPicker;\n  }\n}\n","import { mdiHelpCircle } from \"@mdi/js\";\nimport \"@lrnwebcomponents/simple-tooltip/simple-tooltip\";\nimport type { TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-help-tooltip\")\nexport class HaHelpTooltip extends LitElement {\n  @property() public label!: string;\n\n  @property() public position = \"top\";\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-svg-icon .path=${mdiHelpCircle}></ha-svg-icon>\n      <simple-tooltip\n        offset=\"4\"\n        .position=${this.position}\n        .fitToVisibleBounds=${true}\n        >${this.label}</simple-tooltip\n      >\n    `;\n  }\n\n  static get styles() {\n    return css`\n      ha-svg-icon {\n        --mdc-icon-size: var(--ha-help-tooltip-size, 14px);\n        color: var(--ha-help-tooltip-color, var(--disabled-text-color));\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-help-tooltip\": HaHelpTooltip;\n  }\n}\n","import type { CSSResultGroup, PropertyValues } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../../common/dom/fire_event\";\nimport { stopPropagation } from \"../../../common/dom/stop_propagation\";\nimport \"../../../components/ha-assist-pipeline-picker\";\nimport type {\n  HaFormSchema,\n  SchemaUnion,\n} from \"../../../components/ha-form/types\";\nimport \"../../../components/ha-help-tooltip\";\nimport \"../../../components/ha-navigation-picker\";\nimport \"../../../components/ha-service-control\";\nimport type {\n  ActionConfig,\n  CallServiceActionConfig,\n  NavigateActionConfig,\n  UrlActionConfig,\n} from \"../../../data/lovelace/config/action\";\nimport type { ServiceAction } from \"../../../data/script\";\nimport type { HomeAssistant } from \"../../../types\";\nimport type { EditorTarget } from \"../editor/types\";\nimport type { HaSelect } from \"../../../components/ha-select\";\n\nexport type UiAction = Exclude<ActionConfig[\"action\"], \"fire-dom-event\">;\n\nconst DEFAULT_ACTIONS: UiAction[] = [\n  \"more-info\",\n  \"toggle\",\n  \"navigate\",\n  \"url\",\n  \"perform-action\",\n  \"assist\",\n  \"none\",\n];\n\nconst NAVIGATE_SCHEMA = [\n  {\n    name: \"navigation_path\",\n    selector: {\n      navigation: {},\n    },\n  },\n] as const satisfies readonly HaFormSchema[];\n\nconst ASSIST_SCHEMA = [\n  {\n    type: \"grid\",\n    name: \"\",\n    schema: [\n      {\n        name: \"pipeline_id\",\n        selector: {\n          assist_pipeline: {\n            include_last_used: true,\n          },\n        },\n      },\n      {\n        name: \"start_listening\",\n        selector: {\n          boolean: {},\n        },\n      },\n    ],\n  },\n] as const satisfies readonly HaFormSchema[];\n\n@customElement(\"hui-action-editor\")\nexport class HuiActionEditor extends LitElement {\n  @property({ attribute: false }) public config?: ActionConfig;\n\n  @property() public label?: string;\n\n  @property({ attribute: false }) public actions?: UiAction[];\n\n  @property({ attribute: false }) public defaultAction?: UiAction;\n\n  @property() public tooltipText?: string;\n\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @query(\"ha-select\") private _select!: HaSelect;\n\n  get _navigation_path(): string {\n    const config = this.config as NavigateActionConfig | undefined;\n    return config?.navigation_path || \"\";\n  }\n\n  get _url_path(): string {\n    const config = this.config as UrlActionConfig | undefined;\n    return config?.url_path || \"\";\n  }\n\n  get _service(): string {\n    const config = this.config as CallServiceActionConfig;\n    return config?.perform_action || config?.service || \"\";\n  }\n\n  private _serviceAction = memoizeOne(\n    (config: CallServiceActionConfig): ServiceAction => ({\n      action: this._service,\n      ...(config.data || config.service_data\n        ? { data: config.data ?? config.service_data }\n        : null),\n      target: config.target,\n    })\n  );\n\n  protected updated(changedProperties: PropertyValues<typeof this>) {\n    super.updated(changedProperties);\n    if (changedProperties.has(\"defaultAction\")) {\n      if (changedProperties.get(\"defaultAction\") !== this.defaultAction) {\n        this._select.layoutOptions();\n      }\n    }\n  }\n\n  protected render() {\n    if (!this.hass) {\n      return nothing;\n    }\n\n    const actions = this.actions ?? DEFAULT_ACTIONS;\n\n    let action = this.config?.action || \"default\";\n\n    if (action === \"call-service\") {\n      action = \"perform-action\";\n    }\n\n    return html`\n      <div class=\"dropdown\">\n        <ha-select\n          .label=${this.label}\n          .configValue=${\"action\"}\n          @selected=${this._actionPicked}\n          .value=${action}\n          @closed=${stopPropagation}\n          fixedMenuPosition\n          naturalMenuWidt\n        >\n          <mwc-list-item value=\"default\">\n            ${this.hass!.localize(\n              \"ui.panel.lovelace.editor.action-editor.actions.default_action\"\n            )}\n            ${this.defaultAction\n              ? ` (${this.hass!.localize(\n                  `ui.panel.lovelace.editor.action-editor.actions.${this.defaultAction}`\n                ).toLowerCase()})`\n              : nothing}\n          </mwc-list-item>\n          ${actions.map(\n            (actn) => html`\n              <mwc-list-item .value=${actn}>\n                ${this.hass!.localize(\n                  `ui.panel.lovelace.editor.action-editor.actions.${actn}`\n                )}\n              </mwc-list-item>\n            `\n          )}\n        </ha-select>\n        ${this.tooltipText\n          ? html`\n              <ha-help-tooltip .label=${this.tooltipText}></ha-help-tooltip>\n            `\n          : nothing}\n      </div>\n      ${this.config?.action === \"navigate\"\n        ? html`\n            <ha-form\n              .hass=${this.hass}\n              .schema=${NAVIGATE_SCHEMA}\n              .data=${this.config}\n              .computeLabel=${this._computeFormLabel}\n              @value-changed=${this._formValueChanged}\n            >\n            </ha-form>\n          `\n        : nothing}\n      ${this.config?.action === \"url\"\n        ? html`\n            <ha-textfield\n              .label=${this.hass!.localize(\n                \"ui.panel.lovelace.editor.action-editor.url_path\"\n              )}\n              .value=${this._url_path}\n              .configValue=${\"url_path\"}\n              @input=${this._valueChanged}\n            ></ha-textfield>\n          `\n        : nothing}\n      ${this.config?.action === \"call-service\" ||\n      this.config?.action === \"perform-action\"\n        ? html`\n            <ha-service-control\n              .hass=${this.hass}\n              .value=${this._serviceAction(this.config)}\n              .showAdvanced=${this.hass.userData?.showAdvanced}\n              narrow\n              @value-changed=${this._serviceValueChanged}\n            ></ha-service-control>\n          `\n        : nothing}\n      ${this.config?.action === \"assist\"\n        ? html`\n            <ha-form\n              .hass=${this.hass}\n              .schema=${ASSIST_SCHEMA}\n              .data=${this.config}\n              .computeLabel=${this._computeFormLabel}\n              @value-changed=${this._formValueChanged}\n            >\n            </ha-form>\n          `\n        : nothing}\n    `;\n  }\n\n  private _actionPicked(ev): void {\n    ev.stopPropagation();\n    if (!this.hass) {\n      return;\n    }\n    let action = this.config?.action;\n\n    if (action === \"call-service\") {\n      action = \"perform-action\";\n    }\n\n    const value = ev.target.value;\n\n    if (action === value) {\n      return;\n    }\n    if (value === \"default\") {\n      fireEvent(this, \"value-changed\", { value: undefined });\n      return;\n    }\n\n    let data;\n    switch (value) {\n      case \"url\": {\n        data = { url_path: this._url_path };\n        break;\n      }\n      case \"perform-action\": {\n        data = { perform_action: this._service };\n        break;\n      }\n      case \"navigate\": {\n        data = { navigation_path: this._navigation_path };\n        break;\n      }\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value: { action: value, ...data },\n    });\n  }\n\n  private _valueChanged(ev): void {\n    ev.stopPropagation();\n    if (!this.hass) {\n      return;\n    }\n    const target = ev.target! as EditorTarget;\n    const value = ev.target.value ?? ev.target.checked;\n    if (this[`_${target.configValue}`] === value) {\n      return;\n    }\n    if (target.configValue) {\n      fireEvent(this, \"value-changed\", {\n        value: { ...this.config!, [target.configValue!]: value },\n      });\n    }\n  }\n\n  private _formValueChanged(ev): void {\n    ev.stopPropagation();\n    const value = ev.detail.value;\n\n    fireEvent(this, \"value-changed\", {\n      value: value,\n    });\n  }\n\n  private _computeFormLabel(schema: SchemaUnion<typeof ASSIST_SCHEMA>) {\n    return this.hass?.localize(\n      `ui.panel.lovelace.editor.action-editor.${schema.name}`\n    );\n  }\n\n  private _serviceValueChanged(ev: CustomEvent) {\n    ev.stopPropagation();\n    const value = {\n      ...this.config!,\n      action: \"perform-action\",\n      perform_action: ev.detail.value.action || \"\",\n      data: ev.detail.value.data,\n      target: ev.detail.value.target || {},\n    };\n    if (!ev.detail.value.data) {\n      delete value.data;\n    }\n    // \"service_data\" is allowed for backwards compatibility but replaced with \"data\" on write\n    if (\"service_data\" in value) {\n      delete value.service_data;\n    }\n    if (\"service\" in value) {\n      delete value.service;\n    }\n\n    fireEvent(this, \"value-changed\", { value });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      .dropdown {\n        position: relative;\n      }\n      ha-help-tooltip {\n        position: absolute;\n        right: 40px;\n        top: 16px;\n        inset-inline-start: initial;\n        inset-inline-end: 40px;\n        direction: var(--direction);\n      }\n      ha-select,\n      ha-textfield {\n        width: 100%;\n      }\n      ha-service-control,\n      ha-navigation-picker,\n      ha-form {\n        display: block;\n      }\n      ha-textfield,\n      ha-service-control,\n      ha-navigation-picker,\n      ha-form {\n        margin-top: 8px;\n      }\n      ha-service-control {\n        --service-control-padding: 0;\n      }\n      ha-formfield {\n        display: flex;\n        height: 56px;\n        align-items: center;\n        --mdc-typography-body2-font-size: 1em;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-action-editor\": HuiActionEditor;\n  }\n}\n","import { html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { ActionConfig } from \"../../data/lovelace/config/action\";\nimport type { UiActionSelector } from \"../../data/selector\";\nimport \"../../panels/lovelace/components/hui-action-editor\";\nimport type { HomeAssistant } from \"../../types\";\n\n@customElement(\"ha-selector-ui_action\")\nexport class HaSelectorUiAction extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public selector!: UiActionSelector;\n\n  @property({ attribute: false }) public value?: ActionConfig;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  protected render() {\n    return html`\n      <hui-action-editor\n        .label=${this.label}\n        .hass=${this.hass}\n        .config=${this.value}\n        .actions=${this.selector.ui_action?.actions}\n        .defaultAction=${this.selector.ui_action?.default_action}\n        .tooltipText=${this.helper}\n        @value-changed=${this._valueChanged}\n      ></hui-action-editor>\n    `;\n  }\n\n  private _valueChanged(ev: CustomEvent) {\n    fireEvent(this, \"value-changed\", { value: ev.detail.value });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-ui_action\": HaSelectorUiAction;\n  }\n}\n","import type { Schema } from \"js-yaml\";\nimport { DEFAULT_SCHEMA, dump, load } from \"js-yaml\";\nimport type { CSSResultGroup, PropertyValues } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport type { HomeAssistant } from \"../types\";\nimport { haStyle } from \"../resources/styles\";\nimport \"./ha-code-editor\";\nimport { showToast } from \"../util/toast\";\nimport { copyToClipboard } from \"../common/util/copy-clipboard\";\nimport type { HaCodeEditor } from \"./ha-code-editor\";\nimport \"./ha-button\";\n\nconst isEmpty = (obj: Record<string, unknown>): boolean => {\n  if (typeof obj !== \"object\" || obj === null) {\n    return false;\n  }\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n@customElement(\"ha-yaml-editor\")\nexport class HaYamlEditor extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public value?: any;\n\n  @property({ attribute: false }) public yamlSchema: Schema = DEFAULT_SCHEMA;\n\n  @property() public defaultValue?: any;\n\n  @property({ type: Boolean }) public isValid = true;\n\n  @property() public label?: string;\n\n  @property({ type: Boolean }) public autoUpdate = false;\n\n  @property({ type: Boolean }) public readOnly = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @property({ type: Boolean }) public copyClipboard = false;\n\n  @property({ type: Boolean }) public hasExtraActions = false;\n\n  @state() private _yaml = \"\";\n\n  @query(\"ha-code-editor\") _codeEditor?: HaCodeEditor;\n\n  public setValue(value): void {\n    try {\n      this._yaml = !isEmpty(value)\n        ? dump(value, {\n            schema: this.yamlSchema,\n            quotingType: '\"',\n            noRefs: true,\n          })\n        : \"\";\n    } catch (err: any) {\n      // eslint-disable-next-line no-console\n      console.error(err, value);\n      alert(`There was an error converting to YAML: ${err}`);\n    }\n  }\n\n  protected firstUpdated(): void {\n    if (this.defaultValue !== undefined) {\n      this.setValue(this.defaultValue);\n    }\n  }\n\n  protected willUpdate(changedProperties: PropertyValues<this>): void {\n    super.willUpdate(changedProperties);\n    if (this.autoUpdate && changedProperties.has(\"value\")) {\n      this.setValue(this.value);\n    }\n  }\n\n  public focus(): void {\n    if (this._codeEditor?.codemirror) {\n      this._codeEditor?.codemirror.focus();\n    }\n  }\n\n  protected render() {\n    if (this._yaml === undefined) {\n      return nothing;\n    }\n    return html`\n      ${this.label\n        ? html`<p>${this.label}${this.required ? \" *\" : \"\"}</p>`\n        : nothing}\n      <ha-code-editor\n        .hass=${this.hass}\n        .value=${this._yaml}\n        .readOnly=${this.readOnly}\n        mode=\"yaml\"\n        autocomplete-entities\n        autocomplete-icons\n        .error=${this.isValid === false}\n        @value-changed=${this._onChange}\n        dir=\"ltr\"\n      ></ha-code-editor>\n      ${this.copyClipboard || this.hasExtraActions\n        ? html`\n            <div class=\"card-actions\">\n              ${this.copyClipboard\n                ? html`\n                    <ha-button @click=${this._copyYaml}>\n                      ${this.hass.localize(\n                        \"ui.components.yaml-editor.copy_to_clipboard\"\n                      )}\n                    </ha-button>\n                  `\n                : nothing}\n              <slot name=\"extra-actions\"></slot>\n            </div>\n          `\n        : nothing}\n    `;\n  }\n\n  private _onChange(ev: CustomEvent): void {\n    ev.stopPropagation();\n    this._yaml = ev.detail.value;\n    let parsed;\n    let isValid = true;\n\n    if (this._yaml) {\n      try {\n        parsed = load(this._yaml, { schema: this.yamlSchema });\n      } catch (err: any) {\n        // Invalid YAML\n        isValid = false;\n      }\n    } else {\n      parsed = {};\n    }\n\n    this.value = parsed;\n    this.isValid = isValid;\n\n    fireEvent(this, \"value-changed\", { value: parsed, isValid } as any);\n  }\n\n  get yaml() {\n    return this._yaml;\n  }\n\n  private async _copyYaml(): Promise<void> {\n    if (this.yaml) {\n      await copyToClipboard(this.yaml);\n      showToast(this, {\n        message: this.hass.localize(\"ui.common.copied_clipboard\"),\n      });\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        .card-actions {\n          border-radius: var(\n            --actions-border-radius,\n            0px 0px var(--ha-card-border-radius, 12px)\n              var(--ha-card-border-radius, 12px)\n          );\n          border: 1px solid var(--divider-color);\n          padding: 5px 16px;\n        }\n        ha-code-editor {\n          flex-grow: 1;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-yaml-editor\": HaYamlEditor;\n  }\n}\n"],"names":[],"sourceRoot":""}