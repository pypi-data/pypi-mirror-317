{"version":3,"file":"r4MaHswo.js","mappings":";;AA4GA;;AAGA;;AAEA;AAEA;AAKA;;AAGA;;AAEA;;AAIA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;;AAIA;AAoEA;AAGA;;AAKA;;;;;;;;;;AAsBA;;ACvPA;AACA;AACA;;AAEA;;AAGA;AAGA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;AAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4iBA;;AC/eA;AACA;AACA;AACA;AACA;;AAEA;AAIA;;;;;AA2NA;AC1RA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;;AAGA;;;;;;;;;AAwFA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-form/ha-form.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/map/ha-entity-marker.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/map/ha-map.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/map/ha-locations-editor.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-selector/ha-selector-location.ts"],"sourcesContent":["/* eslint-disable lit/prefer-static-styles */\nimport type { CSSResultGroup, PropertyValues, TemplateResult } from \"lit\";\nimport { css, html, LitElement, ReactiveElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { dynamicElement } from \"../../common/dom/dynamic-element-directive\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../ha-alert\";\nimport \"../ha-selector/ha-selector\";\nimport type { HaFormDataContainer, HaFormElement, HaFormSchema } from \"./types\";\n\nconst LOAD_ELEMENTS = {\n  boolean: () => import(\"./ha-form-boolean\"),\n  constant: () => import(\"./ha-form-constant\"),\n  float: () => import(\"./ha-form-float\"),\n  grid: () => import(\"./ha-form-grid\"),\n  expandable: () => import(\"./ha-form-expandable\"),\n  integer: () => import(\"./ha-form-integer\"),\n  multi_select: () => import(\"./ha-form-multi_select\"),\n  positive_time_period_dict: () =>\n    import(\"./ha-form-positive_time_period_dict\"),\n  select: () => import(\"./ha-form-select\"),\n  string: () => import(\"./ha-form-string\"),\n};\n\nconst getValue = (obj, item) =>\n  obj ? (!item.name || item.flatten ? obj : obj[item.name]) : null;\n\nconst getError = (obj, item) => (obj && item.name ? obj[item.name] : null);\n\nconst getWarning = (obj, item) => (obj && item.name ? obj[item.name] : null);\n\n@customElement(\"ha-form\")\nexport class HaForm extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public data!: HaFormDataContainer;\n\n  @property({ attribute: false }) public schema!: readonly HaFormSchema[];\n\n  @property({ attribute: false }) public error?: Record<\n    string,\n    string | string[]\n  >;\n\n  @property({ attribute: false }) public warning?: Record<string, string>;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ attribute: false }) public computeError?: (\n    schema: any,\n    error\n  ) => string;\n\n  @property({ attribute: false }) public computeWarning?: (\n    schema: any,\n    warning\n  ) => string;\n\n  @property({ attribute: false }) public computeLabel?: (\n    schema: any,\n    data: HaFormDataContainer\n  ) => string;\n\n  @property({ attribute: false }) public computeHelper?: (\n    schema: any\n  ) => string | undefined;\n\n  @property({ attribute: false }) public localizeValue?: (\n    key: string\n  ) => string;\n\n  protected getFormProperties(): Record<string, any> {\n    return {};\n  }\n\n  public async focus() {\n    await this.updateComplete;\n    const root = this.renderRoot.querySelector(\".root\");\n    if (!root) {\n      return;\n    }\n    for (const child of root.children) {\n      if (child.tagName !== \"HA-ALERT\") {\n        if (child instanceof ReactiveElement) {\n          // eslint-disable-next-line no-await-in-loop\n          await child.updateComplete;\n        }\n        (child as HTMLElement).focus();\n        break;\n      }\n    }\n  }\n\n  protected willUpdate(changedProps: PropertyValues) {\n    if (changedProps.has(\"schema\") && this.schema) {\n      this.schema.forEach((item) => {\n        if (\"selector\" in item) {\n          return;\n        }\n        LOAD_ELEMENTS[item.type]?.();\n      });\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"root\" part=\"root\">\n        ${this.error && this.error.base\n          ? html`\n              <ha-alert alert-type=\"error\">\n                ${this._computeError(this.error.base, this.schema)}\n              </ha-alert>\n            `\n          : \"\"}\n        ${this.schema.map((item) => {\n          const error = getError(this.error, item);\n          const warning = getWarning(this.warning, item);\n\n          return html`\n            ${error\n              ? html`\n                  <ha-alert own-margin alert-type=\"error\">\n                    ${this._computeError(error, item)}\n                  </ha-alert>\n                `\n              : warning\n                ? html`\n                    <ha-alert own-margin alert-type=\"warning\">\n                      ${this._computeWarning(warning, item)}\n                    </ha-alert>\n                  `\n                : \"\"}\n            ${\"selector\" in item\n              ? html`<ha-selector\n                  .schema=${item}\n                  .hass=${this.hass}\n                  .name=${item.name}\n                  .selector=${item.selector}\n                  .value=${getValue(this.data, item)}\n                  .label=${this._computeLabel(item, this.data)}\n                  .disabled=${item.disabled || this.disabled || false}\n                  .placeholder=${item.required ? \"\" : item.default}\n                  .helper=${this._computeHelper(item)}\n                  .localizeValue=${this.localizeValue}\n                  .required=${item.required || false}\n                  .context=${this._generateContext(item)}\n                ></ha-selector>`\n              : dynamicElement(this.fieldElementName(item.type), {\n                  schema: item,\n                  data: getValue(this.data, item),\n                  label: this._computeLabel(item, this.data),\n                  helper: this._computeHelper(item),\n                  disabled: this.disabled || item.disabled || false,\n                  hass: this.hass,\n                  localize: this.hass?.localize,\n                  computeLabel: this.computeLabel,\n                  computeHelper: this.computeHelper,\n                  localizeValue: this.localizeValue,\n                  context: this._generateContext(item),\n                  ...this.getFormProperties(),\n                })}\n          `;\n        })}\n      </div>\n    `;\n  }\n\n  protected fieldElementName(type: string): string {\n    return `ha-form-${type}`;\n  }\n\n  private _generateContext(\n    schema: HaFormSchema\n  ): Record<string, any> | undefined {\n    if (!schema.context) {\n      return undefined;\n    }\n\n    const context = {};\n    for (const [context_key, data_key] of Object.entries(schema.context)) {\n      context[context_key] = this.data[data_key];\n    }\n    return context;\n  }\n\n  protected createRenderRoot() {\n    const root = super.createRenderRoot();\n    // attach it as soon as possible to make sure we fetch all events.\n    this.addValueChangedListener(root);\n    return root;\n  }\n\n  protected addValueChangedListener(element: Element | ShadowRoot) {\n    element.addEventListener(\"value-changed\", (ev) => {\n      ev.stopPropagation();\n      const schema = (ev.target as HaFormElement).schema as HaFormSchema;\n\n      if (ev.target === this) return;\n\n      const newValue =\n        !schema.name || (\"flatten\" in schema && schema.flatten)\n          ? ev.detail.value\n          : { [schema.name]: ev.detail.value };\n\n      this.data = {\n        ...this.data,\n        ...newValue,\n      };\n\n      fireEvent(this, \"value-changed\", {\n        value: this.data,\n      });\n    });\n  }\n\n  private _computeLabel(schema: HaFormSchema, data: HaFormDataContainer) {\n    return this.computeLabel\n      ? this.computeLabel(schema, data)\n      : schema\n        ? schema.name\n        : \"\";\n  }\n\n  private _computeHelper(schema: HaFormSchema) {\n    return this.computeHelper ? this.computeHelper(schema) : \"\";\n  }\n\n  private _computeError(\n    error: string | string[],\n    schema: HaFormSchema | readonly HaFormSchema[]\n  ): string | TemplateResult {\n    if (Array.isArray(error)) {\n      return html`<ul>\n        ${error.map(\n          (err) =>\n            html`<li>\n              ${this.computeError ? this.computeError(err, schema) : err}\n            </li>`\n        )}\n      </ul>`;\n    }\n    return this.computeError ? this.computeError(error, schema) : error;\n  }\n\n  private _computeWarning(\n    warning,\n    schema: HaFormSchema | readonly HaFormSchema[]\n  ) {\n    return this.computeWarning ? this.computeWarning(warning, schema) : warning;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      .root > * {\n        display: block;\n      }\n      .root > *:not([own-margin]):not(:last-child) {\n        margin-bottom: 24px;\n      }\n      ha-alert[own-margin] {\n        margin-bottom: 4px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form\": HaForm;\n  }\n}\n","import { LitElement, html, css } from \"lit\";\nimport { property } from \"lit/decorators\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\n\nclass HaEntityMarker extends LitElement {\n  @property({ attribute: \"entity-id\" }) public entityId?: string;\n\n  @property({ attribute: \"entity-name\" }) public entityName?: string;\n\n  @property({ attribute: \"entity-picture\" }) public entityPicture?: string;\n\n  @property({ attribute: \"entity-color\" }) public entityColor?: string;\n\n  protected render() {\n    return html`\n      <div\n        class=\"marker ${this.entityPicture ? \"picture\" : \"\"}\"\n        style=${styleMap({ \"border-color\": this.entityColor })}\n        @click=${this._badgeTap}\n      >\n        ${this.entityPicture\n          ? html`<div\n              class=\"entity-picture\"\n              style=${styleMap({\n                \"background-image\": `url(${this.entityPicture})`,\n              })}\n            ></div>`\n          : this.entityName}\n      </div>\n    `;\n  }\n\n  private _badgeTap(ev: Event) {\n    ev.stopPropagation();\n    if (this.entityId) {\n      fireEvent(this, \"hass-more-info\", { entityId: this.entityId });\n    }\n  }\n\n  static get styles() {\n    return css`\n      .marker {\n        display: flex;\n        justify-content: center;\n        text-align: center;\n        align-items: center;\n        box-sizing: border-box;\n        width: 48px;\n        height: 48px;\n        font-size: var(--ha-marker-font-size, 1.5em);\n        border-radius: var(--ha-marker-border-radius, 50%);\n        border: 1px solid var(--ha-marker-color, var(--primary-color));\n        color: var(--primary-text-color);\n        background-color: var(--card-background-color);\n      }\n      .marker.picture {\n        overflow: hidden;\n      }\n      .entity-picture {\n        background-size: cover;\n        height: 100%;\n        width: 100%;\n      }\n    `;\n  }\n}\n\ncustomElements.define(\"ha-entity-marker\", HaEntityMarker);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-entity-marker\": HaEntityMarker;\n  }\n}\n","import { isToday } from \"date-fns\";\nimport type {\n  Circle,\n  CircleMarker,\n  LatLngExpression,\n  LatLngTuple,\n  Layer,\n  Map,\n  Marker,\n  Polyline,\n} from \"leaflet\";\nimport type { CSSResultGroup, PropertyValues } from \"lit\";\nimport { ReactiveElement, css } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { formatDateTime } from \"../../common/datetime/format_date_time\";\nimport {\n  formatTimeWeekday,\n  formatTimeWithSeconds,\n} from \"../../common/datetime/format_time\";\nimport type { LeafletModuleType } from \"../../common/dom/setup-leaflet-map\";\nimport { setupLeafletMap } from \"../../common/dom/setup-leaflet-map\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport type { HomeAssistant, ThemeMode } from \"../../types\";\nimport { isTouch } from \"../../util/is_touch\";\nimport \"../ha-icon-button\";\nimport \"./ha-entity-marker\";\n\nconst getEntityId = (entity: string | HaMapEntity): string =>\n  typeof entity === \"string\" ? entity : entity.entity_id;\n\nexport interface HaMapPathPoint {\n  point: LatLngTuple;\n  timestamp: Date;\n}\nexport interface HaMapPaths {\n  points: HaMapPathPoint[];\n  color?: string;\n  name?: string;\n  gradualOpacity?: number;\n  fullDatetime?: boolean;\n}\n\nexport interface HaMapEntity {\n  entity_id: string;\n  color: string;\n  label_mode?: \"name\" | \"state\";\n  name?: string;\n  focus?: boolean;\n}\n\n@customElement(\"ha-map\")\nexport class HaMap extends ReactiveElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entities?: string[] | HaMapEntity[];\n\n  @property({ attribute: false }) public paths?: HaMapPaths[];\n\n  @property({ attribute: false }) public layers?: Layer[];\n\n  @property({ type: Boolean }) public autoFit = false;\n\n  @property({ type: Boolean }) public renderPassive = false;\n\n  @property({ type: Boolean }) public interactiveZones = false;\n\n  @property({ type: Boolean }) public fitZones = false;\n\n  @property({ attribute: \"theme-mode\", type: String })\n  public themeMode: ThemeMode = \"auto\";\n\n  @property({ type: Number }) public zoom = 14;\n\n  @state() private _loaded = false;\n\n  public leafletMap?: Map;\n\n  private Leaflet?: LeafletModuleType;\n\n  private _resizeObserver?: ResizeObserver;\n\n  private _mapItems: Array<Marker | Circle> = [];\n\n  private _mapFocusItems: Array<Marker | Circle> = [];\n\n  private _mapZones: Array<Marker | Circle> = [];\n\n  private _mapFocusZones: Array<Marker | Circle> = [];\n\n  private _mapPaths: Array<Polyline | CircleMarker> = [];\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this._loadMap();\n    this._attachObserver();\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    if (this.leafletMap) {\n      this.leafletMap.remove();\n      this.leafletMap = undefined;\n      this.Leaflet = undefined;\n    }\n\n    this._loaded = false;\n\n    if (this._resizeObserver) {\n      this._resizeObserver.unobserve(this);\n    }\n  }\n\n  protected update(changedProps: PropertyValues) {\n    super.update(changedProps);\n\n    if (!this._loaded) {\n      return;\n    }\n    let autoFitRequired = false;\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"entities\")) {\n      this._drawEntities();\n      autoFitRequired = true;\n    } else if (this._loaded && oldHass && this.entities) {\n      // Check if any state has changed\n      for (const entity of this.entities) {\n        if (\n          oldHass.states[getEntityId(entity)] !==\n          this.hass!.states[getEntityId(entity)]\n        ) {\n          this._drawEntities();\n          autoFitRequired = true;\n          break;\n        }\n      }\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"paths\")) {\n      this._drawPaths();\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"layers\")) {\n      this._drawLayers(changedProps.get(\"layers\") as Layer[] | undefined);\n      autoFitRequired = true;\n    }\n\n    if (changedProps.has(\"_loaded\") || (this.autoFit && autoFitRequired)) {\n      this.fitMap();\n    }\n\n    if (changedProps.has(\"zoom\")) {\n      this.leafletMap!.setZoom(this.zoom);\n    }\n\n    if (\n      !changedProps.has(\"themeMode\") &&\n      (!changedProps.has(\"hass\") ||\n        (oldHass && oldHass.themes?.darkMode === this.hass.themes?.darkMode))\n    ) {\n      return;\n    }\n    this._updateMapStyle();\n  }\n\n  private get _darkMode() {\n    return (\n      this.themeMode === \"dark\" ||\n      (this.themeMode === \"auto\" && Boolean(this.hass.themes.darkMode))\n    );\n  }\n\n  private _updateMapStyle(): void {\n    const map = this.renderRoot.querySelector(\"#map\");\n    map!.classList.toggle(\"dark\", this._darkMode);\n    map!.classList.toggle(\"forced-dark\", this.themeMode === \"dark\");\n    map!.classList.toggle(\"forced-light\", this.themeMode === \"light\");\n  }\n\n  private _loading = false;\n\n  private async _loadMap(): Promise<void> {\n    if (this._loading) return;\n    let map = this.shadowRoot!.getElementById(\"map\");\n    if (!map) {\n      map = document.createElement(\"div\");\n      map.id = \"map\";\n      this.shadowRoot!.append(map);\n    }\n    this._loading = true;\n    try {\n      [this.leafletMap, this.Leaflet] = await setupLeafletMap(map);\n      this._updateMapStyle();\n      this._loaded = true;\n    } finally {\n      this._loading = false;\n    }\n  }\n\n  public fitMap(options?: { zoom?: number; pad?: number }): void {\n    if (!this.leafletMap || !this.Leaflet || !this.hass) {\n      return;\n    }\n\n    if (\n      !this._mapFocusItems.length &&\n      !this._mapFocusZones.length &&\n      !this.layers?.length\n    ) {\n      this.leafletMap.setView(\n        new this.Leaflet.LatLng(\n          this.hass.config.latitude,\n          this.hass.config.longitude\n        ),\n        options?.zoom || this.zoom\n      );\n      return;\n    }\n\n    let bounds = this.Leaflet.latLngBounds(\n      this._mapFocusItems\n        ? this._mapFocusItems.map((item) => item.getLatLng())\n        : []\n    );\n\n    this._mapFocusZones?.forEach((zone) => {\n      bounds.extend(\"getBounds\" in zone ? zone.getBounds() : zone.getLatLng());\n    });\n\n    this.layers?.forEach((layer: any) => {\n      bounds.extend(\n        \"getBounds\" in layer ? layer.getBounds() : layer.getLatLng()\n      );\n    });\n\n    bounds = bounds.pad(options?.pad ?? 0.5);\n\n    this.leafletMap.fitBounds(bounds, { maxZoom: options?.zoom || this.zoom });\n  }\n\n  public fitBounds(\n    boundingbox: LatLngExpression[],\n    options?: { zoom?: number; pad?: number }\n  ) {\n    if (!this.leafletMap || !this.Leaflet || !this.hass) {\n      return;\n    }\n    const bounds = this.Leaflet.latLngBounds(boundingbox).pad(\n      options?.pad ?? 0.5\n    );\n    this.leafletMap.fitBounds(bounds, { maxZoom: options?.zoom || this.zoom });\n  }\n\n  private _drawLayers(prevLayers: Layer[] | undefined): void {\n    if (prevLayers) {\n      prevLayers.forEach((layer) => layer.remove());\n    }\n    if (!this.layers) {\n      return;\n    }\n    const map = this.leafletMap!;\n    this.layers.forEach((layer) => {\n      map.addLayer(layer);\n    });\n  }\n\n  private _computePathTooltip(path: HaMapPaths, point: HaMapPathPoint): string {\n    let formattedTime: string;\n    if (path.fullDatetime) {\n      formattedTime = formatDateTime(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    } else if (isToday(point.timestamp)) {\n      formattedTime = formatTimeWithSeconds(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    } else {\n      formattedTime = formatTimeWeekday(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    }\n    return `${path.name}<br>${formattedTime}`;\n  }\n\n  private _drawPaths(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n    if (this._mapPaths.length) {\n      this._mapPaths.forEach((marker) => marker.remove());\n      this._mapPaths = [];\n    }\n    if (!this.paths) {\n      return;\n    }\n\n    const darkPrimaryColor = getComputedStyle(this).getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    this.paths.forEach((path) => {\n      let opacityStep: number;\n      let baseOpacity: number;\n      if (path.gradualOpacity) {\n        opacityStep = path.gradualOpacity / (path.points.length - 2);\n        baseOpacity = 1 - path.gradualOpacity;\n      }\n\n      for (\n        let pointIndex = 0;\n        pointIndex < path.points.length - 1;\n        pointIndex++\n      ) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n\n        // DRAW point\n        this._mapPaths.push(\n          Leaflet!\n            .circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity,\n              fillOpacity: opacity,\n              interactive: true,\n            })\n            .bindTooltip(\n              this._computePathTooltip(path, path.points[pointIndex]),\n              { direction: \"top\" }\n            )\n        );\n\n        // DRAW line between this and next point\n        this._mapPaths.push(\n          Leaflet!.polyline(\n            [path.points[pointIndex].point, path.points[pointIndex + 1].point],\n            {\n              color: path.color || darkPrimaryColor,\n              opacity,\n              interactive: false,\n            }\n          )\n        );\n      }\n      const pointIndex = path.points.length - 1;\n      if (pointIndex >= 0) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n        // DRAW end path point\n        this._mapPaths.push(\n          Leaflet!\n            .circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity,\n              fillOpacity: opacity,\n              interactive: true,\n            })\n            .bindTooltip(\n              this._computePathTooltip(path, path.points[pointIndex]),\n              { direction: \"top\" }\n            )\n        );\n      }\n      this._mapPaths.forEach((marker) => map.addLayer(marker));\n    });\n  }\n\n  private _drawEntities(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n\n    if (this._mapItems.length) {\n      this._mapItems.forEach((marker) => marker.remove());\n      this._mapItems = [];\n      this._mapFocusItems = [];\n    }\n\n    if (this._mapZones.length) {\n      this._mapZones.forEach((marker) => marker.remove());\n      this._mapZones = [];\n      this._mapFocusZones = [];\n    }\n\n    if (!this.entities) {\n      return;\n    }\n\n    const computedStyles = getComputedStyle(this);\n    const zoneColor = computedStyles.getPropertyValue(\"--accent-color\");\n    const passiveZoneColor = computedStyles.getPropertyValue(\n      \"--secondary-text-color\"\n    );\n\n    const darkPrimaryColor = computedStyles.getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    const className = this._darkMode ? \"dark\" : \"light\";\n\n    for (const entity of this.entities) {\n      const stateObj = hass.states[getEntityId(entity)];\n      if (!stateObj) {\n        continue;\n      }\n      const customTitle = typeof entity !== \"string\" ? entity.name : undefined;\n      const title = customTitle ?? computeStateName(stateObj);\n      const {\n        latitude,\n        longitude,\n        passive,\n        icon,\n        radius,\n        entity_picture: entityPicture,\n        gps_accuracy: gpsAccuracy,\n      } = stateObj.attributes;\n\n      if (!(latitude && longitude)) {\n        continue;\n      }\n\n      if (computeStateDomain(stateObj) === \"zone\") {\n        // DRAW ZONE\n        if (passive && !this.renderPassive) {\n          continue;\n        }\n\n        // create icon\n        let iconHTML = \"\";\n        if (icon) {\n          const el = document.createElement(\"ha-icon\");\n          el.setAttribute(\"icon\", icon);\n          iconHTML = el.outerHTML;\n        } else {\n          const el = document.createElement(\"span\");\n          el.innerHTML = title;\n          iconHTML = el.outerHTML;\n        }\n\n        // create marker with the icon\n        this._mapZones.push(\n          Leaflet.marker([latitude, longitude], {\n            icon: Leaflet.divIcon({\n              html: iconHTML,\n              iconSize: [24, 24],\n              className,\n            }),\n            interactive: this.interactiveZones,\n            title,\n          })\n        );\n\n        // create circle around it\n        const circle = Leaflet.circle([latitude, longitude], {\n          interactive: false,\n          color: passive ? passiveZoneColor : zoneColor,\n          radius,\n        });\n        this._mapZones.push(circle);\n        if (\n          this.fitZones &&\n          (typeof entity === \"string\" || entity.focus !== false)\n        ) {\n          this._mapFocusZones.push(circle);\n        }\n\n        continue;\n      }\n\n      // DRAW ENTITY\n      // create icon\n      const entityName =\n        typeof entity !== \"string\" && entity.label_mode === \"state\"\n          ? this.hass.formatEntityState(stateObj)\n          : (customTitle ??\n            title\n              .split(\" \")\n              .map((part) => part[0])\n              .join(\"\")\n              .substr(0, 3));\n\n      // create marker with the icon\n      const marker = Leaflet.marker([latitude, longitude], {\n        icon: Leaflet.divIcon({\n          html: `\n              <ha-entity-marker\n                entity-id=\"${getEntityId(entity)}\"\n                entity-name=\"${entityName}\"\n                entity-picture=\"${\n                  entityPicture ? this.hass.hassUrl(entityPicture) : \"\"\n                }\"\n                ${\n                  typeof entity !== \"string\"\n                    ? `entity-color=\"${entity.color}\"`\n                    : \"\"\n                }\n              ></ha-entity-marker>\n            `,\n          iconSize: [48, 48],\n          className: \"\",\n        }),\n        title: title,\n      });\n      this._mapItems.push(marker);\n      if (typeof entity === \"string\" || entity.focus !== false) {\n        this._mapFocusItems.push(marker);\n      }\n\n      // create circle around if entity has accuracy\n      if (gpsAccuracy) {\n        this._mapItems.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: darkPrimaryColor,\n            radius: gpsAccuracy,\n          })\n        );\n      }\n    }\n\n    this._mapItems.forEach((marker) => map.addLayer(marker));\n    this._mapZones.forEach((marker) => map.addLayer(marker));\n  }\n\n  private async _attachObserver(): Promise<void> {\n    if (!this._resizeObserver) {\n      this._resizeObserver = new ResizeObserver(() => {\n        this.leafletMap?.invalidateSize({ debounceMoveend: true });\n      });\n    }\n    this._resizeObserver.observe(this);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        height: 300px;\n      }\n      #map {\n        height: 100%;\n      }\n      #map.dark {\n        background: #090909;\n      }\n      #map.forced-dark {\n        color: #ffffff;\n        --map-filter: invert(0.9) hue-rotate(170deg) brightness(1.5)\n          contrast(1.2) saturate(0.3);\n      }\n      #map.forced-light {\n        background: #ffffff;\n        color: #000000;\n        --map-filter: invert(0);\n      }\n      #map:active {\n        cursor: grabbing;\n        cursor: -moz-grabbing;\n        cursor: -webkit-grabbing;\n      }\n      .leaflet-tile-pane {\n        filter: var(--map-filter);\n      }\n      .dark .leaflet-bar a {\n        background-color: #1c1c1c;\n        color: #ffffff;\n      }\n      .dark .leaflet-bar a:hover {\n        background-color: #313131;\n      }\n      .leaflet-marker-draggable {\n        cursor: move !important;\n      }\n      .leaflet-edit-resize {\n        border-radius: 50%;\n        cursor: nesw-resize !important;\n      }\n      .named-icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        text-align: center;\n        color: var(--primary-text-color);\n      }\n      .leaflet-pane {\n        z-index: 0 !important;\n      }\n      .leaflet-control,\n      .leaflet-top,\n      .leaflet-bottom {\n        z-index: 1 !important;\n      }\n      .leaflet-tooltip {\n        padding: 8px;\n        font-size: 90%;\n        background: rgba(80, 80, 80, 0.9) !important;\n        color: white !important;\n        border-radius: 4px;\n        box-shadow: none !important;\n        text-align: center;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-map\": HaMap;\n  }\n}\n","import type {\n  Circle,\n  DivIcon,\n  DragEndEvent,\n  LatLng,\n  LatLngExpression,\n  Marker,\n  MarkerOptions,\n} from \"leaflet\";\nimport type { CSSResultGroup, PropertyValues, TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { LeafletModuleType } from \"../../common/dom/setup-leaflet-map\";\nimport type { HomeAssistant, ThemeMode } from \"../../types\";\nimport \"../ha-input-helper-text\";\nimport \"./ha-map\";\nimport type { HaMap } from \"./ha-map\";\nimport type { HaIcon } from \"../ha-icon\";\nimport type { HaSvgIcon } from \"../ha-svg-icon\";\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"location-updated\": { id: string; location: [number, number] };\n    \"markers-updated\": undefined;\n    \"radius-updated\": { id: string; radius: number };\n    \"marker-clicked\": { id: string };\n  }\n}\n\nexport interface MarkerLocation {\n  latitude: number;\n  longitude: number;\n  radius?: number;\n  name?: string;\n  id: string;\n  icon?: string;\n  iconPath?: string;\n  radius_color?: string;\n  location_editable?: boolean;\n  radius_editable?: boolean;\n}\n\n@customElement(\"ha-locations-editor\")\nexport class HaLocationsEditor extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public locations?: MarkerLocation[];\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public autoFit = false;\n\n  @property({ type: Number }) public zoom = 16;\n\n  @property({ attribute: \"theme-mode\", type: String })\n  public themeMode: ThemeMode = \"auto\";\n\n  @state() private _locationMarkers?: Record<string, Marker | Circle>;\n\n  @state() private _circles: Record<string, Circle> = {};\n\n  @query(\"ha-map\", true) private map!: HaMap;\n\n  private Leaflet?: LeafletModuleType;\n\n  private _loadPromise: Promise<boolean | void>;\n\n  constructor() {\n    super();\n\n    this._loadPromise = import(\"leaflet\").then((module) =>\n      import(\"leaflet-draw\").then(() => {\n        this.Leaflet = module.default as LeafletModuleType;\n        this._updateMarkers();\n        return this.updateComplete.then(() => this.fitMap());\n      })\n    );\n  }\n\n  public fitMap(options?: { zoom?: number; pad?: number }): void {\n    this.map.fitMap(options);\n  }\n\n  public fitBounds(\n    boundingbox: LatLngExpression[],\n    options?: { zoom?: number; pad?: number }\n  ) {\n    this.map.fitBounds(boundingbox, options);\n  }\n\n  public async fitMarker(\n    id: string,\n    options?: { zoom?: number }\n  ): Promise<void> {\n    if (!this.Leaflet) {\n      await this._loadPromise;\n    }\n    if (!this.map.leafletMap || !this._locationMarkers) {\n      return;\n    }\n    const marker = this._locationMarkers[id];\n    if (!marker) {\n      return;\n    }\n    if (\"getBounds\" in marker) {\n      this.map.leafletMap.fitBounds(marker.getBounds());\n      (marker as Circle).bringToFront();\n    } else {\n      const circle = this._circles[id];\n      if (circle) {\n        this.map.leafletMap.fitBounds(circle.getBounds());\n      } else {\n        this.map.leafletMap.setView(\n          marker.getLatLng(),\n          options?.zoom || this.zoom\n        );\n      }\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-map\n        .hass=${this.hass}\n        .layers=${this._getLayers(this._circles, this._locationMarkers)}\n        .zoom=${this.zoom}\n        .autoFit=${this.autoFit}\n        .themeMode=${this.themeMode}\n      ></ha-map>\n      ${this.helper\n        ? html`<ha-input-helper-text>${this.helper}</ha-input-helper-text>`\n        : \"\"}\n    `;\n  }\n\n  private _getLayers = memoizeOne(\n    (\n      circles: Record<string, Circle>,\n      markers?: Record<string, Marker | Circle>\n    ): Array<Marker | Circle> => {\n      const layers: Array<Marker | Circle> = [];\n      Array.prototype.push.apply(layers, Object.values(circles));\n      if (markers) {\n        Array.prototype.push.apply(layers, Object.values(markers));\n      }\n      return layers;\n    }\n  );\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n\n    // Still loading.\n    if (!this.Leaflet) {\n      return;\n    }\n\n    if (changedProps.has(\"locations\")) {\n      this._updateMarkers();\n    }\n  }\n\n  public updated(changedProps: PropertyValues): void {\n    // Still loading.\n    if (!this.Leaflet) {\n      return;\n    }\n\n    if (changedProps.has(\"locations\")) {\n      const oldLocations = changedProps.get(\"locations\");\n      const movedLocations = this.locations?.filter(\n        (loc, idx) =>\n          !oldLocations[idx] ||\n          ((loc.latitude !== oldLocations[idx].latitude ||\n            loc.longitude !== oldLocations[idx].longitude) &&\n            this.map.leafletMap?.getBounds().contains({\n              lat: oldLocations[idx].latitude,\n              lng: oldLocations[idx].longitude,\n            }) &&\n            !this.map.leafletMap\n              ?.getBounds()\n              .contains({ lat: loc.latitude, lng: loc.longitude }))\n      );\n      if (movedLocations?.length === 1) {\n        this.map.leafletMap?.panTo({\n          lat: movedLocations[0].latitude,\n          lng: movedLocations[0].longitude,\n        });\n      }\n    }\n  }\n\n  private _updateLocation(ev: DragEndEvent) {\n    const marker = ev.target;\n    const latlng: LatLng = marker.getLatLng();\n    let longitude: number = latlng.lng;\n    if (Math.abs(longitude) > 180.0) {\n      // Normalize longitude if map provides values beyond -180 to +180 degrees.\n      longitude = (((longitude % 360.0) + 540.0) % 360.0) - 180.0;\n    }\n    const location: [number, number] = [latlng.lat, longitude];\n    fireEvent(\n      this,\n      \"location-updated\",\n      { id: marker.id, location },\n      { bubbles: false }\n    );\n  }\n\n  private _updateRadius(ev: DragEndEvent) {\n    const marker = ev.target;\n    const circle = this._locationMarkers![marker.id] as Circle;\n    fireEvent(\n      this,\n      \"radius-updated\",\n      { id: marker.id, radius: circle.getRadius() },\n      { bubbles: false }\n    );\n  }\n\n  private _markerClicked(ev: DragEndEvent) {\n    const marker = ev.target;\n    fireEvent(this, \"marker-clicked\", { id: marker.id }, { bubbles: false });\n  }\n\n  private _updateMarkers(): void {\n    if (!this.locations || !this.locations.length) {\n      this._circles = {};\n      this._locationMarkers = undefined;\n      return;\n    }\n\n    const locationMarkers = {};\n    const circles = {};\n\n    const defaultZoneRadiusColor =\n      getComputedStyle(this).getPropertyValue(\"--accent-color\");\n\n    this.locations.forEach((location: MarkerLocation) => {\n      let icon: DivIcon | undefined;\n      if (location.icon || location.iconPath) {\n        // create icon\n        const el = document.createElement(\"div\");\n        el.className = \"named-icon\";\n        if (location.name !== undefined) {\n          el.innerText = location.name;\n        }\n        let iconEl: HaIcon | HaSvgIcon;\n        if (location.icon) {\n          iconEl = document.createElement(\"ha-icon\");\n          iconEl.setAttribute(\"icon\", location.icon);\n        } else {\n          iconEl = document.createElement(\"ha-svg-icon\");\n          iconEl.setAttribute(\"path\", location.iconPath!);\n        }\n        el.prepend(iconEl);\n\n        icon = this.Leaflet!.divIcon({\n          html: el.outerHTML,\n          iconSize: [24, 24],\n          className: \"light\",\n        });\n      }\n      if (location.radius) {\n        const circle = this.Leaflet!.circle(\n          [location.latitude, location.longitude],\n          {\n            color: location.radius_color || defaultZoneRadiusColor,\n            radius: location.radius,\n          }\n        );\n        if (location.radius_editable || location.location_editable) {\n          // @ts-ignore\n          circle.editing.enable();\n          circle.addEventListener(\"add\", () => {\n            // @ts-ignore\n            const moveMarker = circle.editing._moveMarker;\n            // @ts-ignore\n            const resizeMarker = circle.editing._resizeMarkers[0];\n            if (icon) {\n              moveMarker.setIcon(icon);\n            }\n            resizeMarker.id = moveMarker.id = location.id;\n            moveMarker\n              .addEventListener(\n                \"dragend\",\n                // @ts-ignore\n                (ev: DragEndEvent) => this._updateLocation(ev)\n              )\n              .addEventListener(\n                \"click\",\n                // @ts-ignore\n                (ev: MouseEvent) => this._markerClicked(ev)\n              );\n            if (location.radius_editable) {\n              resizeMarker.addEventListener(\n                \"dragend\",\n                // @ts-ignore\n                (ev: DragEndEvent) => this._updateRadius(ev)\n              );\n            } else {\n              resizeMarker.remove();\n            }\n          });\n          locationMarkers[location.id] = circle;\n        } else {\n          circles[location.id] = circle;\n        }\n      }\n      if (\n        !location.radius ||\n        (!location.radius_editable && !location.location_editable)\n      ) {\n        const options: MarkerOptions = {\n          title: location.name,\n          draggable: location.location_editable,\n        };\n\n        if (icon) {\n          options.icon = icon;\n        }\n\n        const marker = this.Leaflet!.marker(\n          [location.latitude, location.longitude],\n          options\n        )\n          .addEventListener(\"dragend\", (ev: DragEndEvent) =>\n            this._updateLocation(ev)\n          )\n          .addEventListener(\n            // @ts-ignore\n            \"click\",\n            // @ts-ignore\n            (ev: MouseEvent) => this._markerClicked(ev)\n          );\n        (marker as any).id = location.id;\n\n        locationMarkers[location.id] = marker;\n      }\n    });\n    this._circles = circles;\n    this._locationMarkers = locationMarkers;\n    fireEvent(this, \"markers-updated\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-map {\n        display: block;\n        height: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-locations-editor\": HaLocationsEditor;\n  }\n}\n","import { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type {\n  LocationSelector,\n  LocationSelectorValue,\n} from \"../../data/selector\";\nimport type { HomeAssistant } from \"../../types\";\nimport type { SchemaUnion } from \"../ha-form/types\";\nimport type { MarkerLocation } from \"../map/ha-locations-editor\";\nimport \"../map/ha-locations-editor\";\nimport \"../ha-form/ha-form\";\n\n@customElement(\"ha-selector-location\")\nexport class HaLocationSelector extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public selector!: LocationSelector;\n\n  @property({ type: Object }) public value?: LocationSelectorValue;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean, reflect: true }) public disabled = false;\n\n  private _schema = memoizeOne(\n    (radius?: boolean, radius_readonly?: boolean) =>\n      [\n        {\n          name: \"\",\n          type: \"grid\",\n          schema: [\n            {\n              name: \"latitude\",\n              required: true,\n              selector: { number: { step: \"any\" } },\n            },\n            {\n              name: \"longitude\",\n              required: true,\n              selector: { number: { step: \"any\" } },\n            },\n          ],\n        },\n        ...(radius\n          ? [\n              {\n                name: \"radius\",\n                required: true,\n                default: 1000,\n                disabled: !!radius_readonly,\n                selector: { number: { min: 0, step: 1, mode: \"box\" } as const },\n              } as const,\n            ]\n          : []),\n      ] as const\n  );\n\n  protected willUpdate() {\n    if (!this.value) {\n      this.value = {\n        latitude: this.hass.config.latitude,\n        longitude: this.hass.config.longitude,\n        radius: this.selector.location?.radius ? 1000 : undefined,\n      };\n    }\n  }\n\n  protected render() {\n    return html`\n      <p>${this.label ? this.label : \"\"}</p>\n      <ha-locations-editor\n        class=\"flex\"\n        .hass=${this.hass}\n        .helper=${this.helper}\n        .locations=${this._location(this.selector, this.value)}\n        @location-updated=${this._locationChanged}\n        @radius-updated=${this._radiusChanged}\n      ></ha-locations-editor>\n      <ha-form\n        .hass=${this.hass}\n        .schema=${this._schema(\n          this.selector.location?.radius,\n          this.selector.location?.radius_readonly\n        )}\n        .data=${this.value}\n        .computeLabel=${this._computeLabel}\n        .disabled=${this.disabled}\n        @value-changed=${this._valueChanged}\n      ></ha-form>\n    `;\n  }\n\n  private _location = memoizeOne(\n    (\n      selector: LocationSelector,\n      value?: LocationSelectorValue\n    ): MarkerLocation[] => {\n      const computedStyles = getComputedStyle(this);\n      const zoneRadiusColor = selector.location?.radius\n        ? computedStyles.getPropertyValue(\"--zone-radius-color\") ||\n          computedStyles.getPropertyValue(\"--accent-color\")\n        : undefined;\n      return [\n        {\n          id: \"location\",\n          latitude:\n            !value || isNaN(value.latitude)\n              ? this.hass.config.latitude\n              : value.latitude,\n          longitude:\n            !value || isNaN(value.longitude)\n              ? this.hass.config.longitude\n              : value.longitude,\n          radius: selector.location?.radius ? value?.radius || 1000 : undefined,\n          radius_color: zoneRadiusColor,\n          icon:\n            selector.location?.icon || selector.location?.radius\n              ? \"mdi:map-marker-radius\"\n              : \"mdi:map-marker\",\n          location_editable: true,\n          radius_editable:\n            !!selector.location?.radius && !selector.location?.radius_readonly,\n        },\n      ];\n    }\n  );\n\n  private _locationChanged(ev: CustomEvent) {\n    const [latitude, longitude] = ev.detail.location;\n    fireEvent(this, \"value-changed\", {\n      value: { ...this.value, latitude, longitude },\n    });\n  }\n\n  private _radiusChanged(ev: CustomEvent) {\n    const radius = Math.round(ev.detail.radius);\n    fireEvent(this, \"value-changed\", { value: { ...this.value, radius } });\n  }\n\n  private _valueChanged(ev: CustomEvent) {\n    ev.stopPropagation();\n    const value = ev.detail.value;\n    const radius = Math.round(ev.detail.value.radius);\n\n    fireEvent(this, \"value-changed\", {\n      value: {\n        latitude: value.latitude,\n        longitude: value.longitude,\n        ...(this.selector.location?.radius &&\n        !this.selector.location?.radius_readonly\n          ? {\n              radius,\n            }\n          : {}),\n      },\n    });\n  }\n\n  private _computeLabel = (\n    entry: SchemaUnion<ReturnType<typeof this._schema>>\n  ): string => {\n    if (entry.name) {\n      return this.hass.localize(\n        `ui.components.selectors.location.${entry.name}`\n      );\n    }\n    return \"\";\n  };\n\n  static styles = css`\n    ha-locations-editor {\n      display: block;\n      height: 400px;\n      margin-bottom: 16px;\n    }\n    p {\n      margin-top: 0;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-location\": HaLocationSelector;\n  }\n}\n"],"names":[],"sourceRoot":""}