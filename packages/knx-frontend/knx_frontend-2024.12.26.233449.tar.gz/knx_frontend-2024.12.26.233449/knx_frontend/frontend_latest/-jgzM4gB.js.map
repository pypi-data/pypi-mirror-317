{"version":3,"file":"-jgzM4gB.js","mappings":";;AAwIA;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AAEA;AAGA;AAGA;AACA;;;;AAMA;;;;AAQA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;AAMA","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-language-picker.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-selector/ha-selector-language.ts"],"sourcesContent":["import type { CSSResultGroup, PropertyValues } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { stopPropagation } from \"../common/dom/stop_propagation\";\nimport { formatLanguageCode } from \"../common/language/format_language\";\nimport { caseInsensitiveStringCompare } from \"../common/string/compare\";\nimport type { FrontendLocaleData } from \"../data/translation\";\nimport { translationMetadata } from \"../resources/translations-metadata\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-list-item\";\nimport \"./ha-select\";\nimport type { HaSelect } from \"./ha-select\";\n\n@customElement(\"ha-language-picker\")\nexport class HaLanguagePicker extends LitElement {\n  @property() public value?: string;\n\n  @property() public label?: string;\n\n  @property({ type: Array }) public languages?: string[];\n\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true }) public disabled = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @property({ type: Boolean }) public nativeName = false;\n\n  @property({ type: Boolean }) public noSort = false;\n\n  @state() _defaultLanguages: string[] = [];\n\n  @query(\"ha-select\") private _select!: HaSelect;\n\n  protected firstUpdated(changedProps: PropertyValues) {\n    super.firstUpdated(changedProps);\n    this._computeDefaultLanguageOptions();\n  }\n\n  protected updated(changedProperties: PropertyValues) {\n    super.updated(changedProperties);\n\n    const localeChanged =\n      changedProperties.has(\"hass\") &&\n      this.hass &&\n      changedProperties.get(\"hass\") &&\n      changedProperties.get(\"hass\").locale.language !==\n        this.hass.locale.language;\n    if (\n      changedProperties.has(\"languages\") ||\n      changedProperties.has(\"value\") ||\n      localeChanged\n    ) {\n      this._select.layoutOptions();\n      if (this._select.value !== this.value) {\n        fireEvent(this, \"value-changed\", { value: this._select.value });\n      }\n      if (!this.value) {\n        return;\n      }\n      const languageOptions = this._getLanguagesOptions(\n        this.languages ?? this._defaultLanguages,\n        this.nativeName,\n        this.hass?.locale\n      );\n      const selectedItemIndex = languageOptions.findIndex(\n        (option) => option.value === this.value\n      );\n      if (selectedItemIndex === -1) {\n        this.value = undefined;\n      }\n      if (localeChanged) {\n        this._select.select(selectedItemIndex);\n      }\n    }\n  }\n\n  private _getLanguagesOptions = memoizeOne(\n    (languages: string[], nativeName: boolean, locale?: FrontendLocaleData) => {\n      let options: { label: string; value: string }[] = [];\n\n      if (nativeName) {\n        const translations = translationMetadata.translations;\n        options = languages.map((lang) => {\n          let label = translations[lang]?.nativeName;\n          if (!label) {\n            try {\n              // this will not work if Intl.DisplayNames is polyfilled, it will return in the language of the user\n              label = new Intl.DisplayNames(lang, {\n                type: \"language\",\n                fallback: \"code\",\n              }).of(lang)!;\n            } catch (err) {\n              label = lang;\n            }\n          }\n          return {\n            value: lang,\n            label,\n          };\n        });\n      } else if (locale) {\n        options = languages.map((lang) => ({\n          value: lang,\n          label: formatLanguageCode(lang, locale),\n        }));\n      }\n\n      if (!this.noSort && locale) {\n        options.sort((a, b) =>\n          caseInsensitiveStringCompare(a.label, b.label, locale.language)\n        );\n      }\n      return options;\n    }\n  );\n\n  private _computeDefaultLanguageOptions() {\n    this._defaultLanguages = Object.keys(translationMetadata.translations);\n  }\n\n  protected render() {\n    const languageOptions = this._getLanguagesOptions(\n      this.languages ?? this._defaultLanguages,\n      this.nativeName,\n      this.hass?.locale\n    );\n\n    const value =\n      this.value ?? (this.required ? languageOptions[0]?.value : this.value);\n\n    return html`\n      <ha-select\n        .label=${this.label ??\n        (this.hass?.localize(\"ui.components.language-picker.language\") ||\n          \"Language\")}\n        .value=${value || \"\"}\n        .required=${this.required}\n        .disabled=${this.disabled}\n        @selected=${this._changed}\n        @closed=${stopPropagation}\n        fixedMenuPosition\n        naturalMenuWidth\n      >\n        ${languageOptions.length === 0\n          ? html`<ha-list-item value=\"\"\n              >${this.hass?.localize(\n                \"ui.components.language-picker.no_languages\"\n              ) || \"No languages\"}</ha-list-item\n            >`\n          : languageOptions.map(\n              (option) => html`\n                <ha-list-item .value=${option.value}\n                  >${option.label}</ha-list-item\n                >\n              `\n            )}\n      </ha-select>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-select {\n        width: 100%;\n      }\n    `;\n  }\n\n  private _changed(ev): void {\n    const target = ev.target as HaSelect;\n    if (target.value === \"\" || target.value === this.value) {\n      return;\n    }\n    this.value = target.value;\n    fireEvent(this, \"value-changed\", { value: this.value });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-language-picker\": HaLanguagePicker;\n  }\n}\n","import { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport type { LanguageSelector } from \"../../data/selector\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../ha-language-picker\";\n\n@customElement(\"ha-selector-language\")\nexport class HaLanguageSelector extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public selector!: LanguageSelector;\n\n  @property() public value?: any;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = true;\n\n  protected render() {\n    return html`\n      <ha-language-picker\n        .hass=${this.hass}\n        .value=${this.value}\n        .label=${this.label}\n        .helper=${this.helper}\n        .languages=${this.selector.language?.languages}\n        .nativeName=${Boolean(this.selector?.language?.native_name)}\n        .noSort=${Boolean(this.selector?.language?.no_sort)}\n        .disabled=${this.disabled}\n        .required=${this.required}\n      ></ha-language-picker>\n    `;\n  }\n\n  static styles = css`\n    ha-language-picker {\n      width: 100%;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-language\": HaLanguageSelector;\n  }\n}\n"],"names":[],"sourceRoot":""}