# -*- coding: utf-8 -*-
"""Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fdbWbsZgYTqDMrbVlC0MVfjGy8HRutCm
"""

from pandas import read_csv
from pandas import DataFrame
from pandas import concat
import pandas as pd
import numpy as np
import matplotlib.dates as mdates
import matplotlib.colors as mcolors
import matplotlib.pyplot as plt
from .Models import replace_negatives
from .Predictions import individual_model_weekly_count, individual_model_weekly_MAPE

#generalized version
def visualize_weekly_case_count_all_model_each_wave(WAVES, predictions, delay_list, model_evaluation_dictionary, recent_week_count, models):
    """
    Visualizes weekly case counts with predictions for ARIMA and ML models.
    """
    # Generate per-model metrics (A_dict, B_dict, etc.)
    model_dicts = individual_model_weekly_count(WAVES, predictions, delay_list, model_evaluation_dictionary, models)
    #print(model_dicts)
    #model_dicts = {}
    #for model_name in models.keys():
        #model_dicts[model_name] = model_results[model_name]

    max_x_tick = 25  # Maximum number of x-tick labels

    for WAVE in WAVES:
        waveID = WAVE.waveID
        #print("Wave: ", waveID)

        fig = plt.figure(figsize=(25, 25))
        gs = fig.add_gridspec(len(predictions) + 1, len(delay_list), hspace=0.2, wspace=0.2)

        time = WAVE.get_wave_df().tail(recent_week_count).reset_index(drop=False)

        for delay in delay_list:
            from_date, to_date = WAVE.get_wave_test_start_date_with_delay(delay)

            for prediction_length in predictions:
                ax = fig.add_subplot(gs[prediction_length, delay])
                plt.subplots_adjust(left=0.04, right=0.9, top=0.9, bottom=0.01)

                # Plot each model's predictions dynamically

                for model_name, model_data in model_dicts.items():
                    wave_model_data = model_data[waveID]

                    #print(wave_model_data)
                    column_name = f"{model_name}_{prediction_length}"
                    #print('column_name: ', column_name)
                    #print(wave_model_data.columns)
                    #print('model_name: ', model_name, 'waveID', waveID, 'delay', delay, 'prediction_length', prediction_length)
                    if column_name in wave_model_data.columns:

                        ax.plot(wave_model_data[column_name].dropna(), label=model_name, linewidth=2)

                # Scatter plot for observed weekly cases
                ax.scatter(time['week'], time['weekcase'], color='black', label='Observed', zorder=3)

                # Customize Axes
                ax.axvline(x=from_date, color='grey', linestyle="--")
                ax.axvline(x=to_date, color='grey', linestyle="--")
                if delay == 0:
                    plt.ylabel(f"Prediction Length = {prediction_length} Week")
                if prediction_length == 1:
                    ax.set_title(f"Delay = {delay} Week")
                if prediction_length == 6:
                    ax.tick_params(axis='x', labelrotation=90)
                else:
                    ax.set_xticklabels([])
                    ax.set_xticks([])

        ax.legend(bbox_to_anchor=(-0.5, -0.5), ncol=4, fontsize=20)
        fig.text(0, 0.5, f'Weekly Case Count, Wave = {waveID}', va='center', rotation='vertical', fontsize="20")
        plt.show()

#generalized

from matplotlib.colors import ListedColormap
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

def visualize_weekly_MAPE_all_model_each_wave(WAVES, predictions, delay_list, model_evaluation_dictionary, recent_week_count, models):
    """
    Generalized function to visualize weekly MAPE for multiple models across waves.

    Parameters:
        WAVES: List of wave objects containing wave IDs.
        predictions: Model predictions.
        delay_list: List of delays for predictions.
        model_evaluation_dictionary: Dictionary of evaluation results.
        recent_week_count: Number of recent weeks to consider.
        models: Dictionary of models to visualize with their keys and associated methods (e.g., {'ARIMA': SARIMAX, 'RF': RandomForestRegressor}).
    """
    model_results_wave_collection = individual_model_weekly_MAPE(WAVES, predictions, delay_list, model_evaluation_dictionary, models)
    mape_wave_delay = {}
    print('individual_model_weekly_MAPE DONE')
    for WAVE in WAVES:  # Iterate over each wave
        waveID = WAVE.waveID
        fig, axes = plt.subplots(len(models), len(delay_list), sharex=True, sharey=True, figsize=(25, 10))
        gs = fig.add_gridspec(len(models), len(delay_list), hspace=0.2, wspace=0.2)
        plt.subplots_adjust(left=0.08, right=0.9, top=0.9, bottom=0.1)

        for model_index, (model_name, model_class) in enumerate(models.items()):  # Dynamically iterate over models
            model_results_collection = model_results_wave_collection[model_name][waveID]

            for delay in delay_list:  # Iterate over delays
                ax = axes[model_index, delay]
                mape_delay = pd.DataFrame()
                weeks = [x - 1 for x in predictions]
                print(weeks)
                # Retrieve and plot model results
                all_week_list, values_list = find_model_week_values_sum_delay(model_results_collection, delay, weeks)
                values_df = pd.DataFrame(values_list)
                values_df.columns = [model_name]
                #print('okk')
                # Bar and line plot
                all_week_list.plot(
                    kind='bar',
                    stacked=False,
                    width=1,
                    colormap=ListedColormap(sns.color_palette("muted", 10)),
                    figsize=(13, 15),
                    ax=ax
                )
                ax.plot(values_list, label="MAPE")
                ax.set_title(f"Delay = {delay} Week ")
                ax.get_legend().remove()

                mape_delay = pd.concat([mape_delay, values_df], axis=1, join='inner')  # Concatenate MAPE results
                mape_wave_delay[waveID] = mape_delay

                # Labeling
                if delay == 0:
                    ax.set_ylabel(model_name)
                if delay == len(delay_list) - 1 and model_index == len(models) - 1:
                    ax.legend(
                        ["MAPE", 'First Week', 'Second Week', 'Third Week', 'Fourth Week', 'Fifth Week', 'Sixth Week'],
                        loc='lower center',
                        bbox_to_anchor=(-2, -0.3),
                        ncol=7
                    )

        # Super labels
        fig.supxlabel(f"Prediction Length (Week), Wave = {waveID}")
        fig.supylabel("MAPE %")

    return mape_wave_delay

#generalized version

# Visualization function
def create_prediction_df(WAVES, predictions, delay_list, model_evaluation_dictionary, inFoldername_pre, task_name, filename):
    base_columns = ['Wave', 'Delay', 'Length', 'Observed']

    # Dynamically create visualization_columns
    visualization_columns = base_columns + list(models.keys())
    visualization_data = pd.DataFrame(columns=visualization_columns)
    visualization_data_dictionary = {}

    for WAVE in WAVES:
        waveID = WAVE.waveID
        for prediction_length in predictions:
            for delay in delay_list:
                print("prediction_length: ", prediction_length, "delay: ", delay, "Wave: ", waveID)
                wave_delay_prediction_length_key = f'wave {waveID} delay {delay} prediction_length {prediction_length}'

                metric_row = model_evaluation_dictionary[wave_delay_prediction_length_key]

                # Initialize list for model DataFrames
                model_dfs = []
                for model_name in models:
                    #print(metric_row[model_name])
                    model_data = metric_row[model_name]['Predictions']#.values[0]
                    #model_week_key = 'weekSTAT' if model_name == 'ARIMA' else 'weekML'
                    #observed_key = 'Observed_fit_train_pred_test_STAT' if model_name == 'ARIMA' else 'Observed_fit_train_pred_test_ML'

                    week_values = metric_row[model_name]['Weeks']#.values[0]#weekSTAT and weekML
                    observed_values = metric_row[model_name]['Observed']#.values[0]#Observed_fit_train_pred_test_STAT and Observed_fit_train_pred_test_ML

                    #print('OK')
                    #print(week_values)
                    #print(observed_values)
                    # Create DataFrame for each model
                    model_df = pd.DataFrame(model_data).reset_index(drop=True)
                    #print('OKK')
                    model_df['Weeks'] = week_values
                    model_df['Observed'] = observed_values
                    model_df.columns = [model_name, 'Weeks', 'Observed']
                    model_dfs.append(model_df)



                # Merge all model DataFrames on 'week' and 'Observed'#all model merge here, not only three
                result = model_dfs[0]
                for df in model_dfs[1:]:
                    result = pd.merge(result, df, on=['Weeks', 'Observed'], how='inner')

                # Add metadata columns
                result['Wave'] = waveID
                result['Delay'] = delay
                result['Length'] = prediction_length

                # Save the result
                visualization_data_dictionary[wave_delay_prediction_length_key] = result
                visualization_data = pd.concat([visualization_data, result])
                visualization_data.reset_index(drop=True, inplace=True)

    # Save final visualization data
    visualization_data.to_csv(inFoldername_pre + task_name + '_model_predictions_' + filename)
    return visualization_data, visualization_data_dictionary #one is dictionary, one is dataframe columns as keys

def visualize_wave_delays(data_dict):
    """
    Visualize the date ranges for wave-delay combinations,
    with vertical lines for delay 0 only and unique colors for each key.

    Parameters:
        data_dict (dict): Dictionary with wave-delay keys and date ranges.

    Returns:
        None: Displays the visualization.
    """
    # Initialize plot
    fig, ax = plt.subplots(figsize=(14, 8))

    # Define colors for each segment
    segment_colors = {'all': 'skyblue', 'train': 'lightgreen', 'test': 'salmon'}

    # Generate unique colors for vertical lines (using tab10 colormap)
    unique_colors = list(mcolors.TABLEAU_COLORS.values())  # Use a list of distinguishable colors
    print('len(unique_colors)', len(unique_colors))

    # Find min and max date for the x-axis
    min_date = min([r['all'].index[0] for r in data_dict.values()])
    max_date = max([r['all'].index[-1] for r in data_dict.values()])
    color_index = 0
    # Iterate over data_dict to plot ranges and add vertical lines for delay 0
    for i, (key, ranges) in enumerate(data_dict.items()):
        # Assign a unique color for this key


        # Check if 'delay 0' is in the key
        if 'delay 0' in key:
            line_color = unique_colors[color_index % len(unique_colors)]
            color_index += 1
            print('line_color', line_color)
            # Add vertical dashed lines for start and end of 'test'
            test_start_date = ranges['test'].index[0]
            len_test = len(ranges['test'])
            print('len_test', len_test)
            test_end_date = ranges['test'].index[len_test-1]
            #ax.axvline(x=test_start_date, color=line_color, linestyle="--", linewidth=1.5, label=f"{key} Test Start")
            ax.axvline(x=test_end_date, color=line_color, linestyle="--", linewidth=1.5, label=f"{key} Test End")
            print(f"Test Start Date for {key}: {test_start_date}")
            print(f"Test End Date for {key}: {test_end_date}")

        # Plot 'all', 'train', and 'test' ranges
        for label, date_range in ranges.items():
            start_date = date_range.index[0]
            end_date = date_range.index[-1]
            ax.plot([start_date, end_date], [i, i],
                    label=f"{key} - {label}" if label == 'all' else None,
                    color=segment_colors[label], lw=6)

    # Configure x-axis
    ax.set_xlim(min_date, max_date)  # Set x-axis range
    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=5))  # Ticks every 5 weeks
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m-%d"))
    plt.xticks(rotation=45)

    # Configure y-axis
    ax.set_yticks(range(len(data_dict)))
    ax.set_yticklabels(data_dict.keys())

    # Add axis labels and title
    ax.set_title("Wave-Delay Combinations", fontsize=14)
    ax.set_xlabel("Date", fontsize=12)
    ax.set_ylabel("Wave-Delay Combination", fontsize=12)

    # Add legend
    legend_labels = [
        plt.Line2D([0], [0], color=segment_colors['all'], lw=6, label='All Data'),
        plt.Line2D([0], [0], color=segment_colors['train'], lw=6, label='Training Data'),
        plt.Line2D([0], [0], color=segment_colors['test'], lw=6, label='Testing Data')
    ]
    ax.legend(handles=legend_labels, loc="upper left", fontsize=10)

    # Display plot
    plt.tight_layout()
    plt.show()

#no need

#Visualization.py

def process_metrics_df(WAVE, frame, recent_week_count):#cloumn_name
  #print(frame)
  metrics_df = pd.concat(frame, axis = 1).tail(recent_week_count)
  #print(metrics_df.head())
  #metrics_df.columns = cloumn_name
  metrics_df.reset_index(drop=True)
  metrics_df.index = WAVE.get_wave_df().tail(32).index#to get the week as index
  metrics_df= metrics_df.map(replace_negatives)
  return metrics_df

# Generalized Visualization.py
def create_MAPE_df(WAVES, predictions, delay_list, model_evaluation_dictionary, inFoldername_pre, task_name, filename, models):
    visualization_data_dictionary = {}
    for WAVE in WAVES:
        waveID = WAVE.waveID
        for prediction_length in predictions:
            for delay in delay_list:
                print("prediction_length: ", prediction_length, "delay: ", delay, "Wave: ", waveID)
                wave_delay_prediction_length_key = f'wave {waveID} delay {delay} prediction_length {prediction_length}'

                metric_row = model_evaluation_dictionary[wave_delay_prediction_length_key]
                print(metric_row)
                model_dataframes = {}
                for model_name, model_class in models.items():

                    model_data = metric_row[model_name]['Fit_Pred']


                    model_mape = metric_row[model_name]['MAPE']#.values[0]
                    week_values = metric_row[model_name]['Weeks']#.values[0]
                    observed_values = metric_row[model_name]['Observed']#.values[0]

                    model_data['week'] = week_values
                    model_data['Observed'] = observed_values
                    model_data.columns = [model_name, 'week', 'Observed']
                    #print(model_data)
                    model_dataframes[model_name] = model_data

                # Merge the dataframes for all models
                task = model_dataframes[list(models.keys())[0]]
                for model_name in list(models.keys())[1:]:
                    task = pd.merge(task, model_dataframes[model_name], on=['week', 'Observed'], how='inner')

                task = task.set_index('week')

                # Capture the MAPE values for each model to track performance per wave
                #for model_name in models.keys():
                #    model_task = metric_row['MAPE']#.values[0]

                visualization_data_dictionary[wave_delay_prediction_length_key] = task

    return visualization_data_dictionary

#generalized

def plot_predictions(wave_tasks, labels, delay, prediction_length, MAPE_data_dictionary, models, observed_label='Observed', recent_week_count=None):
    """
    Generalized function to plot predictions for multiple ML models and ARIMA.

    Parameters:
    - wave_tasks: List of wave task objects
    - delay: Delay parameter
    - prediction_length: Prediction length parameter
    - MAPE_data_dictionary: Dictionary containing MAPE data for each wave, delay, and prediction length
    - models: Dictionary of models to include in the plot
    - observed_label: Column name for the observed data
    - recent_week_count: Optional. Number of weeks to consider for plotting. Defaults to None (all data).
    """
    fig = plt.figure(figsize=(16, 10))
    plt.subplots_adjust(left=0.1, right=1, top=1, bottom=0.15)
    gs = fig.add_gridspec(len(wave_tasks), 1, hspace=0, wspace=0)
    i = 0

    #labels = ['', " & 2", " & 2 & 1"]  # Example labels for waves
    for wave in wave_tasks:
        waveID = wave.waveID
        wave_delay_prediction_length_key = f'wave {waveID} delay {delay} prediction_length {prediction_length}'
        task = MAPE_data_dictionary[wave_delay_prediction_length_key]

        # Extract recent weeks if specified
        if recent_week_count:
            task = task.tail(recent_week_count).reset_index(drop=True)

        ax = fig.add_subplot(gs[i, 0])

        # Plot each model's predictions
        for model_name in models.keys():
            if model_name in task.columns:
                ax.plot(task.index, task[model_name], label=model_name, linestyle='-', lw=1.5)

        # Plot observed data
        if observed_label in task.columns:
            ax.plot(task.index, task[observed_label], label=observed_label, color='black', linestyle='dotted')

        ax.set_ylabel("Wave "+labels[i], fontsize=13)

        i += 1
        if i >= 2:
            ax.legend(loc='lower center', bbox_to_anchor=(1.05, 1), ncol=1)
            ax.set_xticklabels(task.index, rotation=45)

        ax.axvline('2023-10-08', color='black', linestyle='--', lw=2)  # Example date for a vertical line

    # Adding title and labels
    fig.supxlabel('Week', fontsize=16)
    fig.supylabel("Covid Cases", fontsize=16)
    plt.show()