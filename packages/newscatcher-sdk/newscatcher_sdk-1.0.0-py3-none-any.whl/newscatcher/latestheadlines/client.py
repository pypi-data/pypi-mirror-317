# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from .types.latest_headlines_get_response import LatestHeadlinesGetResponse
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.latest_headlines_request_by_parse_date import LatestHeadlinesRequestByParseDate
from .types.latest_headlines_request_ranked_only import LatestHeadlinesRequestRankedOnly
from .types.latest_headlines_request_is_headline import LatestHeadlinesRequestIsHeadline
from .types.latest_headlines_request_is_opinion import LatestHeadlinesRequestIsOpinion
from .types.latest_headlines_request_is_paid_content import LatestHeadlinesRequestIsPaidContent
from .types.latest_headlines_request_word_count_min import LatestHeadlinesRequestWordCountMin
from .types.latest_headlines_request_word_count_max import LatestHeadlinesRequestWordCountMax
from .types.latest_headlines_request_page import LatestHeadlinesRequestPage
from .types.latest_headlines_request_page_size import LatestHeadlinesRequestPageSize
from .types.latest_headlines_request_clustering_enabled import LatestHeadlinesRequestClusteringEnabled
from .types.latest_headlines_request_clustering_threshold import LatestHeadlinesRequestClusteringThreshold
from .types.latest_headlines_post_response import LatestHeadlinesPostResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class LatestheadlinesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        *,
        lang: str,
        not_lang: str,
        countries: str,
        not_countries: str,
        sources: str,
        predefined_sources: str,
        not_sources: str,
        not_author_name: str,
        parent_url: str,
        all_links: str,
        all_domain_links: str,
        iptc_tags: str,
        not_iptc_tags: str,
        iab_tags: str,
        not_iab_tags: str,
        when: typing.Optional[str] = None,
        by_parse_date: typing.Optional[str] = None,
        sort_by: typing.Optional[str] = None,
        ranked_only: typing.Optional[str] = None,
        is_headline: typing.Optional[str] = None,
        is_opinion: typing.Optional[str] = None,
        is_paid_content: typing.Optional[str] = None,
        word_count_min: typing.Optional[str] = None,
        word_count_max: typing.Optional[str] = None,
        page: typing.Optional[str] = None,
        page_size: typing.Optional[str] = None,
        clustering_variable: typing.Optional[str] = None,
        clustering_enabled: typing.Optional[str] = None,
        clustering_threshold: typing.Optional[float] = None,
        include_nlp_data: typing.Optional[bool] = None,
        has_nlp: typing.Optional[bool] = None,
        theme: typing.Optional[str] = None,
        not_theme: typing.Optional[str] = None,
        org_entity_name: typing.Optional[str] = None,
        per_entity_name: typing.Optional[str] = None,
        loc_entity_name: typing.Optional[str] = None,
        misc_entity_name: typing.Optional[str] = None,
        title_sentiment_min: typing.Optional[float] = None,
        title_sentiment_max: typing.Optional[float] = None,
        content_sentiment_min: typing.Optional[float] = None,
        content_sentiment_max: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> LatestHeadlinesGetResponse:
        """
        This endpoint allows you to get latest headlines. You need to specify since when you want to get the latest headlines. You can also filter by language, country, source, and more.

        Parameters
        ----------
        lang : str

        not_lang : str

        countries : str

        not_countries : str

        sources : str

        predefined_sources : str

        not_sources : str

        not_author_name : str

        parent_url : str

        all_links : str

        all_domain_links : str

        iptc_tags : str

        not_iptc_tags : str

        iab_tags : str

        not_iab_tags : str

        when : typing.Optional[str]

        by_parse_date : typing.Optional[str]

        sort_by : typing.Optional[str]

        ranked_only : typing.Optional[str]

        is_headline : typing.Optional[str]

        is_opinion : typing.Optional[str]

        is_paid_content : typing.Optional[str]

        word_count_min : typing.Optional[str]

        word_count_max : typing.Optional[str]

        page : typing.Optional[str]

        page_size : typing.Optional[str]

        clustering_variable : typing.Optional[str]

        clustering_enabled : typing.Optional[str]

        clustering_threshold : typing.Optional[float]

        include_nlp_data : typing.Optional[bool]

        has_nlp : typing.Optional[bool]

        theme : typing.Optional[str]

        not_theme : typing.Optional[str]

        org_entity_name : typing.Optional[str]

        per_entity_name : typing.Optional[str]

        loc_entity_name : typing.Optional[str]

        misc_entity_name : typing.Optional[str]

        title_sentiment_min : typing.Optional[float]

        title_sentiment_max : typing.Optional[float]

        content_sentiment_min : typing.Optional[float]

        content_sentiment_max : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        LatestHeadlinesGetResponse
            Successful Response

        Examples
        --------
        from newscatcher import NewscatcherApi

        client = NewscatcherApi(
            api_token="YOUR_API_TOKEN",
        )
        client.latestheadlines.get(
            lang="lang",
            not_lang="not_lang",
            countries="countries",
            not_countries="not_countries",
            sources="sources",
            predefined_sources="predefined_sources",
            not_sources="not_sources",
            not_author_name="not_author_name",
            parent_url="parent_url",
            all_links="all_links",
            all_domain_links="all_domain_links",
            iptc_tags="iptc_tags",
            not_iptc_tags="not_iptc_tags",
            iab_tags="iab_tags",
            not_iab_tags="not_iab_tags",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/latest_headlines",
            method="GET",
            params={
                "when": when,
                "by_parse_date": by_parse_date,
                "sort_by": sort_by,
                "lang": lang,
                "not_lang": not_lang,
                "countries": countries,
                "not_countries": not_countries,
                "sources": sources,
                "predefined_sources": predefined_sources,
                "not_sources": not_sources,
                "not_author_name": not_author_name,
                "ranked_only": ranked_only,
                "is_headline": is_headline,
                "is_opinion": is_opinion,
                "is_paid_content": is_paid_content,
                "parent_url": parent_url,
                "all_links": all_links,
                "all_domain_links": all_domain_links,
                "word_count_min": word_count_min,
                "word_count_max": word_count_max,
                "page": page,
                "page_size": page_size,
                "clustering_variable": clustering_variable,
                "clustering_enabled": clustering_enabled,
                "clustering_threshold": clustering_threshold,
                "include_nlp_data": include_nlp_data,
                "has_nlp": has_nlp,
                "theme": theme,
                "not_theme": not_theme,
                "ORG_entity_name": org_entity_name,
                "PER_entity_name": per_entity_name,
                "LOC_entity_name": loc_entity_name,
                "MISC_entity_name": misc_entity_name,
                "title_sentiment_min": title_sentiment_min,
                "title_sentiment_max": title_sentiment_max,
                "content_sentiment_min": content_sentiment_min,
                "content_sentiment_max": content_sentiment_max,
                "iptc_tags": iptc_tags,
                "not_iptc_tags": not_iptc_tags,
                "iab_tags": iab_tags,
                "not_iab_tags": not_iab_tags,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    LatestHeadlinesGetResponse,
                    parse_obj_as(
                        type_=LatestHeadlinesGetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def post(
        self,
        *,
        when: typing.Optional[str] = OMIT,
        by_parse_date: typing.Optional[LatestHeadlinesRequestByParseDate] = OMIT,
        sort_by: typing.Optional[str] = OMIT,
        lang: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_lang: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        countries: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_countries: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        sources: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        predefined_sources: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_sources: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_author_name: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        ranked_only: typing.Optional[LatestHeadlinesRequestRankedOnly] = OMIT,
        is_headline: typing.Optional[LatestHeadlinesRequestIsHeadline] = OMIT,
        is_opinion: typing.Optional[LatestHeadlinesRequestIsOpinion] = OMIT,
        is_paid_content: typing.Optional[LatestHeadlinesRequestIsPaidContent] = OMIT,
        parent_url: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        all_links: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        all_domain_links: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        word_count_min: typing.Optional[LatestHeadlinesRequestWordCountMin] = OMIT,
        word_count_max: typing.Optional[LatestHeadlinesRequestWordCountMax] = OMIT,
        page: typing.Optional[LatestHeadlinesRequestPage] = OMIT,
        page_size: typing.Optional[LatestHeadlinesRequestPageSize] = OMIT,
        clustering_variable: typing.Optional[str] = OMIT,
        clustering_enabled: typing.Optional[LatestHeadlinesRequestClusteringEnabled] = OMIT,
        clustering_threshold: typing.Optional[LatestHeadlinesRequestClusteringThreshold] = OMIT,
        include_nlp_data: typing.Optional[bool] = OMIT,
        has_nlp: typing.Optional[bool] = OMIT,
        theme: typing.Optional[str] = OMIT,
        not_theme: typing.Optional[str] = OMIT,
        org_entity_name: typing.Optional[str] = OMIT,
        per_entity_name: typing.Optional[str] = OMIT,
        loc_entity_name: typing.Optional[str] = OMIT,
        misc_entity_name: typing.Optional[str] = OMIT,
        title_sentiment_min: typing.Optional[float] = OMIT,
        title_sentiment_max: typing.Optional[float] = OMIT,
        content_sentiment_min: typing.Optional[float] = OMIT,
        content_sentiment_max: typing.Optional[float] = OMIT,
        iptc_tags: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_iptc_tags: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        iab_tags: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_iab_tags: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> LatestHeadlinesPostResponse:
        """
        This endpoint allows you to get latest headlines. You need to specify since when you want to get the latest headlines. You can also filter by language, country, source, and more.

        Parameters
        ----------
        when : typing.Optional[str]

        by_parse_date : typing.Optional[LatestHeadlinesRequestByParseDate]

        sort_by : typing.Optional[str]

        lang : typing.Optional[typing.Optional[typing.Any]]

        not_lang : typing.Optional[typing.Optional[typing.Any]]

        countries : typing.Optional[typing.Optional[typing.Any]]

        not_countries : typing.Optional[typing.Optional[typing.Any]]

        sources : typing.Optional[typing.Optional[typing.Any]]

        predefined_sources : typing.Optional[typing.Optional[typing.Any]]

        not_sources : typing.Optional[typing.Optional[typing.Any]]

        not_author_name : typing.Optional[typing.Optional[typing.Any]]

        ranked_only : typing.Optional[LatestHeadlinesRequestRankedOnly]

        is_headline : typing.Optional[LatestHeadlinesRequestIsHeadline]

        is_opinion : typing.Optional[LatestHeadlinesRequestIsOpinion]

        is_paid_content : typing.Optional[LatestHeadlinesRequestIsPaidContent]

        parent_url : typing.Optional[typing.Optional[typing.Any]]

        all_links : typing.Optional[typing.Optional[typing.Any]]

        all_domain_links : typing.Optional[typing.Optional[typing.Any]]

        word_count_min : typing.Optional[LatestHeadlinesRequestWordCountMin]

        word_count_max : typing.Optional[LatestHeadlinesRequestWordCountMax]

        page : typing.Optional[LatestHeadlinesRequestPage]

        page_size : typing.Optional[LatestHeadlinesRequestPageSize]

        clustering_variable : typing.Optional[str]

        clustering_enabled : typing.Optional[LatestHeadlinesRequestClusteringEnabled]

        clustering_threshold : typing.Optional[LatestHeadlinesRequestClusteringThreshold]

        include_nlp_data : typing.Optional[bool]

        has_nlp : typing.Optional[bool]

        theme : typing.Optional[str]

        not_theme : typing.Optional[str]

        org_entity_name : typing.Optional[str]

        per_entity_name : typing.Optional[str]

        loc_entity_name : typing.Optional[str]

        misc_entity_name : typing.Optional[str]

        title_sentiment_min : typing.Optional[float]

        title_sentiment_max : typing.Optional[float]

        content_sentiment_min : typing.Optional[float]

        content_sentiment_max : typing.Optional[float]

        iptc_tags : typing.Optional[typing.Optional[typing.Any]]

        not_iptc_tags : typing.Optional[typing.Optional[typing.Any]]

        iab_tags : typing.Optional[typing.Optional[typing.Any]]

        not_iab_tags : typing.Optional[typing.Optional[typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        LatestHeadlinesPostResponse
            Successful Response

        Examples
        --------
        from newscatcher import NewscatcherApi

        client = NewscatcherApi(
            api_token="YOUR_API_TOKEN",
        )
        client.latestheadlines.post()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/latest_headlines",
            method="POST",
            json={
                "when": when,
                "by_parse_date": convert_and_respect_annotation_metadata(
                    object_=by_parse_date, annotation=LatestHeadlinesRequestByParseDate, direction="write"
                ),
                "sort_by": sort_by,
                "lang": lang,
                "not_lang": not_lang,
                "countries": countries,
                "not_countries": not_countries,
                "sources": sources,
                "predefined_sources": predefined_sources,
                "not_sources": not_sources,
                "not_author_name": not_author_name,
                "ranked_only": convert_and_respect_annotation_metadata(
                    object_=ranked_only, annotation=LatestHeadlinesRequestRankedOnly, direction="write"
                ),
                "is_headline": convert_and_respect_annotation_metadata(
                    object_=is_headline, annotation=LatestHeadlinesRequestIsHeadline, direction="write"
                ),
                "is_opinion": convert_and_respect_annotation_metadata(
                    object_=is_opinion, annotation=LatestHeadlinesRequestIsOpinion, direction="write"
                ),
                "is_paid_content": convert_and_respect_annotation_metadata(
                    object_=is_paid_content, annotation=LatestHeadlinesRequestIsPaidContent, direction="write"
                ),
                "parent_url": parent_url,
                "all_links": all_links,
                "all_domain_links": all_domain_links,
                "word_count_min": convert_and_respect_annotation_metadata(
                    object_=word_count_min, annotation=LatestHeadlinesRequestWordCountMin, direction="write"
                ),
                "word_count_max": convert_and_respect_annotation_metadata(
                    object_=word_count_max, annotation=LatestHeadlinesRequestWordCountMax, direction="write"
                ),
                "page": convert_and_respect_annotation_metadata(
                    object_=page, annotation=LatestHeadlinesRequestPage, direction="write"
                ),
                "page_size": convert_and_respect_annotation_metadata(
                    object_=page_size, annotation=LatestHeadlinesRequestPageSize, direction="write"
                ),
                "clustering_variable": clustering_variable,
                "clustering_enabled": convert_and_respect_annotation_metadata(
                    object_=clustering_enabled, annotation=LatestHeadlinesRequestClusteringEnabled, direction="write"
                ),
                "clustering_threshold": convert_and_respect_annotation_metadata(
                    object_=clustering_threshold,
                    annotation=LatestHeadlinesRequestClusteringThreshold,
                    direction="write",
                ),
                "include_nlp_data": include_nlp_data,
                "has_nlp": has_nlp,
                "theme": theme,
                "not_theme": not_theme,
                "ORG_entity_name": org_entity_name,
                "PER_entity_name": per_entity_name,
                "LOC_entity_name": loc_entity_name,
                "MISC_entity_name": misc_entity_name,
                "title_sentiment_min": title_sentiment_min,
                "title_sentiment_max": title_sentiment_max,
                "content_sentiment_min": content_sentiment_min,
                "content_sentiment_max": content_sentiment_max,
                "iptc_tags": iptc_tags,
                "not_iptc_tags": not_iptc_tags,
                "iab_tags": iab_tags,
                "not_iab_tags": not_iab_tags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    LatestHeadlinesPostResponse,
                    parse_obj_as(
                        type_=LatestHeadlinesPostResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncLatestheadlinesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        *,
        lang: str,
        not_lang: str,
        countries: str,
        not_countries: str,
        sources: str,
        predefined_sources: str,
        not_sources: str,
        not_author_name: str,
        parent_url: str,
        all_links: str,
        all_domain_links: str,
        iptc_tags: str,
        not_iptc_tags: str,
        iab_tags: str,
        not_iab_tags: str,
        when: typing.Optional[str] = None,
        by_parse_date: typing.Optional[str] = None,
        sort_by: typing.Optional[str] = None,
        ranked_only: typing.Optional[str] = None,
        is_headline: typing.Optional[str] = None,
        is_opinion: typing.Optional[str] = None,
        is_paid_content: typing.Optional[str] = None,
        word_count_min: typing.Optional[str] = None,
        word_count_max: typing.Optional[str] = None,
        page: typing.Optional[str] = None,
        page_size: typing.Optional[str] = None,
        clustering_variable: typing.Optional[str] = None,
        clustering_enabled: typing.Optional[str] = None,
        clustering_threshold: typing.Optional[float] = None,
        include_nlp_data: typing.Optional[bool] = None,
        has_nlp: typing.Optional[bool] = None,
        theme: typing.Optional[str] = None,
        not_theme: typing.Optional[str] = None,
        org_entity_name: typing.Optional[str] = None,
        per_entity_name: typing.Optional[str] = None,
        loc_entity_name: typing.Optional[str] = None,
        misc_entity_name: typing.Optional[str] = None,
        title_sentiment_min: typing.Optional[float] = None,
        title_sentiment_max: typing.Optional[float] = None,
        content_sentiment_min: typing.Optional[float] = None,
        content_sentiment_max: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> LatestHeadlinesGetResponse:
        """
        This endpoint allows you to get latest headlines. You need to specify since when you want to get the latest headlines. You can also filter by language, country, source, and more.

        Parameters
        ----------
        lang : str

        not_lang : str

        countries : str

        not_countries : str

        sources : str

        predefined_sources : str

        not_sources : str

        not_author_name : str

        parent_url : str

        all_links : str

        all_domain_links : str

        iptc_tags : str

        not_iptc_tags : str

        iab_tags : str

        not_iab_tags : str

        when : typing.Optional[str]

        by_parse_date : typing.Optional[str]

        sort_by : typing.Optional[str]

        ranked_only : typing.Optional[str]

        is_headline : typing.Optional[str]

        is_opinion : typing.Optional[str]

        is_paid_content : typing.Optional[str]

        word_count_min : typing.Optional[str]

        word_count_max : typing.Optional[str]

        page : typing.Optional[str]

        page_size : typing.Optional[str]

        clustering_variable : typing.Optional[str]

        clustering_enabled : typing.Optional[str]

        clustering_threshold : typing.Optional[float]

        include_nlp_data : typing.Optional[bool]

        has_nlp : typing.Optional[bool]

        theme : typing.Optional[str]

        not_theme : typing.Optional[str]

        org_entity_name : typing.Optional[str]

        per_entity_name : typing.Optional[str]

        loc_entity_name : typing.Optional[str]

        misc_entity_name : typing.Optional[str]

        title_sentiment_min : typing.Optional[float]

        title_sentiment_max : typing.Optional[float]

        content_sentiment_min : typing.Optional[float]

        content_sentiment_max : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        LatestHeadlinesGetResponse
            Successful Response

        Examples
        --------
        import asyncio

        from newscatcher import AsyncNewscatcherApi

        client = AsyncNewscatcherApi(
            api_token="YOUR_API_TOKEN",
        )


        async def main() -> None:
            await client.latestheadlines.get(
                lang="lang",
                not_lang="not_lang",
                countries="countries",
                not_countries="not_countries",
                sources="sources",
                predefined_sources="predefined_sources",
                not_sources="not_sources",
                not_author_name="not_author_name",
                parent_url="parent_url",
                all_links="all_links",
                all_domain_links="all_domain_links",
                iptc_tags="iptc_tags",
                not_iptc_tags="not_iptc_tags",
                iab_tags="iab_tags",
                not_iab_tags="not_iab_tags",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/latest_headlines",
            method="GET",
            params={
                "when": when,
                "by_parse_date": by_parse_date,
                "sort_by": sort_by,
                "lang": lang,
                "not_lang": not_lang,
                "countries": countries,
                "not_countries": not_countries,
                "sources": sources,
                "predefined_sources": predefined_sources,
                "not_sources": not_sources,
                "not_author_name": not_author_name,
                "ranked_only": ranked_only,
                "is_headline": is_headline,
                "is_opinion": is_opinion,
                "is_paid_content": is_paid_content,
                "parent_url": parent_url,
                "all_links": all_links,
                "all_domain_links": all_domain_links,
                "word_count_min": word_count_min,
                "word_count_max": word_count_max,
                "page": page,
                "page_size": page_size,
                "clustering_variable": clustering_variable,
                "clustering_enabled": clustering_enabled,
                "clustering_threshold": clustering_threshold,
                "include_nlp_data": include_nlp_data,
                "has_nlp": has_nlp,
                "theme": theme,
                "not_theme": not_theme,
                "ORG_entity_name": org_entity_name,
                "PER_entity_name": per_entity_name,
                "LOC_entity_name": loc_entity_name,
                "MISC_entity_name": misc_entity_name,
                "title_sentiment_min": title_sentiment_min,
                "title_sentiment_max": title_sentiment_max,
                "content_sentiment_min": content_sentiment_min,
                "content_sentiment_max": content_sentiment_max,
                "iptc_tags": iptc_tags,
                "not_iptc_tags": not_iptc_tags,
                "iab_tags": iab_tags,
                "not_iab_tags": not_iab_tags,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    LatestHeadlinesGetResponse,
                    parse_obj_as(
                        type_=LatestHeadlinesGetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def post(
        self,
        *,
        when: typing.Optional[str] = OMIT,
        by_parse_date: typing.Optional[LatestHeadlinesRequestByParseDate] = OMIT,
        sort_by: typing.Optional[str] = OMIT,
        lang: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_lang: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        countries: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_countries: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        sources: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        predefined_sources: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_sources: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_author_name: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        ranked_only: typing.Optional[LatestHeadlinesRequestRankedOnly] = OMIT,
        is_headline: typing.Optional[LatestHeadlinesRequestIsHeadline] = OMIT,
        is_opinion: typing.Optional[LatestHeadlinesRequestIsOpinion] = OMIT,
        is_paid_content: typing.Optional[LatestHeadlinesRequestIsPaidContent] = OMIT,
        parent_url: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        all_links: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        all_domain_links: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        word_count_min: typing.Optional[LatestHeadlinesRequestWordCountMin] = OMIT,
        word_count_max: typing.Optional[LatestHeadlinesRequestWordCountMax] = OMIT,
        page: typing.Optional[LatestHeadlinesRequestPage] = OMIT,
        page_size: typing.Optional[LatestHeadlinesRequestPageSize] = OMIT,
        clustering_variable: typing.Optional[str] = OMIT,
        clustering_enabled: typing.Optional[LatestHeadlinesRequestClusteringEnabled] = OMIT,
        clustering_threshold: typing.Optional[LatestHeadlinesRequestClusteringThreshold] = OMIT,
        include_nlp_data: typing.Optional[bool] = OMIT,
        has_nlp: typing.Optional[bool] = OMIT,
        theme: typing.Optional[str] = OMIT,
        not_theme: typing.Optional[str] = OMIT,
        org_entity_name: typing.Optional[str] = OMIT,
        per_entity_name: typing.Optional[str] = OMIT,
        loc_entity_name: typing.Optional[str] = OMIT,
        misc_entity_name: typing.Optional[str] = OMIT,
        title_sentiment_min: typing.Optional[float] = OMIT,
        title_sentiment_max: typing.Optional[float] = OMIT,
        content_sentiment_min: typing.Optional[float] = OMIT,
        content_sentiment_max: typing.Optional[float] = OMIT,
        iptc_tags: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_iptc_tags: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        iab_tags: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        not_iab_tags: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> LatestHeadlinesPostResponse:
        """
        This endpoint allows you to get latest headlines. You need to specify since when you want to get the latest headlines. You can also filter by language, country, source, and more.

        Parameters
        ----------
        when : typing.Optional[str]

        by_parse_date : typing.Optional[LatestHeadlinesRequestByParseDate]

        sort_by : typing.Optional[str]

        lang : typing.Optional[typing.Optional[typing.Any]]

        not_lang : typing.Optional[typing.Optional[typing.Any]]

        countries : typing.Optional[typing.Optional[typing.Any]]

        not_countries : typing.Optional[typing.Optional[typing.Any]]

        sources : typing.Optional[typing.Optional[typing.Any]]

        predefined_sources : typing.Optional[typing.Optional[typing.Any]]

        not_sources : typing.Optional[typing.Optional[typing.Any]]

        not_author_name : typing.Optional[typing.Optional[typing.Any]]

        ranked_only : typing.Optional[LatestHeadlinesRequestRankedOnly]

        is_headline : typing.Optional[LatestHeadlinesRequestIsHeadline]

        is_opinion : typing.Optional[LatestHeadlinesRequestIsOpinion]

        is_paid_content : typing.Optional[LatestHeadlinesRequestIsPaidContent]

        parent_url : typing.Optional[typing.Optional[typing.Any]]

        all_links : typing.Optional[typing.Optional[typing.Any]]

        all_domain_links : typing.Optional[typing.Optional[typing.Any]]

        word_count_min : typing.Optional[LatestHeadlinesRequestWordCountMin]

        word_count_max : typing.Optional[LatestHeadlinesRequestWordCountMax]

        page : typing.Optional[LatestHeadlinesRequestPage]

        page_size : typing.Optional[LatestHeadlinesRequestPageSize]

        clustering_variable : typing.Optional[str]

        clustering_enabled : typing.Optional[LatestHeadlinesRequestClusteringEnabled]

        clustering_threshold : typing.Optional[LatestHeadlinesRequestClusteringThreshold]

        include_nlp_data : typing.Optional[bool]

        has_nlp : typing.Optional[bool]

        theme : typing.Optional[str]

        not_theme : typing.Optional[str]

        org_entity_name : typing.Optional[str]

        per_entity_name : typing.Optional[str]

        loc_entity_name : typing.Optional[str]

        misc_entity_name : typing.Optional[str]

        title_sentiment_min : typing.Optional[float]

        title_sentiment_max : typing.Optional[float]

        content_sentiment_min : typing.Optional[float]

        content_sentiment_max : typing.Optional[float]

        iptc_tags : typing.Optional[typing.Optional[typing.Any]]

        not_iptc_tags : typing.Optional[typing.Optional[typing.Any]]

        iab_tags : typing.Optional[typing.Optional[typing.Any]]

        not_iab_tags : typing.Optional[typing.Optional[typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        LatestHeadlinesPostResponse
            Successful Response

        Examples
        --------
        import asyncio

        from newscatcher import AsyncNewscatcherApi

        client = AsyncNewscatcherApi(
            api_token="YOUR_API_TOKEN",
        )


        async def main() -> None:
            await client.latestheadlines.post()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/latest_headlines",
            method="POST",
            json={
                "when": when,
                "by_parse_date": convert_and_respect_annotation_metadata(
                    object_=by_parse_date, annotation=LatestHeadlinesRequestByParseDate, direction="write"
                ),
                "sort_by": sort_by,
                "lang": lang,
                "not_lang": not_lang,
                "countries": countries,
                "not_countries": not_countries,
                "sources": sources,
                "predefined_sources": predefined_sources,
                "not_sources": not_sources,
                "not_author_name": not_author_name,
                "ranked_only": convert_and_respect_annotation_metadata(
                    object_=ranked_only, annotation=LatestHeadlinesRequestRankedOnly, direction="write"
                ),
                "is_headline": convert_and_respect_annotation_metadata(
                    object_=is_headline, annotation=LatestHeadlinesRequestIsHeadline, direction="write"
                ),
                "is_opinion": convert_and_respect_annotation_metadata(
                    object_=is_opinion, annotation=LatestHeadlinesRequestIsOpinion, direction="write"
                ),
                "is_paid_content": convert_and_respect_annotation_metadata(
                    object_=is_paid_content, annotation=LatestHeadlinesRequestIsPaidContent, direction="write"
                ),
                "parent_url": parent_url,
                "all_links": all_links,
                "all_domain_links": all_domain_links,
                "word_count_min": convert_and_respect_annotation_metadata(
                    object_=word_count_min, annotation=LatestHeadlinesRequestWordCountMin, direction="write"
                ),
                "word_count_max": convert_and_respect_annotation_metadata(
                    object_=word_count_max, annotation=LatestHeadlinesRequestWordCountMax, direction="write"
                ),
                "page": convert_and_respect_annotation_metadata(
                    object_=page, annotation=LatestHeadlinesRequestPage, direction="write"
                ),
                "page_size": convert_and_respect_annotation_metadata(
                    object_=page_size, annotation=LatestHeadlinesRequestPageSize, direction="write"
                ),
                "clustering_variable": clustering_variable,
                "clustering_enabled": convert_and_respect_annotation_metadata(
                    object_=clustering_enabled, annotation=LatestHeadlinesRequestClusteringEnabled, direction="write"
                ),
                "clustering_threshold": convert_and_respect_annotation_metadata(
                    object_=clustering_threshold,
                    annotation=LatestHeadlinesRequestClusteringThreshold,
                    direction="write",
                ),
                "include_nlp_data": include_nlp_data,
                "has_nlp": has_nlp,
                "theme": theme,
                "not_theme": not_theme,
                "ORG_entity_name": org_entity_name,
                "PER_entity_name": per_entity_name,
                "LOC_entity_name": loc_entity_name,
                "MISC_entity_name": misc_entity_name,
                "title_sentiment_min": title_sentiment_min,
                "title_sentiment_max": title_sentiment_max,
                "content_sentiment_min": content_sentiment_min,
                "content_sentiment_max": content_sentiment_max,
                "iptc_tags": iptc_tags,
                "not_iptc_tags": not_iptc_tags,
                "iab_tags": iab_tags,
                "not_iab_tags": not_iab_tags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    LatestHeadlinesPostResponse,
                    parse_obj_as(
                        type_=LatestHeadlinesPostResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
